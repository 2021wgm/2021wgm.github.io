<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>js1 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="JS编写的位置:可写在外部文件中，然后引入script type&#x3D;”text&#x2F;javascript” src&#x3D;”js&#x2F;script.js” 也可以写在script  &#x2F;script 还可以 button onclick&#x3D;”” 字面量与变量:字面量都是一些不可改变的值 如 1，2，3 变量可以用来保存字面量，变量的值是可以任意改变的 声明变">
<meta property="og:type" content="article">
<meta property="og:title" content="js1">
<meta property="og:url" content="http://example.com/2022/02/14/js1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JS编写的位置:可写在外部文件中，然后引入script type&#x3D;”text&#x2F;javascript” src&#x3D;”js&#x2F;script.js” 也可以写在script  &#x2F;script 还可以 button onclick&#x3D;”” 字面量与变量:字面量都是一些不可改变的值 如 1，2，3 变量可以用来保存字面量，变量的值是可以任意改变的 声明变">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-02-14T10:40:51.000Z">
<meta property="article:modified_time" content="2022-03-30T10:04:51.629Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-js1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/14/js1/" class="article-date">
  <time class="dt-published" datetime="2022-02-14T10:40:51.000Z" itemprop="datePublished">2022-02-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      js1
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="JS编写的位置"><a href="#JS编写的位置" class="headerlink" title="JS编写的位置:"></a>JS编写的位置:</h4><p>可写在外部文件中，然后引入<br>script type&#x3D;”text&#x2F;javascript” src&#x3D;”js&#x2F;script.js”</p>
<p>也可以写在script  &#x2F;script</p>
<p>还可以 button onclick&#x3D;””<br><br/></p>
<h4 id="字面量与变量"><a href="#字面量与变量" class="headerlink" title="字面量与变量:"></a>字面量与变量:</h4><p>字面量都是一些不可改变的值 如 1，2，3</p>
<p>变量可以用来保存字面量，变量的值是可以任意改变的</p>
<p>声明变量  var a;<br><br/></p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符:"></a>标识符:</h4><p>js中所有可以由我们自主命名的都可以称为标识符</p>
<p>1 标识符可以含有 字母，数字，_,$,<br>2 标识符不能以数字开头<br>3 标识符不能是ES中的关键字(如:var,if)和保留字(如extend,class)<br>4 标识符一般采用驼峰命名法<br>  首字母小写，每个单词的开头字母大写，其余字母小写<br>如 helloworld<br>   helloWorld<br><br/></p>
<h4 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h4><p>数据类型指的就是字面量的类型<br>String 字符串<br>Number 数字<br>Boolean 布尔值<br>Null 空值<br>Undefined 未定义 6个基本<br>Symbol</p>
<p>Object 对象 一个引用</p>
<p>基本(值)类型:<br>string  number Boolean undefined null</p>
<p>对象(引用)类型:<br>Object:任意对象<br>Function:一种特别的对象(可以执行)<br>Array：一种特别的对象(数值下标,内部数据是有序的)</p>
<p>instanceof 判断对象的具体类型</p>
<p>typeof null ：  “object”<br>typeof undefined : “undefined”<br>typeof 函数名: “function”</p>
<p>typeof 可以判断： 数字 字符串 布尔值 undefined function<br>无法判断null和object object与array<br><br/></p>
<h4 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串:"></a>String字符串:</h4><p>JS中字符串需要用引号引起来<br>使用双引号或单引号都可以，但同种引号不要混着用<br>在字符串中可以使用\作为转义字符<br>&quot; 表示 “<br>&#39;表示’<br>\n表示换行<br>\表示<br><br/></p>
<h4 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型:"></a>Number类型:</h4><p>在JS中所有数值都是Number类型<br>包括整数和浮点数(小数)<br>JS中用来表示数字的最大值Number.MAX_VALUE<br>如果超过了最大值的大小则为Infinity字面量正无穷大,这个也是Number类型<br>NaN的类型也是Number,表示not a number不是一个数字<br>Number.MIN_VALUE表示0以上的最小值<br><br/></p>
<h4 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型:"></a>Boolean类型:</h4><p>值只有两个，主要用来逻辑判断<br>true 真<br>false 假<br><br/></p>
<h4 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined:"></a>null和undefined:</h4><p>null这个值专门用来表示一个空对象 typeof null 结果是 object<br>undefined 表示 声明一个变量，但是没有赋值 typeof undefined结果为undefined<br>null转成数字为0<br>undefined转成数字为NaN<br><br/></p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换:"></a>强制类型转换:</h4><p>将其他数据类型转换为String：<br>.toString()方法 不会影响原变量，但会将结果返回<br>null和undefined没有toString()方法，但可用下面的函数转换<br>调用String()函数</p>
<p>将其他数据类型转换为Number<br>转换方式一:<br>使用Number()函数<br>字符串转成数字:<br>1 如果是纯数字的字符串,则直接将其转换成数字<br>2 如果字符串中有非数字的内容，则直接转成NaN<br>3 如果字符串是空串或者里面全部都是空格，则转成0</p>
<p>布尔转成数字<br>true 1<br>false 0</p>
<p>null转成数字为0<br>undefined转成数字为NaN</p>
<p>转换方式二:<br>parseInt()函数 parseInt可以将一个字符串中的有效数字读取出来，然后转换成Number类型，但如果第一位就是非数字，name直接转为NaN<br>parseFloat()函数  parseFloat和parseInt类似，不同的是 parseFloat还可以获得有效的小数<br>对于非String类型使用parseInt或者parseFloat，会将其先转成字符串，然后再转成Number</p>
<p>将其他类型转成Boolean类型:<br>数字中：0和NaN转布尔都是false<br>字符串中:只有空串(“”)转布尔为false<br>null和undefined转布尔都为false<br><br/></p>
<h4 id="其他进制的数"><a href="#其他进制的数" class="headerlink" title="其他进制的数:"></a>其他进制的数:</h4><p>在js中，如果要表示16进制的数，需要以0x开头<br>var a&#x3D;0x10 结果为16</p>
<p>如果要表示8进制的数，需要以0开头<br>var a&#x3D;070 结果为56</p>
<p>如果要标识2进制的数，需要以0b开头<br>var a&#x3D;0b10 结果为 2</p>
<p>像var a&#x3D;”070”<br>parseInt(a);<br>这种字符串有的浏览器当成8进制，有的当成10进制度</p>
<p>解决方法:<br>parseInt(a,10)第一个表示参数，第二个表示进制<br><br/></p>
<h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符:"></a>算数运算符:</h4><p>+：对于非Number类型的进行计算，会将其转换为number类型，然后进行计算，并将结果返回。<br>任何值和NaN计算都为NaN(若是字符串相加除外)<br>任何一个值和字符串相加，都会将其先转换为字符串，然后进行拼串。<br>var a&#x3D;1;<br>a&#x3D;1+””;<br>结果为字符串1，这里是虽然是隐式转换，但过程中还是用到了 String（）函数</p>
<p>-,<em>,&#x2F;:<br>会将参与计算的值都转换为number类型，然后计算。<br>var a&#x3D;”1”;<br>a&#x3D;a-0;<br>a&#x3D;a</em>1;<br>a&#x3D;a&#x2F;1;<br>结果为Number类型的1,可以做隐式的类型转换。</p>
<p>%：取余。<br><br/></p>
<h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符:"></a>一元运算符:</h4><p>只需要一个操作数<br>var a&#x3D;1;<br>console.log(+a);1 没有影响</p>
<p>var a&#x3D;1;<br>console.log(-a);-1 有影响</p>
<p>都会将非number类型的值转换为Number类型，<br>var a&#x3D;false;<br>console.log(+a)；0；</p>
<p>可以用+a;来做隐式转换成number类型(原理和Number()函数一样)<br><br/></p>
<h4 id="自增与自减"><a href="#自增与自减" class="headerlink" title="自增与自减:"></a>自增与自减:</h4><p>var a&#x3D;1;<br>a++;此时 表达式 的值是1<br>console.log(a):这里变成2;<br>对于一个变量自增以后，原变量的值会立即增加1;<br>无论是a++,还是++a,都会立即让原来的变量值加1，区别是a++这个表达式的值是自增以前的值，<br>而++a这个表达式的值是自增以后的值。<br>var a&#x3D;20;<br>var a&#x3D;a++;<br>等价于 var e&#x3D;a++;<br>a&#x3D;e;<br>a的结果还是20;<br><br/></p>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符:"></a>逻辑运算符:</h4><p>! 非运算符:对一个布尔值进行取反操作，false变成true,true变成false,<br>不会改变原来变量的值，<br>var a&#x3D;true;<br>console.log(!a);false;<br>console.log(a);true;<br>对于非布尔值取反，会将其先转换为布尔值，然后取反。<br>可以取两次反，将一个非布尔类型的值转换为布尔类型的值，并且不改变原值<br>var a&#x3D;1;<br>a&#x3D;!!a;true;</p>
<p>&amp;&amp; 与运算符:<br>a&amp;&amp;b;<br>只有两个值都为true,结果才是true;<br>如果有一个值为false,结果就是false;<br>如果第一个值为false,则不会再看第二个值</p>
<p>|| 或运算符:<br>只有两个值都为false,才返回false<br>若需其中一个值为true,就会返回true<br>如果第一个值为true,则不会再去看第二值<br><br/></p>
<h4 id="非布尔值的与或运算"><a href="#非布尔值的与或运算" class="headerlink" title="非布尔值的与或运算:"></a>非布尔值的与或运算:</h4><p>会将其转换成布尔值，然后进行运算,并且返回原值。<br>2&amp;&amp;1  1<br>1&amp;&amp;2  2<br>如果两个值都为true,则返回后面的。<br>0&amp;&amp;2<br>flase&amp;&amp;true<br>返回 0<br>2&amp;&amp;0  0<br>NaN&amp;&amp;0  NaN<br>0&amp;&amp;NaN  0<br>如果两个值中有false,则返回靠前的false<br>如果第一个值为true,则必然返回第二个值<br>如果第一个值为false，则直接返回第一个值<br><br/><br>2||1 2 如果第一个值为true,则直接返回第一个值<br>NaN||1  1  如果第一个值为false,则直接返回第二个值<br><br/></p>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符:"></a>赋值运算符:</h4><p>&#x3D;:可以将符号右侧的值赋值给符号左侧的变量<br>a +&#x3D;5 等价于 a&#x3D;a+5<br>a -&#x3D;5 等价于 a&#x3D;a-5<br>a %&#x3D;5 等价于 a&#x3D;a%5<br><br/></p>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符:"></a>关系运算符:</h4><p>比较两个值的大小，如果成立返回true,不成立返回false<br>4&gt;5 false<br>5&gt;&#x3D;5(大于或者等于 满足其一就成立) true<br>1&gt;”0” true  对于非数字进行比较时，会将其转换为数字然后进行比较。<br>10&lt;&#x3D;”hello” 任何值和NaN做比较都是false<br>“11”&lt;”5” true 特殊情况:如果两边都是字符串，不会将其转成数字比较，而会分别比较字符串中的Unicode编码<br>“abc”&lt;”b” true 比较字符编码时是一位一位进行比较,第一位a比b小，后面就不看了<br>“bbc”&lt;”b” false  第一位两边一样，比较下一位，第二位 左边是b 右侧没有 左边大<br><br/></p>
<h4 id="Unicode编码表的使用"><a href="#Unicode编码表的使用" class="headerlink" title="Unicode编码表的使用:"></a>Unicode编码表的使用:</h4><p>在字符串中使用转义字符使用Unicode编码:console.log(“\u0054”);<br>在网页中使用Unicode编码:&amp;#编码 这里的编码需要的是10进制<br><br/></p>
<h4 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符:"></a>相等运算符:</h4><p>&#x3D;&#x3D;  比较两个值是否相等，相等则返回true,否则返回false<br>4&#x3D;&#x3D;5 false<br>“1”&#x3D;&#x3D;1 true  如果两边的类型不同，  大部分情况都会转换为数字<br>true&#x3D;&#x3D;”1”  true  左边布尔转数字 1  右侧字符串也转成数字1<br>null&#x3D;&#x3D;0 false  左边null没有转成数字<br>undefined&#x3D;&#x3D;null true undefined衍生于null<br>NaN&#x3D;&#x3D;NaN  false NaN不和任何值相等，包括它本身</p>
<p>检查一个值是否是NaN,如果是NaN返回true,否则返回false<br>isNaN(NaN) true<br>isNaN(1)   false<br>!&#x3D; 用来判断两个值是否不相等，不相等返回true 相等返回false</p>
<p>&#x3D;&#x3D;&#x3D; 全等 用来判断两个值是否全等 若两边值的类型不同，则直接返回false，不会自动做类型转换。<br>“123”&#x3D;&#x3D;123 false<br>“123”&#x3D;&#x3D;123 true<br>null&#x3D;&#x3D;&#x3D;undefined  false  null与undefined相等但不全等</p>
<p>！&#x3D;&#x3D; 不全等  如果两个值的类型不同，直接返回true<br>1!&#x3D;&#x3D;”1” true<br><br/></p>
<h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符:"></a>条件运算符:</h4><p>语法：<br>条件表达式？语句1:语句2;<br>首先对条件表达式进行求值,若为true，则执行语句1，并返回结果,否则执行语句2，并返回结果。<br>var a&#x3D;1,b&#x3D;2;<br>a&gt;b?alert(“a大”)：alert(“b大”);<br>获取 a和b中的最大值<br>var max&#x3D;a&gt;b?a:b;<br>获取abc中的最大值<br>max&#x3D;max&gt;c?max:c;<br>或者<br>max&#x3D;a&gt;b?(a&gt;max?a:c):(b&gt;c?b:c);<br>如果条件表达式的求值为一个非布尔值，则会将其转换为布尔值，<br>“”?alert(1):alert(2);2<br>“1”?alert(1):alert(2); 1</p>
<p>if(a&#x3D;10) 表示  if(10) 即 if(true)<br><br/></p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级:"></a>优先级:</h4><p>, 运算符  可用来同时声明多个变量<br>var a,b,c;<br>1+2*3  先乘除后加减<br>1||2&amp;&amp;3  1如果或的优先级高先算或，如果与的优先级高先算与，如果两个一样高，则按从左往右的顺序<br>这里  &amp;&amp;的优先级比||高<br>可以通过()改变优先级 (1||2)&amp;&amp;3  3<br><br/></p>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块:"></a>代码块:</h4><p>程序是一条一条语句构成的,<br>语句是按照自上向下的顺序一条一条执行的<br>同一个{}中的语句称为一组语句，他们要么都执行，要么都不执行<br>{<br>alert(0);<br>console.log(1);<br>}  这里与不加{}没有区别<br>一个{}中的语句也称为一个代码块<br>在代码块的后边就不用再编写;了<br>JS中的代码块{}只具有分组的作用，没有其他用途。<br>在代码块中的内容，在外部是完全可见的<br><br/></p>
<h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句:"></a>if语句:</h4><p>if(条件表达式)<br>语句<br>if语句在执行时 会先对条件表达式进行判断<br>如果为 true 则执行if后的语句，若为false 则不执行if后的语句。<br>var a&#x3D;10;<br>if(a&gt;10） if语句只能控制紧随其后的那个语句。<br>alert(1);<br>alert(2);这句还是会执行<br>如果希望if语句可以同时控制多条语句，可以将他们放在代码块{}中<br>if(a&gt;10){<br>alert(1);<br>alert(2);<br>}<br>if…else if…else  会从上到下依次对条件表达式进行求值判断,如果所有条件都不满足，则执行<br>最后一个else后的语句。<br>该语句中，只会有一个代码块被执行，一旦代码块执行了，则直接结束语句。<br>if(a&gt;10){<br>console.log（10）；<br>}else if(a&gt;5){<br>console.log(5);<br>}else if(a&gt;3){<br>console.log(3);<br>}else{<br>console.log(0);<br>}<br><br/></p>
<h4 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句:"></a>条件分支语句:</h4><p>switch(条件表达式){<br>case 表达式:<br>语句 …<br>break; 这三行可以有多个<br>default:<br>语句 …<br>break;<br>}</p>
<p>在执行时会依次将case后面的表达式的值和switch后面的表达式的值进行 全等 比较<br>如果比较的结果为true,则从当前case处开始执行代码，当前case后的代码都会执行<br>如果比较结果为false,则继续向下比较<br>使用break可以退出switch语句<br>如果所有的比较结果都为false,则只执行default后的语句</p>
<p>var a&#x3D;1;<br>switch(a){<br>case 1:<br>console.log(“1”);<br>break;<br>}<br><br/></p>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环:"></a>while循环:</h4><p>while(条件表达式){<br>}<br>先对条件表达式进行求值判断<br>如果值为true,则执行循环体<br>循环体执行完以后，继续对表达式进行判断<br>如果为true,则继续执行循环体，以此类推<br>如果值为false，则终止循环</p>
<p>while(true){  这个称为死循环<br>alert(n++)；<br>break;可以使用break终止循环<br>} </p>
<p>do…while循环<br>先执行循环体，判断，继续执行循环体，然后判断,以此类推。<br>如果结果为false,则终止循环。<br>do{<br>语句…<br>}while（条件表达式）</p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环:"></a>for循环:</h4><p>求水仙花数：<br>for(var i&#x3D;100;i&lt;1000;i++){<br>var bai&#x3D;parseInt(i&#x2F;100); &#x2F;&#x2F;获取百位上的数字<br>var shi&#x3D;parseInt((i-bi*100)&#x2F;10);&#x2F;&#x2F;获取十位上的数字<br>var ge&#x3D;i%10;<br>if(bai*bai*bai+shi*shi*shi+ge*ge*ge&#x3D;&#x3D;i){<br>console.log(i);<br>}<br>}<br><br/></p>
<p>嵌套联系:<br>for(var i&#x3D;0;i&lt;5;i++){&#x2F;&#x2F;控制行的个数<br>i值改变一次前，j值会该改变i次<br>for(var j&#x3D;0;j&lt;&#x3D;i;j++){&#x2F;&#x2F;控制每一行显示的个数<br>document.write(“*”);<br>}<br>document.write(“<br/>“);<br>}<br><br/></p>
<h4 id="break与continue"><a href="#break与continue" class="headerlink" title="break与continue:"></a>break与continue:</h4><p>break关键字只能又来退出switch或循环语句<br>不能在if语句中使用break和continue<br>break会终止离他最近的循环语句</p>
<p>可以在break后跟一个label（随便一个标签）,可以终止指定的循环<br>outer：<br>for(…){<br>for(…){<br>break outer;</p>
<p>continue可以用来跳过当次循环<br>continue默认只会对离他最近的循环起作用<br><br/></p>
<h4 id="测试程序执行的时间"><a href="#测试程序执行的时间" class="headerlink" title="测试程序执行的时间:"></a>测试程序执行的时间:</h4><p>程序执行前，开启计时器<br>console.time(“test”);text为计时器的名字<br>…<br>console.timeEnd(“test”);终止计时器</p>
<p>或者<br>var start&#x3D;Date.now();得到的是毫秒</p>
<p>然后再回调里面  用Date.now-start<br><br/></p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象:"></a>对象:</h4><p>对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性<br>分类:<br>1 内建对象:由ES标准标准中定义的对象，在任何的ES的实现中都可以使用<br>例如:Math,String,Number,Boolean,Function,Object,…<br>2 宿主对象:由JS的运行环境提供的对象，主要指浏览器提供的对象<br>  比如 BOM,DOM<br>  console.log()中console<br>  document.write()中的document<br>3 自建对象；由开发人员自己建立的对象<br>var obj&#x3D;new Object() 使用new关键字调用的函数，是构造函数constructor，构造函数是专门用来创建对象的函数<br>使用typeof 检查一个对象时,会返回一个object<br>对象中保存的指称为属性<br>向对象添加属性<br>语法:对象.属性名&#x3D;属性值<br>obj.name&#x3D;”孙猴子<br>读取对象中的属性:对象.属性名 obj.name<br>如果读取对象中没有的属性，不会报错，而是返回undefined<br>修改对象的属性值: obj.name&#x3D;”八戒<br>删除对象的属性 delete obj.name;<br>如果要存入特殊的属性名，不能采用 . 的方式来操作,而应该这样<br>obj[“123”]&#x3D;”monkey”<br>取的时候也必须是 obj[“123”]</p>
<p>还可以  var n&#x3D;”123”<br>obj[n]的值还是一样(读取时还是obj[“123”])</p>
<p>in 运算符<br>通过该运算符可以检查一个对象中是否含有指定的属性<br>如果由返回true,没有则返回false<br>语法:”属性名” in 对象<br>“name” in obj   true<br>“test” in obj   false</p>
<p>对象的属性值也可以是个函数,这是函数可以认为是这个对象的方法<br>obj.sayName&#x3D;function(){}<br>obj.sayName()；调方法</p>
<p>function fun(){}<br>fun();调函数</p>
<p>var obj&#x3D;{<br>sayName:function（）{}<br>}</p>
<p>枚举对象中的属性:<br>for（var 变量 in 对象）{}<br>有多少属性，循环体就执行多少次</p>
<p>变量为每次执行的属性名字<br>对象[变量] 来取每次的属性值,而对象.变量的方式不能采取<br><br/></p>
<h4 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型:"></a>基本数据类型和引用数据类型:</h4><p>JS中的变量都是保存在栈内存中<br>基本数据类型的值直接在栈内存中存储<br>值与值之间是独立存在的，修改一个变量不会影响其他的变量<br>var a&#x3D;123;<br>var b&#x3D;a;<br>过程如下<br>在栈内存中<br>变量  值<br>a     123<br>b     123 （这里的123是直接复制上面的123）<br>然后a++<br>a 124<br>b  123 不会对a有任何影响</p>
<p>对象是保存在堆内存中的<br>var obj&#x3D; new Object()  出现new 意味着在堆中开辟了一个空间，用来存储对象<br>栈内存中<br>变量 值<br>obj  0x123 这里变量保存的是一个内存地址(对象引用) 这里相当于一个指针，执行了堆内存中指定的空间</p>
<p>堆内存中<br>一部分空间  地址为0x123..<br>obj.name&#x3D;”孙猴子” 此时在堆内存指定的空间里存入数据</p>
<p>var obj2&#x3D;obj;<br>栈内存中<br>obj  0x123…<br>obj2 ox123…(此时变量值 为 从上面复制过来的地址) 此时指向的是同一个对象</p>
<p>若 obj2&#x3D;null<br>此时obj2和堆中的对象链接断开了，但不会影响obj<br><br/></p>
<h4 id="对象字面量："><a href="#对象字面量：" class="headerlink" title="对象字面量："></a>对象字面量：</h4><p>使用对象字面量创建对象，可以直接指定对象中的属性<br>var obj&#x3D;{}<br>语法:{属性名:属性值,…}<br>对象字面量的属性名可以加引号，也可以不加，建议不加<br>但如果使用特殊的属性名，需要加上引号，如 {“!#$@#”：”00”}<br>如果一个属性之后没有其他的属性了，就不要加逗号了<br><br/></p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数:"></a>函数:</h4><p>函数也是一个对象<br>函数中可以封装一些功能代码,在需要时可以执行这些功能(代码)<br>创建一个函数对象<br>var fun&#x3D;new Function()<br>console.log(typeof fun)  “function”<br>可以将要封装的代码以字符串的形式传递给构造函数<br>var fun&#x3D;new Function(“console.log(‘你是八戒吗’)”)<br>封装到函数中的代码不会立即执行<br>调用函数的语法:<br>函数对象+()</p>
<p>也可以 使用函数声明来创建一个函数<br>语法:<br>function 函数名(形参1,形参2,…,形参N,){<br>语句…<br>}</p>
<p>还可以  使用函数表达式（匿名函数）来创建一个函数<br>var 函数名&#x3D;function(形参1,形参2,…形参N){};</p>
<p>var fun3&#x3D;function(){console.log(“你是一个函数”);};<br>使用return可以结束整个函数<br>返回值可以是任意的数据类型，可以是一个对象，也可以是一个函数<br><br/></p>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数:"></a>函数参数:</h4><p>可以在函数的()指定一个或多个形参(形式参数)<br>多个形参之间使用,隔开<br>声明形参就相当于在函数内部声明了对应的变量<br>function sum(a,b){}<br>相当于 function sum(a,b){var a;var b;}<br>在调用函数时,可以在()中指定实参(实际参数)<br>实参将会赋值给函数中对应的形参<br>sum(1,2）<br>相当于<br>function sum(a,b){var a&#x3D;1;var b&#x3D;2;}</p>
<p>调用函数时，解析器不会检查实参的类型，<br>所以要注意，是否有可能接收到非法的参数，如果有可能，需要对参数进行一个类型的检查<br>调用函数时，解析器也不会检查是实参的数量</p>
<p>多余实参不会被赋值<br>如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined<br>函数的实参可以是任何的数据类型</p>
<p>return 后的值将作为函数的执行结果返回<br>在函数中 return 语句之后的语句都不会执行<br>如果return 后面不跟任何值，就相当于返回了undefined<br>如果函数中不写return,也相当于返回了undefined</p>
<p>当参数过多时，可以将他们封装到一个对象中进行传递<br>实参可以是一个对象，也可以是一个函数<br>sum() 调用函数 相当于使用函数的返回值<br>sum 函数对象<br><br/></p>
<h4 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数:"></a>立即执行函数:</h4><p>也称为 匿名函数自调用，IIEF<br>函数定义完，立即被调用<br>立即执行函数往往只会执行一次<br>(function(a,b){<br>var a&#x3D;10;<br>}<br>)(1,2)<br>好处：<br>不会影响全局命名空间<br>隐藏内部实现<br><br/></p>
<h4 id="作用域："><a href="#作用域：" class="headerlink" title="作用域："></a>作用域：</h4><p>一个变量的作用范围<br>全局作用域:<br>直接编写在script标签里面的JS代码，都在全局作用域里面<br>全局作用域在页面打开时创建，在页面关闭时销毁<br>在全局作用域中有一个全局对象window,代表的是浏览器的窗口，由浏览器创建，是可以直接使用的<br>在全局作用域中，创建的变量都会作为window对象的属性保存<br>创建的函数都会作为window对象的方法保存<br>在全局作用域下,var a&#x3D;10相当于window.a&#x3D;10;<br>function fun(){}  相当于 window.fun&#x3D;function(){}<br>在全局作用域下的变量都称为全局变量，在页面的任意位置都可以访问的到</p>
<p>函数作用域:<br>调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁<br>每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的<br>在函数作用域中可以访问到全局作用域下的变量，但是在全局作用域中无法访问到函数作用域下的变量<br>当在函数作用域操作一个变量时，它会先在自身作用域查找，如果有就直接使用，如果没有，就向上一级作用域中查找，知道找到全局作用域<br>如果全局作用域中依然没有找到，则会报错<br>在函数中要访问全局变量可以使用window对象<br>函数作用域中也有声明提前的特性，使用var 关键字声明的变量，会在函数中所有代码执行之前被声明<br>函数声明也会在函数中所有代码执行之前执行<br>在函数中，不使用var声明的变量都都成为全局变量 相当于window.变量&#x3D;…<br>定义形参就相当于在函数作用域中声明了变量</p>
<p>内部可以看到外部(通过作用域链)，但外部看不到内部<br><br/></p>
<h4 id="声明提前"><a href="#声明提前" class="headerlink" title="声明提前:"></a>声明提前:</h4><p>使用var关键字声明的变量，会在所有的代码执行之前被声明<br>console.log(a);<br>var a&#x3D;10；undefined<br>上面2行等价于<br>var a;<br>console.log(a);<br>a&#x3D;10;<br>如果声明变量时不使用var关键字，则变量不会被声明提前。<br>console.log(a);<br>a&#x3D;10;报错</p>
<p>函数声明:<br>fun();<br>fun2();报错<br>function fun(){alert(1);} 函数声明会被提前创建<br>var fun2&#x3D;function(){}函数表达式不会被提前创建(这里只是把变量提前了，赋值操作没有提前)<br>上面4行相当于<br>function fun(){alert(1);}<br>var fun2;<br>fun();<br>fun2();<br>fun2&#x3D;function(）{};<br><br/></p>
<h4 id="关于this"><a href="#关于this" class="headerlink" title="关于this:"></a>关于this:</h4><p>解析器在调用函数时，每次都会向函数内部传递一个隐含的参数，这个隐含的参数就是this,this指向的是一个对象，这个对象被称为 函数执行的上下文对象，根据函数的调用方式不同，this会指向不同的对象<br>以函数的形式调用,this永远都是window<br>以方法的形式调用，this就是调用方法的那个对象<br>以构造函数的形式调用，this就指向被创建出来的那个对象<br>使用call与apply方法调用时.this是指定的那个对象<br><br/></p>
<h4 id="使用工厂模式创建对象"><a href="#使用工厂模式创建对象" class="headerlink" title="使用工厂模式创建对象:"></a>使用工厂模式创建对象:</h4><p>返回一个对象的函数<br>通过该方法可以大批量的创建对象，节省代码<br>使用工厂模式创建的对象，使用的构造函数都是Object<br>所以创建的对象都是Object这个类型，就导致无法区分多种不同类型的对象<br>function createPerson(name,age){<br>var obj&#x3D;new Object();<br>obj.name&#x3D;name;<br>obj.age&#x3D;age;<br>return obj;<br>}</p>
<p>var obj1&#x3D;createPerson(…);<br>var obj2&#x3D;createPerson(…);</p>
<p>obj1 instanceof Object：true<br>obj1 instanceof Object： true<br><br/></p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数:"></a>构造函数:</h4><p>构造函数就是一个普通的函数，创建方式与普通函数没有区别<br>不同的是构造函数首字母大写</p>
<p>构造函数与普通函数的区别就是调用方式的不同<br>普通函数是直接调用，构造函数需要使用new关键字调用</p>
<p>构造函数的执行流程(即 new …()期间发生的事情)<br>1 立刻创建一个新的对象<br>2 将新建的对象作为函数中的this<br>3 逐行执行函数中的代码<br>4 将新建立的对象作为返回值返回</p>
<p>使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类<br>通常将通过一个构造函数创建的对象，称为是该类的实例</p>
<p>可以使用instanceof检查一个对象是否是一个类的实例,如果是，返回true,否则返回false<br>var per&#x3D;new Person();<br>per instanceof Person<br>所有的对象都是Object的后代，所以任何对象和instanceof做检查都会返回true</p>
<p>构造函数每执行一次就会创建一个新的对象，但是方法都是一样的，浪费资源，应该让所有对象共享一个方法<br>function Person(){<br>this.sayName&#x3D;function（）{}<br>}<br>var per1&#x3D;new Person();<br>var per2&#x3D;new Person();<br>per1.sayName&#x3D;&#x3D;per2.sayName;false</p>
<p>将上面改成<br>function Person(){<br>this.sayName&#x3D;fun;<br>}<br>function fun(){<br>alert(1);<br>}<br>将函数定义在全局作用域里面，污染了全局作用域的命名空间(可能其他人也不知道，起了相同的名字，于是这个就被覆盖掉了)<br><br/></p>
<h4 id="自定义构造函数-原型的组合模式："><a href="#自定义构造函数-原型的组合模式：" class="headerlink" title="自定义构造函数+原型的组合模式："></a>自定义构造函数+原型的组合模式：</h4><p>套路:自定义构造函数，属性在函数中初始化,方法添加到原型链上<br>使用场景:需要创建多个类型确定的对象<br>如： function Person(name,age){<br>this.name&#x3D;name;<br>this.age&#x3D;age;<br>}<br>Person.prototype.setName&#x3D;function(name){<br>this.name&#x3D;name;这里的this是指向实例对象<br>}</p>
<p>var person1&#x3D;new Person（）;<br>person1 instanceof Person :true<br>var person2&#x3D;new Person(); </p>
<p>如果把方法写在构造函数里面，那么person1,person2的方法是不同的，会造成浪费内存，而放在原型链上，则2个对象的方法是同一个</p>
<p>function  Animal(){…}<br>var animal1&#x3D;new animal();<br>animal1 instanceof animal:true</p>
<h4 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象:"></a>原型对象:</h4><p>构造函数名.prototype  为显示原型属性<br>实例对象.<strong>proto</strong>    为隐式原型属性<br>这两个都是指向同一个原型对象 </p>
<p>原型prototype：<br>我们所创建的每一个属性，解析器都会向函数中添加一个属性prototype,这个属性(保存了一个地址)对应着一个对象，这个对象就是所谓的原型对象（默认是一个object的空对象）(如：空间地址为0x123)。<br>原型对象有一个属性constructor，它指向函数对象<br>如果函数作为作为普通函数调用,那么prototype没有任何作用。<br>当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，即 创建出来的那个对象的__proto__属性也是保存了一个地址，指向了同一个空间。<br>也就是 对象.<strong>proto</strong>&#x3D;&#x3D;函数.prototype<br>原型对象就像一个公共区域，所有同一个类的实例都可以访问到这个原型对象<br>可以将对象中公有的内容都设置在原型对象中<br>向MyClass构造函数中添加属性a（这个是在公共区间中存入a,并不是单个的实例中存入）<br>MyClass.a&#x3D;….</p>
<p>当我们访问对象的一个属性或者方法时，它会现在对象自身中查找，如果有则直接使用，如果没有，则会去原型对象中寻找,如果找到则直接使用。</p>
<p>向原型中添加方法<br>MyClass.prototype.sayName&#x3D;function(){} 这样既是公共的方法，也不会污染全局作用域的命名空间<br>使用 in 检查对象中有没有某个属性时，如果对象中没有，但原型中有，也会返回true<br>可以使用对象中的hasOwnProperty来检查 对象自身 有没有该属性<br>像  实例.<strong>proto</strong>.hasOwnProperty(“hasOwnProerty”):false</p>
<p>原型对象也是对象，它也有原型，如果原型中没有，则去原型对象的原型中寻找，也就是<br>函数名.prototype.__proto__或者是实例.<strong>proto</strong>.<strong>proto</strong></p>
<p>上面这个属性是在原型的原型中<br>而原型的原型的原型(3个)是指向空,即<br>函数名.prototype.<strong>proto</strong>.<strong>proto</strong>&#x3D;null<br>实例.<strong>proto</strong>.<strong>proto</strong>.<strong>proto</strong>&#x3D;null</p>
<p>原型对象也是对象，它也有原型，如果原型中没有，则去原型对象的原型中寻找，也就是<br>函数名.prototype.__proto__或者是实例.<strong>proto</strong>.<strong>proto</strong>,<br>如果原型的原型中也没有，则知道找到Object对象（所有对象的祖先,也就是原型的原型）的原型<br>Object对象的原型(即原型的原型 的原型)没有原型，如果在Object中依然没有找到，则返回undefined</p>
<p>原型对象(0x123)<br>a           100<br><strong>proto</strong>   0x124(这个指向下面,如果上面没有找到对象的属性，就去这个指向空间里找)</p>
<p>原型对象的原型对象<br><strong>proto</strong><br>object的原型对象的隐式原型为null,所以object的原型对象是原型链的尽头<br>实例才有隐式原型 <strong>proto</strong><br>函数只有显示原型  prototype<br>Function.prototype是一个实例<br><br/></p>
<h4 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法:"></a>toString方法:</h4><p>当我们直接在页面中打印出一个对象时，实际上是输出对象的toString()方法的返回值<br>如果希望在输出对象时不输出[object Object],可以为对象添加一个toString方法<br>对象.toString&#x3D;function(){}<br>但这样只能改变一个实例<br>应该  构造函数名.prototype.toString&#x3D;function（）{} 添加一个方法<br><br/></p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收:"></a>垃圾回收:</h4><p>var obj&#x3D;new Object();<br>这里开辟了一个内存空间<br>obj这个变量保存了这个空间的引用地址<br>但当执行  obj&#x3D;null时<br>这个变量和这个空间的链接就断开了<br>那么这个空间不被任何变量所指向，也就成垃圾了<br>这种对象过多会占用大量的内存空间，导致程序运行变慢<br>在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁<br>我们不需要也不能进行垃圾回收的操作</p>
<p>如果需要回收 就执行null操作，让浏览器自动将这些垃圾对象销毁<br><br/></p>
<h4 id="数组简介"><a href="#数组简介" class="headerlink" title="数组简介:"></a>数组简介:</h4><p>数组也是对象<br>和普通对象功能类似，也是用来存储一些值的<br>不同的是，普通对象是使用字符串作为属性值，而数组是使用数字作为索引来操作元素<br>索引:从0开始的整数<br>创建数组对象: var obj&#x3D;new Array();<br>使用typeof检查一个数组时，会返回object<br>向数组中添加元素:数组[索引]&#x3D;值<br>如果读取不存在的值，不会报错，而是返回undefined</p>
<p>获取数组的长度 数组.length<br>对于非连续的数组,使用length会获取到数组的最大索引+1<br>尽量不要创建非连续的数组<br>如果修改的lenth大于原长度，则多出部分会空出来<br>如果修改的length小于原长度，则多出的元素会被删除<br>向数组的最后一个位置添加元素 arr[arr.length]&#x3D;…</p>
<p>存值还可以 arr.hello&#x3D;”hello” 但没有意义<br>还可以使用字面量创建数组<br>var arr&#x3D;[];<br>使用构造函数创建数组时，也可以同时添加元素，元素之间用,隔开<br>new Array(10,20,30);</p>
<p>arr&#x3D;[10];表示只用一个元素，这个元素内容为10<br>new Array(10) 表示数组的长度为10,10个元素的内容暂时为空</p>
<p>arr.push(1,2,3)向数组中添加新的元素，这些元素将自动添加到数组的末尾，并返回新的长度<br>arr.pop()删除数组的最后一个元素，并将删除的值作为返回值<br>arr.unshift() 向数组的开头添加一个或者多个元素，并且返回新的数组长度，向前面插入元素以后，后面的元素的索引会依次改变<br>arr.shift() 删除数组的第一个元素，并将删除掉的元素作为返回值</p>
<p>forEach方法需要一个函数作为参数,像这种函数，由我们创建但不由我们调用的（由浏览器自己调用的），称为回调函数。<br>数组中有几个元素，这个函数就会执行几次<br>浏览器会在回调函数中传递三个参数，a为正在遍历的元素，b为正在遍历的元素的索引，第三个参数就是正在遍历的数组<br>arr.forEach(function(a,b,c){<br>})</p>
<p>arr.slice(a,b)可以用来从数组中提取指定元素,a为起始位置 b为末端位置，但截取的内容不包括末端的那个元素<br>该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回</p>
<p>arr.slice(a) 截取从索引a开始以后的所有元素，索引可以传递一个负值,如-1就是倒数第一个</p>
<p>arr.splice(m,n)可以用来删除数组中的指定元素 m起始，n表示删除的数量，并将被删除的元素作为返回值返回 会改变原数组<br>arr.splice(m,n,k)第三个元素及以后，这些元素将替换掉之前被删掉的元素<br>如果n为0，则表示不删，那么k代表的元素还是将插入到开始的位置(索引m的前面)的前面</p>
<p>arr.concat(arr2) 连接两个或者多个数组(也可以是元素)，并将新数组返回，该方法不会对原数组产生影响</p>
<p>arr.filter(（num）&#x3D;&gt;{return true&#x2F;false})<br>函数 function 为必须，数组中的每个元素都会执行这个函数。且如果返回值为 true，则该元素被保留；<br>函数的第一个参数 currentValue 也为必须，代表当前元素的值。filter会返回一个新的数组，不会改变原数组</p>
<p>arr.join()该方法可以将一个数组转换为字符串，<br>该方法不会改变原数组，而是将转换后得到的字符串作为结果返回<br>还可以指定一个字符串作为参数，该字符串会作为元素之间的连接符<br>如果不适用连接符，默认会使用,作为连接符<br>如果连，也不想要，可以指定空字符串 “”</p>
<p>arr.reverse() 会翻转数组 前后颠倒过来<br>会改变原数组</p>
<p>arr.sort()  对数组进行排序<br>会改变原数组 默认会按照unicode编码来进行排序<br>即使对于纯数字的数组，也会按照unicode编码来进行排序，所以对数字进行排序时，可能会得到错误的结果<br>也可以自己来指定排序的规则<br>可以在sort()中放一个回调函数来指定排序规则<br>a，b代表数组中的连续的某两个元素<br>并且a代表的元素的位置一定在b代表的元素的前面<br>浏览器会根据元素的返回值来决定元素是否会交换位置<br>如果大于0 元素会交换位置<br>如果小于0 元素不变<br>如果等于0 则认为两个元素相等，也不交换位置<br>arr.sort(function(a,b){<br>如果升序<br>if(a&gt;b){<br>return 1;<br>}else if(a&lt;b){<br>return -1;<br>}else{<br>return 0<br>}<br>如果降序:<br>if(a&gt;b){<br>return -1;<br>}else if(a&lt;b){<br>return 1;<br>}else {<br>return 0;<br>}</p>
<p>})</p>
<p>当遇到数组对象时<br>arr.sort((p1,p2)&#x3D;&gt;{ 降序:后 减 前      升序:前 减 后<br>return sortType&#x3D;&#x3D;1?p2.age-p1.age(根据年龄降序):p1.age-p2.age(根据年龄升序)</p>
<p>})<br><br/></p>
<h4 id="call与apply"><a href="#call与apply" class="headerlink" title="call与apply:"></a>call与apply:</h4><p>这两个方法都是函数对象的方法，需要通过函数对象来调用<br>当函数调用call()和apply()都会让函数执行<br>可以将一个对象指定为第一个参数，这个对象将成为函数执行时的this<br>call方法中实参是在对象之后(第一个参数以后)依次传递<br>fun.call(obj,1,2)<br>apply方法中实参在对象之后需要以数组的形式传递<br>apply(obj,[1,2])<br><br/></p>
<h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments:"></a>arguments:</h4><p>当调用函数时，浏览器每次都会传递进两个隐含的参数:<br>1 函数的上下文对象this<br>2 封装实参的对象arguments<br>arguments是一个类数组对象，可以通过索引来操作数据<br>当调用函数时，所用的实参都会在arguments中保存<br>arguments.length可以获取实参的长度<br>arguments.callee这个属性对应一个函数对象，就是当前正在执行的函数的对象<br><br/></p>
<h4 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象:"></a>Date对象:</h4><p>在JS中使用Date对象来表示一个时间<br>如果直接使用构造函数创建一个Date对象，则会封装成当前代码执行的时间<br>var d&#x3D;new Date()<br>创建一个指定的时间对象:需要在构造函数中传递一个表示时间的字符串作为参数<br>日期的格式:月&#x2F;日&#x2F;年 时:分:秒<br>new Date(“12&#x2F;03&#x2F;2016 11:10:13”);<br>d.getDate() 获取当前日期是几号<br>d.getDay()  获取当前日期是星期几 会返回一个0-6的值，0表示周日，1表示周一<br>d.getMonth() 获取当前时间的月份 0-11的值 0表示1月 1表示2月  11表示12月<br>d.getFullYear() 获取当前日期对象的年份<br>d.getTime() 获取当前日期对象的时间戳<br>时间戳：从格林威治标准时间的1970年1月1日 0时0分0秒到当前日期所花费的毫秒数(1s&#x3D;1000ms<br>)<br>计算机底层在保存时间时使用的都是时间戳<br>Date.now() 获取当前代码执行时的时间戳<br>可以利用时间戳来测试代码执行的性能<br><br/></p>
<h4 id="Math"><a href="#Math" class="headerlink" title="Math:"></a>Math:</h4><p>不是构造函数<br>里面封装了数学相关计算的一些属性和方法<br>Math.PI 圆周率 常量<br>Math.abs() 计算一个数的绝对值<br>Math.ceil() 可以对一个数进行向上取整，小数位只要有值就会向上进1<br>Math.floor() 可以对一个数进行向下取整，小数部分会被省掉<br>Math.round() 四舍五入取整<br>Math.random() 可以生成一个0到1之间的随机数 包括0  但不包含1<br>若要随机出现0到10(包括0和10)的数<br>Math.round(Math.random()*10)<br>若要生成0到x之间的随机数<br>Math.round(Math.random()*x)<br>若要生成1到10的数<br>Math.round(Math.random()*9+1)</p>
<p>生成一个x到y之间的随机数:<br>Math.round(Math.random()*(y-x)+x)</p>
<p>Math.max(1,10,5) 可以获取多个数中的最大值<br>Math.min()  可以获取多个数中的最小值</p>
<p>Math.pow(2,2) 4 可以获取一个数的几次方<br>Math.sqrt(4) 2 可以对一个数进行开方<br><br/></p>
<h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类:"></a>包装类:</h4><p>主要是给浏览器自己用的<br>String() Number() Boolean()<br>通过包装类可以将基本数据类型转化为对象<br>var a&#x3D;new Number(1)<br>new String(“123”)<br>new Boolean(true)<br>用typeof 检测后都是object</p>
<p>转换为对象后有一个好处，可以添加属性<br>a.hello&#x3D;”123”;</p>
<p>当我们对一些基本数据类型调用一些属性和方法时,浏览器会临时使用一些包装类将其转换为对象，然后再调用对象的属性和方法，调用完以后，再将其转换为基本数据类型<br>所以<br>var s&#x3D;123;<br>s&#x3D;s.toString();<br>s.hello&#x3D;”你好”; 这里是添加到临时的对象里了，添加完后，这个对象就销毁了<br>console.log(s.hello) undefined  </p>
<p>上面一共转换了两次对象<br>s.toString()1次<br>s.hello 1次  但这两个不是同一个<br>这上面两个都是临时转换为对象，然后被销毁<br><br/></p>
<h4 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法:"></a>字符串的方法:</h4><p>var str&#x3D;”hello”<br>在底层 字符是以字符数组的形式保存的<br>[‘h’,’e’,’l’]<br>str.charAt(0) h 可以返回字符串中指定位置的字符<br>str.charCodeAt(1) 获取指定位置的字符的字符编码（uniCode编码）</p>
<p>String.fromCharCode(72)  可以根据字符编码去获取字符 ‘H’<br>str.concat(“你好”,”再见”) 可以用来链接两个或多个字符串<br>str.indexOf(“h”) 可以用来检查一个字符串中含有指定内容，如果有，则返回其出现的第一次的索引，如果没有找到指定的内容，则返回-1 (特殊情况:’abc’.indexOf(“”): 0 ,当input框中值全删完，默认为空字符串)<br>str.indexOf(“h”,1) 可以指定第二个参数，指定开始查找的位置，返回的还是索引<br>str.lastIndexOf(“h”) 从后往前面找<br>str.lastIndexOf(“h”，5) 也可以指定位置</p>
<p>str.slice(1,2)  可以从字符串中截取指定的内容，不会影响原字符串，而是将截取到的内容返回<br>参1: 开始位置的索引，包括开始的位置<br>参2:结束位置的索引，不包括结束位置</p>
<p>如果省略第二个，则会截取到开始位置以后所有的<br>str.slice(1,-1) -1表示倒数第一个，截取原则还是不变</p>
<p>str.substring()  可以用来截取一个字符串，和slice类似<br>参1 :开始截取位置的索引，包括开始位置<br>参2:结束位置的索引，不包括结束位置<br>不同的是 这个不能接收负值作为参数<br>如果是负值，则默认使用0，并且如果第二个参数小于第一个，还会互换位置</p>
<p>str.substr() 截取指定位置的内容<br>参1:开始位置的索引<br>参2:截取的数量</p>
<p>str.split()<br>可以将一个字符串拆分成一个数组<br>参数:需要一个字符串作为参数，将会根据这个字符串去拆分成数组<br>如果传递一个空串作为参数表，则会将每个字符拆分成数组中的一个元素<br>var str&#x3D;”abc,def,g”<br>str.split(“,”);[“abc”,”def”,”g”]<br>str.split(“d”) [“abc,”,”ef,g”] 两个元素</p>
<p>str.toUpperCase() 将一个字符串转换为大写并返回<br>str.toLowerCase() 将一个字符串转换为小写并返回<br><br/></p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式:"></a>正则表达式:</h4><p>用来定义一些字符串的规则<br>创建正则表达式的对象<br>var reg&#x3D;new RegExp(“正则表达式”,”匹配模式”);</p>
<p>只要字符串中有a,严格区分大小写,就返回true<br>var reg&#x3D;new RegExp(“a”); reg： &#x2F;a&#x2F;</p>
<p>在构造函数中可以传递一个匹配模式作为第二个参数<br>可以是:<br>i 忽略大小写<br>g 全局匹配模式</p>
<p>var reg&#x3D;new RegExp(“a”,”i”)</p>
<p>var str&#x3D;”a”;<br>test（）  用来检测一个字符串是否符合正则表达式的规则，符合就返回true,反之则返回false<br>reg.test(str); 使用reg这个规则去测试str这个字符串</p>
<p>使用字面量来创建正则表达式<br>var 变量&#x3D;&#x2F;正则表达式&#x2F;匹配模式<br>var reg&#x3D;&#x2F;a&#x2F;i  和上面是一样的</p>
<p>使用|表示或者的意思<br>reg&#x3D;&#x2F;a|b&#x2F; 有其中一个就会返回true</p>
<p>[]也是或的关系<br>reg&#x3D;&#x2F;[ab]&#x2F;<br>优势 &#x2F;[a-b]&#x2F; 表示任意小写字母 [A-B] 任意大写字母 [A-z] 任意字母</p>
<p>reg&#x3D;&#x2F;a[bde]c&#x2F; 表示是否含有 abc或者adc或者aec</p>
<p>[^] 除了<br>reg&#x3D;&#x2F;[^ab]&#x2F; 字符串中如果有ab之外的字符就返回true,如果没有则返回false</p>
<p>[0-9] 任意的数字</p>
<p>split() 可以传递一个正则表达式作为参数，默认是全局匹配<br>var str&#x3D;”1a2b3c4D5”<br>var reg&#x3D;&#x2F;A-z&#x2F;<br>str&#x3D;str.split(reg) [“1”,”2”,”3”,”4”,”5”]</p>
<p>search()可以指定字符串中是否含有指定内容,如果搜索到指定内容，会返回第一个字母的索引，如果没有则返回-1,还可以接收一个正则表达式作为参数，根据这个来检索字符串<br>默认只会查找第一个<br>str.search(“abc”)<br>str.search(&#x2F;a[bef]c&#x2F;)</p>
<p>match()  可以根据正则表达式，将符合条件的内容找出来，默认情况下，只会找到第一个符合条件的内容，找到以后就停止检索，match还会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果<br>需要设置匹配模式为全局，才会将所有内容取出来<br>str.match(&#x2F;[A-z]&#x2F;);<br>str.match(&#x2F;a-z&#x2F;gi)</p>
<p>replace()  可以将字符串中指定的内容替换为新的内容,默认只会替换第一个<br>参数1 ：被替换的内容 可以接收一个正则表达式作为参数<br>参数2：  新的内容<br>str.replace(“a”,”@<em>@”)<br>str.replace(&#x2F;a&#x2F;g,”@</em>@”)<br>str.replace(&#x2F;[A-z]&#x2F;g,””) 直接删除字母</p>
<p>量词:可以设置一个内容出现的次数<br>{n}：正好出现n次<br>var str&#x3D;&#x2F;a{3}&#x2F;<br>量词只对前面的一个内容其作用<br>&#x2F;ab{3}&#x2F;  指的是  abbb<br>但可以这样 &#x2F;(ab){3}&#x2F;  这就表示 ababab<br>{m,n} 可以出现m到n次<br>{m,}  出现m次及以上<br>&#x2F;ab{1,3}c&#x2F; b可以出现1到3次</p>
<p>加号代表 至少一个  &gt;&#x3D;1<br>&#x2F;ab+c&#x2F;<br>星号代表0个或多个<br>&#x2F;ab*c&#x2F;<br>问号代表0个或1个<br>&#x2F;ab?c&#x2F;</p>
<p>^ 以什么开头<br>&#x2F;^a&#x2F;<br>$ 以什么结尾<br>&#x2F;a$&#x2F;</p>
<p>&#x2F;^a$&#x2F;  开头又结束代表只能有一个a</p>
<p>&#x2F;.&#x2F; 表示任意字符，除了换行和结束符</p>
<p>在正则表达式中可以使用\表示转义字符<br>&#x2F;.&#x2F;  表示.</p>
<p>reg&#x3D;/&#x2F;\ 表示一个\</p>
<p>reg.test(“b.\“)  true  这里字符串中的\也转义了，实际上是一个\ （\在字符串中也是一个转义字符）</p>
<p>\w：任意字母,数字,_ [A-z0-9_]<br>\W：除了 字母，数字,_ [^A-z0-9_]<br>\d：任意的数字 [0-9]<br>\D：除了数字<br>\s：空格<br>\S:除了空格<br>（） 是为了提取匹配字符串的，表达式中有几个()就有几个相应的匹配字符串</p>
<p>\b：单词边界<br>&#x2F;\bchild\b&#x2F;  表示child为一个独立的单词 前面和后面一个位置都有空格 或后面什么都没有<br>\B：除了单词边界</p>
<p>去除字符串中的空格<br>str&#x3D;str.replace(&#x2F;\s&#x2F;g,”_”)</p>
<p>去除开头的空格<br>str&#x3D;str.replace（&#x2F;^\s*&#x2F;，” “）<br>去除结尾的空格<br>str&#x3D;str.replace(&#x2F;\s*$&#x2F;,” “)<br>去除开头和结束的空格<br>str&#x3D;str.replace(&#x2F;^\s*|\s*$&#x2F;g,” “)</p>
<br/>

<h4 id="文档的加载"><a href="#文档的加载" class="headerlink" title="文档的加载:"></a>文档的加载:</h4><p>浏览器在加载一个页面时，是按照自上向下的顺序加载的，读取到一行就运行一行<br>如果将script标签写在页面的上面,代码执行时，页面还没有加载<br>onload事件会在整个页面加载完成之后触发<br>window.onload&#x3D;function(){} 这个可以确保当代码执行时所有dom对象已经加载完毕<br><br/></p>
<h4 id="dom查询"><a href="#dom查询" class="headerlink" title="dom查询:"></a>dom查询:</h4><p>下面五个通过 document对象(在整个页面查询)调用<br>getElementById() 通过id获取一个元素节点对象</p>
<p>getElementsByTagName() 通过标签名获取一组元素节点对象</p>
<p>getElementsByName() 通过name属性获取一组元素节点对象</p>
<p>getElementsByClassName()  通过class属性获取一组元素节点对象</p>
<p>querySelector(“.box1&gt;div1”) 里面放css选择器</p>
<p>querySelectorAll(“”)</p>
<p>元素.id 元素.name 元素.value<br>读取class时:元素.className<br>s<br>下面四个通过具体的元素（在指定的元素中查询）节点调用</p>
<p>方法:getElementsByTagName() </p>
<p>属性:childNodes  当前节点的所有子节点(包含文本节点（空格）， 元素节点)</p>
<p>属性:firstNode  当前节点的第一个子节点</p>
<p>属性:lastChild  当前节点的最后一个子节点</p>
<p>属性:children  获取当前元素的所有子元素</p>
<p>属性:firstElementChild 获取当前元素的第一个子元素</p>
<p>属性:parentNode 获取当前节点的父节点</p>
<p>属性:previosSibling 表示当前节点的前一个兄弟节点</p>
<p>属性:previosElementSibling 表示当前节点的前一个兄弟元素节点</p>
<p>属性:nextSibling  表示当前节点的后一个兄弟节点</p>
<p>属性:innerHTML  可以获取到元素内部的文本内容</p>
<p>属性:innerText  同上,但获取不到标签元素</p>
<p>属性：nodeValue 获取节点内容</p>
<p>获取body：document.body<br>或者  document.getElementsByTagName(“body”)[0]</p>
<p>获取html根标签:document.documentElement</p>
<p>获取页面中所有的元素: document.all<br>或者  document.getElementsByTagName(“*”）<br><br/><br>dom的增删改<br> document.createElement(“li”)  创建一个元素节点对象，需要一个标签名作为参数，并根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回<br> document.createTextNode(“你是啥子”) 创建文本节点对象</p>
<p>父元素.appendChild(“”)  向一个父节点中添加一个子节点<br>（父节点.innerHtml+&#x3D;”<li>cat</li>“一样的效果）（有时会有隐患）<br>父元素.insertBefore(a1,a2)  a1为新节点，a2为指定节点 可以在指定的子节点前插入新的子节点<br>父元素.replaceChild(新节点，旧节点)  可以使用新节点替换已有的子节点<br>父元素.removeChild(子节点) 可以删除一个子节点<br><br/></p>
<h4 id="操作内联样式"><a href="#操作内联样式" class="headerlink" title="操作内联样式:"></a>操作内联样式:</h4><p>通过style属性设置和读取的样式都是内联样式<br>元素.style.width&#x3D;”300px”<br>元素.style.backgroundColor&#x3D;”yellow” 需要将样式名改为驼峰命名的写法</p>
<p>读取样式 (但通过style无法读取样式表中的样式)<br>元素.style.backgroundColor<br><br/>  </p>
<h4 id="获取元素的样式"><a href="#获取元素的样式" class="headerlink" title="获取元素的样式:"></a>获取元素的样式:</h4><p>读取当前元素正在显示的样式:元素.currentStyle.width（这个只有IE支持）<br>在其他浏览器中可以使用getComputedStyle(元素,null)来获取当前样式，返回的是一个对象，读取样式:对象.样式名<br>上面这两个都是只读，不能修改，<br>而修改必须要用style属性<br><br/></p>
<h4 id="其他样式相关的属性"><a href="#其他样式相关的属性" class="headerlink" title="其他样式相关的属性:"></a>其他样式相关的属性:</h4><p>元素.clientWidth  可见宽   没有单位(包括内容区和内边距) 只读属性<br>元素.offsetWidth  包括内容区，内边距，边框  没有单位<br>offsetParent  会获取到离当前元素最近的并且开启了定位的祖先元素<br>offsetLeft 当前元素相对于其定位元素的水平偏移量<br>scollWidth  滚动区域的高度<br>scrollLeft  获取水平滚动条滚动的距离<br>说明垂直滚动条到底了: scrollHeight-scrollTop&#x3D;clientHeight<br>元素.onscroll&#x3D;function(){}滚动条的滚动事件<br>input.disabled&#x3D;true 设置元素禁用<br>input.disabled&#x3D;false  设置元素可用<br><br/></p>
<h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象:"></a>事件对象:</h4><p>onmousemove：在元素内移动时触发<br>事件对象:当事件的响应函数被触发时,浏览器每次都会将一个事件对象作为实参传递进响应函数。事件对象中封装了当前事件相关的所有细节<br>window.event 在ie8以下，还有chrome中将事件对象作为window的属性保存的，<br>在火狐中是作为实参传进来(function(event))</p>
<p>event&#x3D;event||window.event 解决兼容性问题<br><br/></p>
<h4 id="div跟随鼠标移动"><a href="#div跟随鼠标移动" class="headerlink" title="div跟随鼠标移动:"></a>div跟随鼠标移动:</h4><p>document.onmousemove&#x3D;function(event){<br>event&#x3D;event||window.event;<br>var left&#x3D;event.clientX;鼠标在当前的 可见窗口 中的坐标，当页面出现滚动条，容易出现bug<br>var top&#x3D;event.clientY;</p>
<p>var left&#x3D;event.pageX；鼠标相对于整个页面的坐标,这个属性在ie8中不支持</p>
<p>box1.style.left&#x3D;left+”px”;  这里元素需要开启定位才能生效，这里的参照物是整个页面</p>
<p>}<br><br/></p>
<h4 id="事件的冒泡"><a href="#事件的冒泡" class="headerlink" title="事件的冒泡:"></a>事件的冒泡:</h4><p>指事件的向上传导，当后代元素的事件被触发时，它的祖先元素的相同事件也会被触发<br>document.body.onclick&#x3D;function(event){<br>如果要取消冒泡 event.cancelBubble&#x3D;true;<br>或者<br>event.stopPropagation();<br><br/></p>
<h4 id="事件的委派"><a href="#事件的委派" class="headerlink" title="事件的委派:"></a>事件的委派:</h4><p>指事件统一绑定给元素共同的祖先元素,当后代元素身上的事件触发时,会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件</p>
<p>好处:可以减少事件绑定的次数，提高程序的性能<br>event.target 表示事件触发的对象<br><br/></p>
<h4 id="事件的绑定"><a href="#事件的绑定" class="headerlink" title="事件的绑定:"></a>事件的绑定:</h4><p>1 使用对象.事件&#x3D;函数 的形式绑定响应函数<br>它只能为一个元素的同一个事件绑定一次响应函数<br>不能绑定多个，如果绑定多个，则后面的会覆盖前面的</p>
<p>2 addEventListener()<br>可以为同一个元素的同一个事件绑定多个响应函数(ie8及以下不支持)<br>参数:<br>事件的字符串，不要on<br>回调函数，当事件触发时，该函数会被调用<br>是否在捕获阶段触发事件，需要一个值，一般都为false<br>btn1.addEventListener(“click”,function(){},false)<br>这里的this是绑定事件的对象</p>
<p>在ie8中可以使用<br>btn.attachEvent(“onclick”,function(){}）和上面不同的是 这个 是 事件后绑定先执行，<br>这里的this是window<br><br/></p>
<h4 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播:"></a>事件的传播:</h4><p>W3C将事件传播分为3个阶段:<br>1 捕获阶段（先触发捕获 最后才触发冒泡）<br>从最外层的祖先元素向目标元素进行事件的捕获，但是默认此时不会触发事件</p>
<p>2 目标阶段<br>事件捕获到目标元素 捕获结束 开始在目标元素上触发事件</p>
<p>3 冒泡阶段<br>事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件</p>
<p>如果希望在捕获阶段触发事件，可以将addEventListener的第三个参数设置为true</p>
<p>在ie8及一下的浏览器中没有捕获阶段<br><br/></p>
<h4 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽:"></a>拖拽:</h4><p>取消事件</p>
<p>document.onmouseup&#x3D;null<br>当拖拽网页中的内容时,浏览器会默认在搜索引擎中搜索内容，<br>此时会导致拖拽功能的异常，这是浏览器提供的默认行为，<br>如果不希望出现这个行为,可以通过return false 来取消默认行为，但在ie8中不奏效</p>
<p>使用addEventListener绑定事件取消默认行为是不能使用return false,<br>而是使用event.preventDefault()<br><br/></p>
<h4 id="滚轮事件"><a href="#滚轮事件" class="headerlink" title="滚轮事件:"></a>滚轮事件:</h4><p>box1.onmousewheel&#x3D;function(event){但火狐不支持<br>event.wheelDelta 可以获取鼠标滚轮滚动的方向  正值向上  负值向下<br>}<br><br/></p>
<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件:"></a>键盘事件:</h4><p>一般都会绑定给一些可以获取到焦点的对象或者是document(input,..)<br>onkeydown：键盘被按下<br>onkeyup:键盘被松开</p>
<p>document.onkeydown&#x3D;function(event){<br>console.log(event.keyCode) 按键的编码<br>event.key  按键的名字</p>
<p>event.altKey<br>event.ctrlKey<br>event.shiftKey 这三个用来判断alt,ctrl,shift是否被按下，如若按下了则返回true</p>
<p>在文本框中输入内容，属于onkeydown的默认行为<br>使文本框中不能输入数字<br>if(event.keyCode&gt;&#x3D;48&amp;&amp;event.keyCode&lt;&#x3D;57){<br>return false;<br>}<br><br/></p>
<p>BOM对象:</p>
<p>BOM（Brower Object Model）：浏览器对象模型，可以通过js来操作浏览器</p>
<p>DOM(Document Object Model):文档对象模型</p>
<p>BOM对象:</p>
<p>Window 整个浏览器的窗口,同时也是网页中的全局对象</p>
<p>Navigator 当前浏览器的信息，可以用这个识别不同的浏览器</p>
<p>Location  浏览器的地址栏  可以获取地址栏信息,或者操作浏览器跳转页面，location&#x3D;”<a target="_blank" rel="noopener" href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a> 或者 “01.html”直接跳转页面,并且会生成相对应的历史记录 ，location.reload(true):强制清空缓存刷新 location.assigin(“http:&#x2F;&#x2F;…”) 与location一样,location.replace(“http:&#x2F;&#x2F;…”)也能跳转，但不会生成历史记录</p>
<p>History 可以操作浏览器的历史记录，只能向前或向后翻页，只能在当次访问时有效,history.length:当前访问的链接数量（如果关闭浏览器就没了）,history.back():可以回到到上一个页面，和浏览器的回退按钮一样，history.forward():跳转到下一个页面，和浏览器的前进按钮一样，history.go() 可以跳转到指定的页面，需要一个整数作为参数 1表示向前跳转一个页面,-1表示向后跳转一个页面</p>
<p>Screen 用户的屏幕的信息,</p>
<p>这些BOM对象都是作为window对象的属性保存的<br>可以通过window的对象使用，也可以直接使用<br><br/></p>
<h4 id="定时器简介"><a href="#定时器简介" class="headerlink" title="定时器简介:"></a>定时器简介:</h4><p>setInterval(function(){},1000)<br>定时调用:每隔一段时间执行一次回调函数<br>时间单位是毫秒<br>返回一个number类型的数据<br>这个数字作为定时器的唯一标识</p>
<p>清除上面的定时器<br>var timer&#x3D;setInterval(…)<br>clearInterval(timer);<br>可以接收任意参数，<br>如果参数是一个有效的定时器标识，则会停止定时器<br>如果不是一个有效的标识，则什么也不会做</p>
<p>如果同时开启多个定时器，则会速度变快，需要在开启前清除掉上一个</p>
<p>setTimeout(function(){},300)<br>延时调用一个函数不马上执行，而是隔一段时间之后再执行，而且只会执行一次<br>clearTimeout(…)</p>
<p>定时器真的是定时执行的吗:<br>定时器并不能保证真正定时执行<br>一般会延迟一丁点(可以接受),也有可能延迟很长时间(不能接受:如 外面存在一个for循环  循环次数非常分大 1后面10个0,而定时器回调函数是在主线程执行的 并且js是单线程)</p>
<p>定时器是如何实现的:<br>事件循环模型<br><br/></p>
<h4 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图:"></a>轮播图:</h4><p>为每一个链接添加属性 all[i].num&#x3D;i;<br><br/></p>
<h4 id="类的操作"><a href="#类的操作" class="headerlink" title="类的操作:"></a>类的操作:</h4><p>可以修改元素class的属性来间接修改样式<br>box.className&#x3D;”m2”;</p>
<p>.m2{<br>…<br>}</p>
<p>box.className+&#x3D;” m2”<br><br/></p>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON:"></a>JSON:</h4><p>是一个特殊格式的字符串，这个字符串可以被任何的语言识别，主要用来数据的交互<br>‘{“name”:”涨潮”,”action”：”冲刷”}’<br>JSON中的属性名必须加双引号<br>JSON中允许的值：<br>1 字符串<br>2 布尔值<br>3 数值<br>4 null<br>5 对象(普通对象)<br>6 数组</p>
<p>JSON.parse()<br>可以将JSON字符串转换为js对象，<br>需要一个JSON字符串作为参数</p>
<p>JSON.stringify()<br>可以将一个js对象转换为JSON字符串</p>
<h4 id="eval"><a href="#eval" class="headerlink" title="eval:"></a>eval:</h4><p>eval（）<br>可以执行一段字符串形式的JS代码,并将执行结果返回<br>eval(“alert(‘hello’);”)</p>
<p>如果eval执行的过程中有{},它会将{}当成是代码块，<br>如果不希望将其当成代码块解析，则需要在字符串前后各加一个<br>如<br>‘{“name”:”涨潮”,”action”：”冲刷”}’ 改成<br> ‘({“name”:”涨潮”,”action”：”冲刷”})’<br>或者 eval(“(“+str+”)”)<br><br/></p>
<h4 id="变量声明提升与函数提升："><a href="#变量声明提升与函数提升：" class="headerlink" title="变量声明提升与函数提升："></a>变量声明提升与函数提升：</h4><p>变量提升在函数提升之前</p>
<p>通过var定义的变量，在定义语句之前就可以访问到，只是值为undefined<br>通过function声明的函数,在之前就可以直接调用<br><br/></p>
<h4 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链:"></a>作用域与作用域链:</h4><p>作用域:在编写代码时就确定了，和函数调用没有关系。<br>分类:<br>全局作用域<br>函数作用域<br>没有块作用域(ES6有了)<br>作用:<br>隔离变量,不同作用域下同名变量不会有冲突。</p>
<p>作用域链:<br>多个上下级关系的作用域形成的链,它的方向是从下往上的(从内到外)。<br>查找变量时就是沿着作用域链来查找的。</p>
<h4 id="循环遍历加监听"><a href="#循环遍历加监听" class="headerlink" title="循环遍历加监听:"></a>循环遍历加监听:</h4><p>for(var i&#x3D;0,length&#x3D;btns.length;i&lt;length;i++){<br>var btn&#x3D;btns[i];<br>btn.index&#x3D;i;&#x2F;&#x2F;将btn所对应的下标保存在btn上<br>btn.onclick&#x3D;function(){<br>alert(‘第+(this.index+1)+个’)<br>}</p>
<p>1 2 3 4 …</p>
<p>利用闭包同样可以实现:<br>for(var i&#x3D;0,length&#x3D;btns.length;i&lt;length;i++){<br>(function(i){ 这里据作用域是不同的，每次执行立即执行函数中的i和for循环里的i都不一样，因为作用域不同<br>var btn&#x3D;btns[i];<br>btn.onclick&#x3D;function(){<br>alert(‘第+(i+1)+个’)<br>}<br>)(i)<br>}<br><br/><br><br/></p>
<h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承:"></a>原型链继承:</h4><p>关键点:子类型的原型是父类型的一个实例对象<br>父类型:<br>function Supper(){<br>this.supProp&#x3D;”Supper property”;<br>}</p>
<p>Supper.prototype.showSupperProp&#x3D;function(){<br>console.log(this.supProp);<br>}</p>
<p>子类型:<br>function Sub(){<br>this.subProp&#x3D;”Sub property”;<br>}</p>
<p>Sub.prototype.showSubProp&#x3D;function(){<br>console.log(this.subProp);<br>}</p>
<p>vra sub&#x3D;new Sub();<br>sub.showSupperProp();报错<br>sub.toString();可以 （内部执行了一句代码:Sub.prototype&#x3D;{}；透过这个对象可以看到 object.prototype身上的toString方法）</p>
<p>所以想让子类型实例对象看到父类型中的方法，需加上:<br>Sub.prototype&#x3D;new Supper();</p>
<p>此时 Sub.constructor 是 Supper函数，因为这个construtor构造器属性只在原型对象身上(即Sub.prototype),并且人为指向了Supper实例对象</p>
<p>所以还应该加上；<br>Sub.prototype.constructor&#x3D;Sub;让子类型的原型的constructor指向子类型<br><br/><br><br/></p>
<h4 id="借用构造函数继承（假的）"><a href="#借用构造函数继承（假的）" class="headerlink" title="借用构造函数继承（假的）:"></a>借用构造函数继承（假的）:</h4><p>s实际上只是简化了代码(借用其他函数初始化了一些相同的属性)<br>关键：在子类型的构造函数中通过call（）调用父类型的构造函数<br>function Person(name,age){<br>this.name&#x3D;name;<br>this.age&#x3D;age;<br>}</p>
<p>function Student(name,age,price){<br>Person.call(this,age,price);相当于 this.age&#x3D;age;this.price&#x3D;price;<br>this.price&#x3D;price;<br>}</p>
<p>new Student(‘Tom’,20,100);</p>
<h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核:"></a>浏览器内核:</h4><p>是支撑浏览器运行的最核心的程序:<br>Chrome,Safari：webkit<br>firefox：Gecko<br>IE：Trident<br>360,搜狗等国内浏览器:Trident+webkit（双核双驱动）</p>
<p>不同的浏览器可能不一样</p>
<p>内核由很多模块组成：<br>内核是一个比较大的程序，有很多模块<br>如:<br>js引擎(也是代码，起到一个解释的作用)模块:负责js程序的编译与运行 </p>
<p>html,css文档解析模块:负责页面文本的(如输入百度网址回车后  最先得到(读取)html,css的文本，然后进行拆解(根据一定的规则拆解，如标签  html,body,…))</p>
<p>Dom&#x2F;Css模块:负责dom&#x2F;css在内存中的相关处理(如看到一个p 标签，会生成一个p标签对象，这个对象还会有top,left,等一些如何显示的数据)</p>
<p>布局和渲染模块:负责页面的布局和效果的绘制(参照内存中的对象)</p>
<p>（以上四个模块运行在 主线程）</p>
<p>(以下的模块是运行在 分线程)<br>定时器模块:负责定时器的管理(如 setTimeout(fn,3s)，但里面的fn回调函数是在主线程中运行的)<br>事件管理模块:负责事件的管理(如 对一个按钮进行监听)<br>网络请求模块:负责ajax请求</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/14/js1/" data-id="cl1dgc7dz000548no0f3h46js" data-title="js1" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/02/25/%E8%AE%A1%E7%AE%97%E9%A2%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          计算题
        
      </div>
    </a>
  
  
    <a href="/2022/02/14/github%E5%AE%98%E7%BD%91%E5%BF%AB%E9%80%9F%E8%BF%9B%E5%85%A5%E7%9A%84%E6%96%B9%E6%B3%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">github官网快速进入的方法</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/25/vue2-0-3-0/">vue2.0+3.0</a>
          </li>
        
          <li>
            <a href="/2022/03/22/ES6-11/">ES6-11</a>
          </li>
        
          <li>
            <a href="/2022/03/17/ajax/">ajax</a>
          </li>
        
          <li>
            <a href="/2022/02/25/js2/">js2</a>
          </li>
        
          <li>
            <a href="/2022/02/25/%E8%AE%A1%E7%AE%97%E9%A2%98/">计算题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>