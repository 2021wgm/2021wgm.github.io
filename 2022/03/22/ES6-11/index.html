<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>ES6-11 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="javaScript基本语法 即es5的相关语法 let变量声明及声明特性:1 变量不能重复声明如 let a&#x3D;1;let a&#x3D;2; 报错 2 块级作用域 在{}里面有效，出了这个区域就会无效(而在javascript中没有这个作用域，只会有 函数作用域 全局作用域 eval作用域 eval作用域只会出现在严格模式下) 在if else while for里面 如果用let 声">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6-11">
<meta property="og:url" content="http://example.com/2022/03/22/ES6-11/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="javaScript基本语法 即es5的相关语法 let变量声明及声明特性:1 变量不能重复声明如 let a&#x3D;1;let a&#x3D;2; 报错 2 块级作用域 在{}里面有效，出了这个区域就会无效(而在javascript中没有这个作用域，只会有 函数作用域 全局作用域 eval作用域 eval作用域只会出现在严格模式下) 在if else while for里面 如果用let 声">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-03-22T06:15:40.000Z">
<meta property="article:modified_time" content="2022-03-26T09:10:28.529Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-ES6-11" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/22/ES6-11/" class="article-date">
  <time class="dt-published" datetime="2022-03-22T06:15:40.000Z" itemprop="datePublished">2022-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      ES6-11
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>javaScript基本语法 即es5的相关语法</p>
<h4 id="let变量声明及声明特性"><a href="#let变量声明及声明特性" class="headerlink" title="let变量声明及声明特性:"></a>let变量声明及声明特性:</h4><p>1 变量不能重复声明<br>如 let a&#x3D;1;<br>let a&#x3D;2; 报错</p>
<p>2 块级作用域</p>
<p>在{}里面有效，出了这个区域就会无效(而在javascript中没有这个作用域，只会有 函数作用域 全局作用域 eval作用域 eval作用域只会出现在严格模式下)</p>
<p>在if else while for里面 如果用let 声明 也会出现块级作用域</p>
<p>3 不存在变量提升</p>
<p>4 不影响作用域链(由内到外查找)</p>
<h4 id="const声明常量及其特点"><a href="#const声明常量及其特点" class="headerlink" title="const声明常量及其特点:"></a>const声明常量及其特点:</h4><p>常量:值不能修改的量<br>一般常量使用大写</p>
<p>1 一定要赋初始值</p>
<p>2 常量的值不能修改</p>
<p>3 块级作用域</p>
<p>4 对于数组和对象的元素修改  不算作对常量的修改,不会报错<br>如  const arr&#x3D;[];<br>arr.push(1)<br>虽然arr的元素发生变化，但arr所指向的地址值没有发生变化<br>但如果 arr&#x3D;10 则会报错 因为原来的地址值变化了</p>
<h4 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值:"></a>变量的解构赋值:</h4><p>1 数组的解构<br>const f4&#x3D;[‘老王’,’老张’,’老李’,’老桃’];<br>let（var） [wang,zhang,li,tao]&#x3D;f4;<br>wang 的值为 ‘老王’<br>…</p>
<p>2 对象的解构</p>
<p>const shan&#x3D;{<br>name：’隔壁老王’,<br>age:’不详’,<br>dance:function（）{}<br>}</p>
<p>let  {name,age,dance}&#x3D;shan;</p>
<p>name为隔壁老王<br>…</p>
<h4 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串:"></a>模版字符串:</h4><p>&#96;&#96;反引号<br>let str&#x3D;<code>你是谐星吗</code></p>
<p>1 内容中可以出现换行</p>
<p>2 变量拼接</p>
<p>let a&#x3D;<code>$&#123;str&#125;是的</code></p>
<h4 id="对象的简化写法"><a href="#对象的简化写法" class="headerlink" title="对象的简化写法:"></a>对象的简化写法:</h4><p>如:<br>let name&#x3D;’老王’;<br>let change&#x3D;function(){}</p>
<p>const school&#x3D;{<br>name,change<br>} 这种写法等价于<br>const school&#x3D;{<br>name:name,<br>change：change<br>}</p>
<p>还有 声明的简化<br>const school&#x3D;{<br>name:name,<br>change：change，<br>improve:function(){}<br>}可以简化成<br>const school&#x3D;{<br>name:name,<br>change：change，<br>improve(){}<br>}</p>
<h4 id="箭头函数及其声明特点"><a href="#箭头函数及其声明特点" class="headerlink" title="箭头函数及其声明特点:"></a>箭头函数及其声明特点:</h4><p>原来<br>let fn&#x3D;function(){}</p>
<p>现在 let fn&#x3D;(a,b)&#x3D;&gt;{<br>return a+b;<br>}</p>
<p>1 箭头函数中this是静态的 始终指向函数声明时所在作用域下的this的值<br> 无法 通过call,apply等方式去改变this的值 （本身是没有this的，所以会自动往外找）</p>
<p>2 不能作为构造函数来实例化对象</p>
<p>3 箭头函数中不能使用arguments变量</p>
<p>4 箭头函数的简写</p>
<ol>
<li><p>省略小括号 当形参有且只有一个的时候<br>let add&#x3D; (n)&#x3D;&gt;{<br>return n+n;<br>}<br>可直接简化成<br>let add&#x3D; n&#x3D;&gt;{<br>return n+n;<br>}</p>
</li>
<li><p>省略花括号 当代码体只有一条语句的时候,此时return 也必须省略 而且语句的执行结果就是函数的返回值</p>
</li>
</ol>
<p>let add&#x3D; n&#x3D;&gt;{<br>return n+n;<br>} 简化成<br>let add&#x3D; n&#x3D;&gt;n+n;</p>
<p>应用场景</p>
<p>btn.onclick&#x3D;function(){<br>setTimeout(function(){<br>console.log(this)  这里的this是 window<br>},3000)<br>}</p>
<p>btn.onclick&#x3D;function(){<br>setTimeout(()&#x3D;&gt;{<br>console.log(this)  换成箭头函数后这里的this是 btn元素<br>},3000)<br>}</p>
<h4 id="es6允许给函数参数赋值初始值"><a href="#es6允许给函数参数赋值初始值" class="headerlink" title="es6允许给函数参数赋值初始值:"></a>es6允许给函数参数赋值初始值:</h4><p>1 具有默认值的参数一般放在最后(放其他位置也不会有错，但没有意义)<br>function add(a,b,c&#x3D;10){<br>return a+b+c;<br>}</p>
<p>2 与解构赋值结合<br>function connnect({name,host&#x3D;’127.0.0.1’}){ 如果没有传 走默认值</p>
<p>console.log(name)<br>}</p>
<p>connect({<br>host:’localhost’<br>…<br>})</p>
<h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数:"></a>rest参数:</h4><p>rest参数必须放在最后<br>function (…args){}  args为一个数组</p>
<p>与arguments不同的是</p>
<p>args的原型是一个数组，可以用数组的方法<br>而arguments的原型是一个对象，不能用数组的方法</p>
<h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符:"></a>扩展运算符:</h4><p>1 能将数组转换成 以逗号 分隔开的参数序列</p>
<p>2 数组的合并</p>
<p>var arr1&#x3D;[1,2];<br>var arr2&#x3D;[3,4];</p>
<p>var arr3&#x3D;[…arr1,…arr2];[1,2,3,4]</p>
<p>3 数组的克隆(如果里面有引用类型，就是浅拷贝)<br>var sanzhihua&#x3D;[‘a’,’b’,’c’];<br>var yiduohua&#x3D;[…sanzhihua];</p>
<p>4 将伪数组转化为真正的数组<br>var divs&#x3D;document.querySelectorAll(‘div’)  NodeList伪数组对象</p>
<p>var arr&#x3D;[…divs]</p>
<p>还可以将多个对象的属性和属性值合并到一个对象里：<br>var obj1&#x3D;{name:1}  var obj2&#x3D;{city:2}  var obj3&#x3D;{action:3}</p>
<p>var obj4&#x3D;{…obj1,…obj2,…obj3}</p>
<h4 id="Symbol的介绍与创建"><a href="#Symbol的介绍与创建" class="headerlink" title="Symbol的介绍与创建:"></a>Symbol的介绍与创建:</h4><p>一种新的数据类型</p>
<p>1 Symbol的值是惟一的，可以解决命名冲突的问题</p>
<p>2 Symbol的值不能与其他数据进行运算</p>
<p>3 Symbol定义的对象属性不能使用for… in 循环遍历，但可以使用Reflect.ownKeys来获取对象的所有键名</p>
<p>创建Symbol<br>let s&#x3D;Symbol() 当成函数</p>
<p>let s2&#x3D;Symbol(‘尚硅谷’);</p>
<p>let s3&#x3D;Symbol(‘尚硅谷’);</p>
<p>s2不等于s3<br>Symbol.for（） 创建  当成对象</p>
<p>let s4&#x3D;Symbol.for(‘尚硅谷’)<br>let s5&#x3D;Symbol.for(‘尚硅谷’)</p>
<p>s4与s5相等</p>
<p>使用场景<br>给对象添加属性或者方法</p>
<p>let youxi&#x3D;{<br>[Symbol(‘say’)]:function(){},<br>[Symbol(‘dance’)]:function(){}<br>}</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器:"></a>迭代器:</h4><p>iterator 是一种接口<br>任何一种数据结构只要部署了这样一个接口，就可以完成遍历操作<br>是对象中的一种属性 Symbol（Symbol.iterator）</p>
<ol>
<li>es6创建了一种新的遍历命令for…of循环，iterator接口主要供for..of消费</li>
</ol>
<p>2） 具备itrator接口的数据<br>Array<br>arguments<br>Set<br>Map<br>String<br>NodeList</p>
<p>工作原理:<br>创建一个指针对象(由Symbol.iterator这个对象的函数创建一个对象),指向当前数据结构的起始位置<br>第一次调用next方法,指针自动指向数据结构的第一个成员<br>接下来不断调用next方法,指针一直往后移动，直到指向最后一个成员<br>每次调用Next方法返回一个包含value和done属性的对象</p>
<p>const xiyou&#x3D;[‘猴’，’猪’,’打工人’,’光头’]</p>
<p>let iterator&#x3D;xiyou[Symbol.iterator]( ）</p>
<p>调用对象的next方法</p>
<p>console.log(iterator.next());{value：’猴’,done:true}<br>console.log(iterator.next());{value：’猪’,done:true}<br>console.log(iterator.next());{value：’打工人’,done:true}<br>console.log(iterator.next());{value：’光头’,done:true}<br>console.log(iterator.next());{value:undefined,done:false}</p>
<p>需要自定义遍历数据的时候，使用迭代器</p>
<p>如 想要对一个对象使用for…of遍历<br> var obj&#x3D;{name:’老王’,stus:[1,2,3]};<br>因为里面没有迭代器，所以无法用for…of遍历</p>
<p> var obj&#x3D;{<br>name:’老王’,<br>stus:[1,2,3],<br>[Symbol.iterator](）{</p>
<p>return {<br>var that&#x3D;this;<br>var index&#x3D;0;<br>next:function(){<br>if(index&lt;that.stus.length){<br>var result&#x3D; {value:that.stus[i],done:false};<br>i++;<br>return result;<br>}<br>else{<br>return {value:undefined,done:true}<br>}<br>}</p>
<p>}</p>
<p>}<br>};</p>
<p>for(var i in of){<br>console.log(v)<br>}</p>
<p>1<br>2<br>3</p>
<h4 id="生成器函数声明与调用"><a href="#生成器函数声明与调用" class="headerlink" title="生成器函数声明与调用:"></a>生成器函数声明与调用:</h4><p>function * gen（）{</p>
<p>console.log(‘hello generator’);<br>}</p>
<p>let iterator&#x3D;gen();<br>iterator.next(); 这里才执行了上面的函数</p>
<p>生成器函数可以出席那yield语句(函数代码的分隔符)</p>
<p>function * gen（）{<br>console.log(111);<br>yield ‘1’;<br>console.log(222);<br>yield ‘2’;<br>console.log(333);<br>yield ‘3’;</p>
<p>}</p>
<p>let iterator&#x3D;gen();<br>iterator.next();111<br>iterator.next();222<br>iterator.next();333</p>
<p>function * gen（）{</p>
<p>yield ‘1’;</p>
<p>yield ‘2’;</p>
<p>yield ‘3’;</p>
<p>}</p>
<p>console.log（iterator.next());1<br>console.log（iterator.next());2<br>console.log（iterator.next());3</p>
<p>for（var i of gen）{<br>console.log(i)<br>}<br>1  每次迭代是yield后面的内容<br>2<br>3</p>
<h4 id="生成器函数的参数传递"><a href="#生成器函数的参数传递" class="headerlink" title="生成器函数的参数传递:"></a>生成器函数的参数传递:</h4><p>异步编程</p>
<p>function * gen(…args){<br>console.log(args);<br>let one&#x3D;yield ‘1’;<br>console.log(one);<br>yield ‘2’;<br>yield ‘3’;</p>
<p>}</p>
<p>let iterator&#x3D;gen();<br>iterator.next();111</p>
<p>next方法可以传入实参，而这个实参就是整个yield语句的返回结果</p>
<p>第二次调用Next方法传入的实参将作为第一次yield语句的返回结果</p>
<p>iterator.next(‘AAA’);AAA 222 </p>
<p>第三次调用Next方法传入的实参将作为第二次yield语句的返回结果<br>iterator.next();333</p>
<p>生成器函数实例:<br>function one(){<br>setTimeout(function(){<br>console.log(111)</p>
<p>iterator.next(); 解决了回调地狱的问题(回调里面一层套一层)<br>},1000)<br>}</p>
<p>function two(){<br>setTimeout(function(){<br>console.log(222)<br>iterator.next();<br>},2000)<br>}</p>
<p>function three(){<br>setTimeout(function(){<br>console.log(333)<br>},3000)<br>}</p>
<p>function * time(){<br>yield one();<br>yield two();<br>yield three();<br>}</p>
<p>var itertor&#x3D;time();<br>iterator.next();  111 222 333</p>
<h4 id="Promise的介绍与基本使用"><a href="#Promise的介绍与基本使用" class="headerlink" title="Promise的介绍与基本使用:"></a>Promise的介绍与基本使用:</h4><p>实例化promise对象<br>有三个状态 初始化 成功 失败<br>const p&#x3D;new Promise(function(resolve,reject){<br>setTimeout(function(){<br>let data&#x3D;’数据库中的用户数据’;<br>resolve(data);  执行resolve函数后,promise的状态会变成成功</p>
<p>let err&#x3D;’读取失败’;<br>resolve(err);<br>},1000)</p>
<p>})</p>
<p>如果成功后，可以调用then方法<br>如果前面调用了resolve方法，那么就会执行then里面的第一个回调函数<br>如果前面调用了reject方法，那么就会执行then里面的第二个回调函数<br>p.then(function(value){ 这里的value就是resolve函数的实参 </p>
<p>},function(reason){这里的reason就是reject函数的实参</p>
<p>})</p>
<h4 id="promise封装读取文件"><a href="#promise封装读取文件" class="headerlink" title="promise封装读取文件:"></a>promise封装读取文件:</h4><p>读取文件.js<br>const fs&#x3D;require(‘fs’);</p>
<p>调用方法读取文件<br>fs.readFile(‘..&#x2F;… .md’,(err,data)&#x3D;&gt;{<br>if（err）{throw err} 如果失败，抛出错误<br>console.log(data.toString());如果成功，输出结果<br>})</p>
<p>把上面的换成promise封装（如果有多个，那么上面的代码会不停往里面缩进，而promise不会）<br>const p&#x3D;new Promise(function(resolve,reject){<br>fs.readFile(‘..&#x2F;….md’,(err.data)&#x3D;&gt;{<br>if（err）{reject(err)}<br>如果成功  resolve(data);<br>})</p>
<p>})</p>
<p>p.then(function(value){</p>
<p>},function（reason）{</p>
<p>})</p>
<h4 id="使用promise封装ajax"><a href="#使用promise封装ajax" class="headerlink" title="使用promise封装ajax:"></a>使用promise封装ajax:</h4><p>const xhr&#x3D;new XMLHttpRequest()</p>
<p>xhr.open(‘GET’,’<a target="_blank" rel="noopener" href="http://127.0.0.1:8000/server&#39;">http://127.0.0.1:8000/server&#39;</a>)</p>
<p>xhr.send();</p>
<p>xhr.onreadystatechange&#x3D;function(){<br>if(xhr.readyState&#x3D;&#x3D;4){<br>if(xhr.status&#x3D;&#x3D;200&amp;&amp;xhr.status&lt;300){}</p>
<p>下面用promise对上面代码封装:<br>const p&#x3D;new Promise((resolve,reject)&#x3D;&gt;{</p>
<p>const xhr&#x3D;new XMLHttpRequest()</p>
<p>xhr.open(‘GET’,’<a target="_blank" rel="noopener" href="http://127.0.0.1:8000/server&#39;">http://127.0.0.1:8000/server&#39;</a>)</p>
<p>xhr.send();</p>
<p>xhr.onreadystatechange&#x3D;function(){<br>if(xhr.readyState&#x3D;&#x3D;4){<br>if(xhr.status&#x3D;&#x3D;200&amp;&amp;xhr.status&lt;300){<br>resolve(xhr.response)}<br>else<br>{<br>reject(xhr.status)<br>}</p>
<p>})</p>
<p>p.then(function(value){},function(reason){})</p>
<h4 id="关于promise的then方法"><a href="#关于promise的then方法" class="headerlink" title="关于promise的then方法:"></a>关于promise的then方法:</h4><p>then方法的返回结果也是一个promise</p>
<p>如果回调函数中返回的结果是非promise类型的属性，状态为成功,返回值为对象成功的值<br>如果没有写返回结果，默认返回undefined<br>const result&#x3D;p.then(function(value){<br>return 1},function(reason){})</p>
<p>这里result的值 promiseValue为123 promiseStatus为:resolved</p>
<p>如果回调函数中返回的结果是promise类型的属性，状态为成功,返回值为对象成功的值<br>const result&#x3D;p.then(function(value){<br>return </p>
<p>new Promise((resolve,reject)&#x3D;&gt;{<br>resolve(‘ok’)<br>})     这里promise的状态就决定了then方法的返回结果的状态，这里成功的值就是thenn方法返回结果的值<br>},function(reason){})</p>
<p>如果抛出错误,结果为rejected<br>const result&#x3D;p.then(function(value){<br>throw ‘出错了’<br>},function(reason){})</p>
<p>因为then方法可以返回一个promise对象，所以可以链式调用<br>链式调用(解决回调地狱)<br>使用场景:先有，然后才有,最后才有.</p>
<p>p.then(value&#x3D;&gt;{},reason&#x3D;&gt;{} 这里第二个错误的回调也可以不写).then(value&#x3D;&gt;{</p>
<p>})</p>
<h4 id="promise对象的catch方法"><a href="#promise对象的catch方法" class="headerlink" title="promise对象的catch方法:"></a>promise对象的catch方法:</h4><p>const p&#x3D;new Promise(function(resolve,reject){<br>reject(‘出错了’)<br>}</p>
<p>下面两种都可以<br>p.then(function(){},function(reason){<br>console.log(reason);})</p>
<p>p.catch(function(reason){<br>console.log（reason）</p>
<p>})</p>
<h4 id="Set："><a href="#Set：" class="headerlink" title="Set："></a>Set：</h4><p>Set（集合）<br>类似数组<br>成员的值都是唯一的<br>集合实现了iterator接口，所以可以使用扩展运算符展开和for..of进行遍历</p>
<p>属性和方法:<br>const s&#x3D;new Set（[1,2,3,4]）<br>类型为 ‘object’</p>
<p>个数: s.size</p>
<p>添加元素:s.add(‘111’)</p>
<p>删除元素:s.delete(3)</p>
<p>检测: s.has(3) 有 返回true,否则返回false</p>
<p>清空: s2.clear()</p>
<p>可用于数组去重:<br>[…new Set(arr)]</p>
<h4 id="Map："><a href="#Map：" class="headerlink" title="Map："></a>Map：</h4><p>类似对象（就是升级版的对象），也是键值对的集合<br>但是键的范围不限于字符串，各种类型的值(包括对象)都可以当作键<br>map也实现了iterator接口</p>
<p>let m&#x3D;new Map();</p>
<p>添加元素:m.set(‘name’,’尚硅谷’)<br>m.set(‘change’,function(){})</p>
<p>let key&#x3D;{school:’atguigu’};<br>m.set(key,[‘北京’,’上海’,’广州’]); 这里是对象作为键名</p>
<p>个数:m.size<br>删除:m.delete(‘name’)<br>获取:m.get(‘change’)<br>清空:m.clear();</p>
<h4 id="class的介绍："><a href="#class的介绍：" class="headerlink" title="class的介绍："></a>class的介绍：</h4><p>class Phone{</p>
<p>构造方法 名字不能修改<br>constructor(a,b){当出席那new Phone()时该构造函数就会执行<br>this.a&#x3D;a;<br>this.b&#x3D;b;<br>}</p>
<p>方法必须使用该语法,不能使用es5的对象完整形式<br>call(){</p>
<p>}<br>}</p>
<p>var m&#x3D;new Phone(‘1’,2)</p>
<p>上面换成es5的写法:<br>function Phone(a,b){<br>this.a&#x3D;a;<br>this.b&#x3D;b;</p>
<p>}</p>
<p>Phone.prototype.call&#x3D;function（）{}</p>
<p>var m&#x3D;new Phone();</p>
<h4 id="class的静态成员"><a href="#class的静态成员" class="headerlink" title="class的静态成员:"></a>class的静态成员:</h4><p>es5的写法:<br>function Phone(){}</p>
<p>Phone.name&#x3D;’1’; 函数也是一个对象<br>Phone.change&#x3D;function(){};</p>
<p>let a&#x3D; new Phone();<br>a.name;undefined<br>a.change;报错</p>
<p>实例和构造函数对象是不相通的<br>实例是和构造函数对象的原型是相通的</p>
<p>如果 Phone.name&#x3D;’1’ 写成  Phone.prototype.name&#x3D;’1’ 则实例也能拿到</p>
<p>属于函数对象，而不属于实例的成员 称为 静态成员</p>
<p>上面换成es6写法后</p>
<p>class Phone{<br>static name&#x3D;1  静态成员<br>static change(){}<br>}</p>
<p>var a&#x3D;new Phone()<br>a.name ：undefined<br>Phone.name :1</p>
<h4 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承:"></a>class的继承:</h4><p>class Phone{<br>constructor(a,b){<br>this.a&#x3D;a;<br>this.b&#x3D;b;<br>}<br>call(){}<br>}</p>
<p>class SmartPhone extends Phone{<br>constructor（a,b,c,d）{<br>super(a,b)调用父类方法  相当于es5中的 Phone.call(this,a,b);<br>this.color&#x3D;color;<br>this.size&#x3D;size;<br>}</p>
<p>photo(){}<br>}</p>
<p>const a&#x3D;new SmartPhone(1,2,3,4);<br>父类方法也可以调用</p>
<h4 id="子类对父类方法的重写"><a href="#子类对父类方法的重写" class="headerlink" title="子类对父类方法的重写:"></a>子类对父类方法的重写:</h4><p>可以在字类声明一个和父类重名的方法</p>
<p>后面子类实例调用这个重名方法时，是子类的，父类中的同名方法，字类实例是无法调用的</p>
<h4 id="getter与setter："><a href="#getter与setter：" class="headerlink" title="getter与setter："></a>getter与setter：</h4><p>当获取某个属性时执行get函数<br>当对某个属性进行设置时执行set函数</p>
<p>class Phone{<br>get  price(){<br>console.log(‘1’)<br>return 11  这里的返回值就是  s.price的返回值<br>}</p>
<p>set Price(value){}</p>
<p>}</p>
<p>let s&#x3D;new Phone();<br>console.log(s.price) 1  11<br>s.price&#x3D;2;</p>
<h4 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展:"></a>数值扩展:</h4><p>Number.EPSILON是javaScript表示的最小精度:<br>function equal(a,b){<br>if（Math.abs(a-b)&lt;Number.EPSILON）{<br>return true;<br>}else{return false;}<br>}</p>
<p>console.log(equal(0.1+0.2,0.3))</p>
<p>Number.isFinite()检测一个数是否为有限数:<br>Number.isFinite(1): true<br>Number.isFinite(100&#x2F;0): false<br>Number.isFinite(Infinity): false</p>
<p>Number.isNaN()检测一个数值是否是NaN：<br>Number.isNaN(123) false</p>
<p>Number.isInteger()判断一个数是否是整数：<br>Number.isInteger(1)  true<br>Number.isInteger(2.5)  false</p>
<p>Math.trunc()将一个数的小数部分去掉<br>Math.trunc(3.5)  3</p>
<p>Math.sign（） 检测一个数是否是正数 0 负数</p>
<p>Math.sign（100） 1<br>Math.sign（0） 0<br>Math.sign（-100） -1</p>
<h4 id="对象方法的扩展"><a href="#对象方法的扩展" class="headerlink" title="对象方法的扩展:"></a>对象方法的扩展:</h4><p>Object.is()  判断两个值是否完全相等(&#x3D;&#x3D;&#x3D;) </p>
<p>Object.is(100,100)  true</p>
<p>特殊情况:<br>Object.is(NaN,NaN)  true</p>
<p>Object.assign（obj1,obj2）:对象的合并<br>如果出现属性重名 ，后面会覆盖前面的，如果前面对象出现 后面对象属性中没有的 则会被保留下来</p>
<p>Object.setPrototypeOf（）  改变一个对象的原型对象<br>const school&#x3D;{};<br>const cities&#x3D;{};<br>Object.setPrototypeOf(school,cities); 把school的原型对象改成了cities对象</p>
<p>Object.getPrototypeOf  获取一个对象的原型对象<br>Object.setPrototypeOf（school） 为cities</p>
<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化:"></a>模块化:</h4><p>优势:<br>防止命名冲突<br>代码复用<br>高维护性(产品升级需要做改动时，只需改一部分文件)</p>
<p>语法:<br>import  输入其他模块的功能<br>export 规定模块的对外接口</p>
<p>如:<br>1.html中</p>
<script type='module'>
import * as m1 from '../1.js' 也可以用解构赋值的形式  import {m,fun} from '../1.js' 
console.log(m1)
</script>

<p>1.js:<br>export let m&#x3D;10;<br>export function fun(){}</p>
<p>也可以<br>let m&#x3D;10;<br>function fun(){}<br>export {m,fun}</p>
<p>还可以<br>export default{<br>m:10,<br>fun:function(){}</p>
<p>}</p>
<p>第3种调用时   m1.default.fun()</p>
<p>当不同的js模块被引入到同一个文件中时，并且变量名出现重名，可以使用别名<br>  import {m as guigu,fun} from ‘..&#x2F;1.js’</p>
<p>导入时 如果是默认暴露 使用结构赋值形式<br>import {default as m3} from ‘..&#x2F;1.js’</p>
<p>简便形式 针对默认暴露:<br>import m3 from ‘..&#x2F;1.js’</p>
<p>模块化 还可以 把上面3个js文件导入到一个新的文件4.js中<br>然后在html页面中</p>
<script src='./4.js' type='module'></script>




<h4 id="babel对es6模块化代码转换"><a href="#babel对es6模块化代码转换" class="headerlink" title="babel对es6模块化代码转换:"></a>babel对es6模块化代码转换:</h4><p>npm init –yes<br>npm i babel-cli babel-preset-env browserify -D(开发依赖)</p>
<p>如果这里是局部安装  npx babel  src&#x2F;js（文件路径）  -d（要存到哪里） dist&#x2F;js –presets&#x3D;babel-preset-env  </p>
<p>如果是全局安装  babel …</p>
<p>(代码依然无法在浏览器中运行)还需要打包<br>npx browserify dist&#x2F;js&#x2F;app.js -o dist&#x2F;bundle.js</p>
<h4 id="es6模块化引入npm包"><a href="#es6模块化引入npm包" class="headerlink" title="es6模块化引入npm包:"></a>es6模块化引入npm包:</h4><p>npm i jquery</p>
<p>import $ from ‘jquery’<br>$(‘body’).css(‘background’,pink)</p>
<h4 id="es7新特性-includes-和"><a href="#es7新特性-includes-和" class="headerlink" title="es7新特性 includes 和 **:"></a>es7新特性 includes 和 **:</h4><p>var arr&#x3D;[1,2]</p>
<p>arr.includes(3) false</p>
<p>2的10次方<br>2 ** 10    1024 与Math.pow(2,10) 效果一样</p>
<h4 id="es8新特性-async-和-await"><a href="#es8新特性-async-和-await" class="headerlink" title="es8新特性 async 和 await:"></a>es8新特性 async 和 await:</h4><p>async:<br>async函数的返回值为promise对象(即便里面写的是return 1)</p>
<p>如果返回的结果不是一个promise对象，返回的结果就是成功的Promise对象<br>如果里面抛出错误（throw new Error(‘出错了’)），则返回一个失败状态的promise</p>
<p>返回的结果如果是一个promise对象，resolve或者reject里面的结果就是函数的结果，函数的状态与这里的promise对象状态一样</p>
<p>await:<br>await必须放在async函数里面 （但是async里面可以没有await）<br>await右侧的表达式一般是promise对象<br>await返回的是promise成功的值<br>await的promise失败了,就会抛出异常,需要通过try..catch捕获处理</p>
<p>try{<br>let result&#x3D;await p;</p>
<p>}catch(e){}</p>
<h4 id="es8对象方法扩展"><a href="#es8对象方法扩展" class="headerlink" title="es8对象方法扩展:"></a>es8对象方法扩展:</h4><p>const s&#x3D;{name:’1’,xueke:’2’};<br>获取对象所有的键名: Object.keys(s);<br>获取对象所有的值:Object.values(s);</p>
<p>Object.entries(school); 结果:一个数组每个元素都是键值对的形式 可以用来创建map<br>new Map(Object.entries(school))</p>
<p>Object.getOwnPropertyDescriptors(school)  对象属性的描述对象<br>也是一个对象，但属性值中还有 writable,enumerable,…</p>
<p>(<br>属性特性:<br>writable :是否可写<br>configurable:是否可删除<br>enumerable:是否可枚举</p>
<p>对象的克隆<br>const obj&#x3D;Object.create(null 原型对象,{<br>name：’尚硅谷’,<br>writable:true,<br>configurable:true,<br>enumerable：false<br>})</p>
<p>)</p>
<h4 id="es9正则扩展-命名捕获分组"><a href="#es9正则扩展-命名捕获分组" class="headerlink" title="es9正则扩展:命名捕获分组:"></a>es9正则扩展:命名捕获分组:</h4><p>举例:<br>let str&#x3D;’<a target="_blank" rel="noopener" href="http://www.atguigu.com">尚硅谷</a>‘<br>提取url和文本<br>用es5的写法是</p>
<p>const reg&#x3D;&#x2F;<a href="(.*)">(.*)</a>&#x2F;<br>const result&#x3D;reg.exec(str);</p>
<p>url：result[1];<br>文本:result[2];</p>
<p>es6的写法: 可以随意命名  在属性groups中出现别名和值<br>const reg&#x3D;&#x2F;<a href="(?<url>.*)">(?<text>.*)</a>&#x2F;<br>const result&#x3D;reg.exec(str);<br>console.log(result.groups.url)<br>console.log(result.groups.text)</p>
<h4 id="es9正则扩展-正向断言-反向断言"><a href="#es9正则扩展-正向断言-反向断言" class="headerlink" title="es9正则扩展:正向断言 反向断言 :"></a>es9正则扩展:正向断言 反向断言 :</h4><p>前瞻:<br>根据当前匹配的后边内容 来判断前面的内容是不是合法的</p>
<p>(reg.exec(str) 的作用是专门在正则中查找字符串中所有敏感词的内容和位置的函数。找到一个敏感词，就会返回一个数组)<br>如 动态提取 555<br>var str&#x3D;’123arg么555啦啦啦’<br>const reg&#x3D;&#x2F;\d+(?&#x3D;啦)&#x2F;</p>
<p>const result&#x3D;reg.exec(str); 这里\d+就是敏感词<br>console.log(result) </p>
<p>后瞻:<br>根据前面的内容做判断</p>
<p>var str&#x3D;’123arg555啦啦啦’<br>const reg&#x3D;&#x2F;(?&lt;&#x3D;么)\d+&#x2F;</p>
<p>const result&#x3D;reg.exec(str); 这里\d+就是敏感词<br>console.log(result) </p>
<h4 id="正则扩展-dotAll模式"><a href="#正则扩展-dotAll模式" class="headerlink" title="正则扩展:dotAll模式:"></a>正则扩展:dotAll模式:</h4><p>dot . 元字符 除换行符以外的任意单个字符</p>
<p>let str&#x3D;&#96;<br>&lt; ul&gt;<br>&lt; li&gt;<br>&lt; a&gt;肖生客&lt; &#x2F;a&gt;<br>&lt; p&gt;上映时间&lt; &#x2F;p&gt;<br>&lt;&#x2F; li&gt;</p>
<p>&lt; li&gt;<br>&lt; a&gt;肖生客&lt; &#x2F;a&gt;<br>&lt; p&gt;上映时间&lt; &#x2F;p&gt;<br>&lt;&#x2F; li&gt;<br>&lt; &#x2F;ul&gt;&#96;</p>
<p>匹配出<br>电影名称和时间</p>
<p>没有使用dotAll模式之前:</p>
<p>const  reg&#x3D;&#x2F;&lt; li&gt;\s+&lt; a&gt;(.*?)&lt; &#x2F;a&gt;\s+&lt; p&gt;\s+(.*？)&lt;&#x2F; li&gt;&#x2F;</p>
<p>const result&#x3D;reg.exec(str)；<br>console.log(result)</p>
<p>使用dotAll模式后  多了一个模式修正符s 有了这个模式以后  .就可以匹配任意字符 包括换行符<br>const  reg&#x3D;&#x2F;&lt; li&gt;.<em>?&lt; a&gt;(.</em>?)&lt; &#x2F;a&gt;\s+&lt; p&gt;.*?(.*？)&lt;&#x2F; li&gt;&#x2F;</p>
<h4 id="es10-对象的扩展方法-Object-fromEntries"><a href="#es10-对象的扩展方法-Object-fromEntries" class="headerlink" title="es10 对象的扩展方法 Object.fromEntries:"></a>es10 对象的扩展方法 Object.fromEntries:</h4><p>用来创建对象<br>参数为二维数组或map</p>
<p>const result&#x3D;Object.fromEntries([<br>[‘name’:’尚硅谷’],<br>[‘xueke’,’前端’]<br>])</p>
<p>const m&#x3D;new Map()</p>
<p>Object.fromEntries(m)</p>
<h4 id="es10"><a href="#es10" class="headerlink" title="es10:"></a>es10:</h4><p>let str&#x3D;’ arg ‘</p>
<p>str.trimStart()  清除左侧空格<br>str.trimEnd()  清楚右侧空格</p>
<h4 id="es10数组方法扩展"><a href="#es10数组方法扩展" class="headerlink" title="es10数组方法扩展:"></a>es10数组方法扩展:</h4><p>flat 将多维数组转换为低维数组<br>const arr&#x3D;[1,2,3,[4,5,6,[7,8]]];<br>arr.flat()  默认降低一个维度<br>arr.flat(2)  可以指定降低几个维度</p>
<p>flatMap  flat与map的结合<br>如果返回的结果是多维度数组  可以将他降低维度<br>var arr&#x3D;[2,3,4];<br>arr.flatMap(item&#x3D;&gt;[item*10])<br>结果还是一维数组</p>
<h4 id="es10：Symbol-prototype-description"><a href="#es10：Symbol-prototype-description" class="headerlink" title="es10：Symbol.prototype.description:"></a>es10：Symbol.prototype.description:</h4><p>var s&#x3D;Symbol(‘尚硅谷’)<br>s.description : 尚硅谷</p>
<h4 id="es11-私有属性"><a href="#es11-私有属性" class="headerlink" title="es11:私有属性:"></a>es11:私有属性:</h4><p>class Person{<br>公有属性<br>name；</p>
<p>私有属性(只能通过 调用类里面函数使用，在外部无法直接使用)<br>井号age;<br>井号weight;<br>constructor(name,age,weight){<br>this.name&#x3D;name;<br>this.井号age&#x3D;age;<br>this.井号weight&#x3D;weight;<br>}</p>
<p>intro(){<br>console.log(this.井号age)<br>}</p>
<p>}</p>
<p>var m&#x3D;new Person(1,2,3)<br>m.name 1<br>m.井号age 报错</p>
<h4 id="es11-Promise-allSettled"><a href="#es11-Promise-allSettled" class="headerlink" title="es11:Promise.allSettled"></a>es11:Promise.allSettled</h4><p>接受一个promise的数组作为参数<br>返回的结果状态永远都是成功的状态<br>值是里面每一个promise的状态与结果</p>
<p>Promise.allSettled([p1,p2]) （适用于每一个异步任务都想得到一个结果）</p>
<p>与之类似的   promise.all（适用于每一个异步任务都成功才会往下执行）<br>也是 接受一个promise的数组作为参数<br>但里面只要有一个promise失败，则返回的结果就是失败的，并且最后返回的值就是失败状态的promise的值<br>只有当所有成功，结果才成功，成功后的值，是所有promise成功的值组成的数组</p>
<h4 id="es11可选链子操作符"><a href="#es11可选链子操作符" class="headerlink" title="es11可选链子操作符:"></a>es11可选链子操作符:</h4><p>避免了做层层判断<br>function main(config){</p>
<p>原来是这样的  const s&#x3D;config&amp;&amp;config.db&amp;&amp;config.db.host</p>
<p>const s&#x3D;config?.db？.host  (?.判断前面的值有没有传入,如果传了就读取后面的db属性)</p>
<p>}</p>
<p>main({<br>db:{<br>host:1,<br>username:2</p>
<p>}</p>
<p>})</p>
<h4 id="es11：动态import-按需加载，懒加载"><a href="#es11：动态import-按需加载，懒加载" class="headerlink" title="es11：动态import()(按需加载，懒加载):"></a>es11：动态import()(按需加载，懒加载):</h4><p>等到用的时候再导入<br>import()  import函数的返回结果为一个promise对象  而这个promise对象成功的值就是暴露模块的对象</p>
<p>import(‘.&#x2F;1.js’).then(module&#x3D;&gt;{<br>module.hello();<br>})</p>
<h4 id="es11：BigInt："><a href="#es11：BigInt：" class="headerlink" title="es11：BigInt："></a>es11：BigInt：</h4><p>大整数类型<br>let a&#x3D;521n;  n表示大整形</p>
<p>let n&#x3D;123;<br>BigInt(n) 123n</p>
<p>用来进行大数值运算</p>
<p>let max&#x3D;Number.MAX_SAFE_INTEGER;<br>max+1<br>max+2 这里已经不能再大了 这里+2与+1是一样的</p>
<p>但可以<br>BigInt(max)+BigInt(1)<br>BigInt(max)+BigInt(2)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/22/ES6-11/" data-id="cl195kl600001fsno12xc3l88" data-title="ES6-11" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/03/25/vue2-0-3-0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          vue2.0+3.0
        
      </div>
    </a>
  
  
    <a href="/2022/03/17/ajax/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">ajax</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/25/vue2-0-3-0/">vue2.0+3.0</a>
          </li>
        
          <li>
            <a href="/2022/03/22/ES6-11/">ES6-11</a>
          </li>
        
          <li>
            <a href="/2022/03/17/ajax/">ajax</a>
          </li>
        
          <li>
            <a href="/2022/02/25/js2/">js2</a>
          </li>
        
          <li>
            <a href="/2022/02/25/%E8%AE%A1%E7%AE%97%E9%A2%98/">计算题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>