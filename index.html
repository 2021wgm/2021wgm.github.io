<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/25/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2022-02-25T12:24:11.000Z" itemprop="datePublished">2022-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/25/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="new-…-期间发生的事情"><a href="#new-…-期间发生的事情" class="headerlink" title="new …()期间发生的事情:"></a>new …()期间发生的事情:</h4><p>1 立刻创建一个新的对象<br>2 将新建的对象作为函数中的this<br>3 逐行执行函数中的代码<br>4 将新建立的对象作为返回值返回</p>
<h4 id="this指向"><a href="#this指向" class="headerlink" title="this指向:"></a>this指向:</h4><p>以函数的形式调用,this永远都是window<br>以方法的形式调用，this就是调用方法的那个对象<br>以构造函数的形式调用，this就指向被创建出来的那个对象<br>使用call与apply方法调用时.this是指定的那个对象</p>
<p>任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window<br>所有函数内部都有一个变量this，它的值是调用函数的当前对象</p>
<h4 id="null与undefined的区别"><a href="#null与undefined的区别" class="headerlink" title="null与undefined的区别:"></a>null与undefined的区别:</h4><p>undefined:定义了但没有赋值<br>null:定义了也赋值了，值就是null</p>
<h4 id="什么时候给变量赋值为null"><a href="#什么时候给变量赋值为null" class="headerlink" title="什么时候给变量赋值为null:"></a>什么时候给变量赋值为null:</h4><p>初始赋值，表明将要赋值为对象<br>结束前，让变量的指向的对象成为垃圾对象</p>
<p>什么是数据？数据的特点?什么是内存?什么是变量?内存分类?内存,数据,变量三者之间的关系?<br>存储在内存中代表特定的信息,本质上是0101..(二进制数)<br>可传递,可运算。<br>内存条通电后产生的可储存数据的空间(临时的)<br>可变化的量,由变量名和变量值组成,每个变量都对象一块小内存，变量名用来查找对象的内存，变量值就是内存中保存的数据<br>栈:全局变量和局部变量  堆:对象。<br>内存是用来存储数据的空间，变量时内存的标识。</p>
<h4 id="判断一个数是否是质数"><a href="#判断一个数是否是质数" class="headerlink" title="判断一个数是否是质数:"></a>判断一个数是否是质数:</h4><p>质数:只能被1和它自身整除的数，1不是质数也不是和数，质数必须是大于1的自然数。<br>var num&#x3D;prompt(“请输入一个数”);<br>var flag&#x3D;true;<br>if(num&lt;1){<br>alert(“请输入一个小于1的数”);<br>}else{<br>for(var i&#x3D;2;i&lt;num;i++){<br>&#x2F;&#x2F;优化:i&lt;&#x3D;Math.sqrt(num)  可以对一个数开方<br>if(num%i&#x3D;&#x3D;0){<br>flag&#x3D;false;  &#x2F;&#x2F;如果num能将一个数除断,就不是一个质数<br>&#x2F;&#x2F;优化：加一个break;减少时间<br>}<br>}<br>if(flag){<br>alert(num+”是一个质数”);&#x2F;&#x2F;说明上面的num%i一直都没有除断,所以flag为false一直没执行<br>}else{<br>alert(num+”不是一个质数”);<br>}</p>
<h4 id="js引擎如何管理内存"><a href="#js引擎如何管理内存" class="headerlink" title="js引擎如何管理内存:"></a>js引擎如何管理内存:</h4><p>分配小内存空间,得到它的使用权<br>存储数据，可以反复进行操作<br>释放当前的小内存空间</p>
<p>function fn（）{<br>var obj&#x3D;{};<br>}<br>fn();调用完后 obj是自动释放,而obj所指向的对象是在后面的某个时刻有垃圾回收器回收</p>
<h4 id="什么是对象-为什么要用对象-对象的组成？如何访问对象内部数据-什么时候必须使用-‘属性名’-："><a href="#什么是对象-为什么要用对象-对象的组成？如何访问对象内部数据-什么时候必须使用-‘属性名’-：" class="headerlink" title="什么是对象?为什么要用对象?对象的组成？如何访问对象内部数据?什么时候必须使用[‘属性名’]："></a>什么是对象?为什么要用对象?对象的组成？如何访问对象内部数据?什么时候必须使用[‘属性名’]：</h4><p>多个数据的封装体,用来保存多个数据的容器,一个对象代表现实中的一个事物。<br>统一管理多个数据。<br>属性:属性值(字符串)和属性值组成  方法：一种特别的属性<br>.属性名 (有时不能用)   [‘属性名’] 通用<br>1 属性名包含特殊字符,如 _ 空格 p.content-type&#x3D;… 不能用  p[“content-type”]&#x3D;… 可行，<br>2 变量名不确定<br>var propName&#x3D;’age’<br>var value&#x3D;18<br>p.propName&#x3D;value 不可行  直接属性名当成了propName<br>p[propName]&#x3D;value  （中括号里面的是变量）可行</p>
<h4 id="什么是函数-为什么要用函数-如何定义函数-如何调用函数"><a href="#什么是函数-为什么要用函数-如何定义函数-如何调用函数" class="headerlink" title="什么是函数?为什么要用函数?如何定义函数?如何调用函数?"></a>什么是函数?为什么要用函数?如何定义函数?如何调用函数?</h4><p>实现特定功能的n条语句的封装体<br>提高代码复用,便于阅读交流<br>函数声明或者表达式(function fn(){}    var f&#x3D;function(){})<br>test() 直接调用<br>obj.test() 通过对象调用<br>new test（）  new调用<br>test.call&#x2F;apply(obj) 临时让test成为obj的方法进行调用(可以让一个函数成为指定任意对象的方法进行调用)</p>
<p>什么函数才是回调函数?<br>自己定义的  我没有调用  但最终执行了  （如定时器,dom事件）</p>
<h4 id="关于加不加分号？"><a href="#关于加不加分号？" class="headerlink" title="关于加不加分号？"></a>关于加不加分号？</h4><p>js中一条语句的后面可以不加分号<br>有两种情况下必须加分号:<br>1 小括号开头的前一条语句<br>var a&#x3D;3<br>;(function(){…})()  或者在在3后面加上分号也是一样的</p>
<p>2 中方括号的前一条语句<br>var b&#x3D;5<br>;[1,2].forEach(function(){})</p>
<p>合并压缩(合并:将多个js文件合成一个js文件 压缩:把换行,注释能干掉的干掉，然后把变量名,函数名都换成a,b,c,d,..不重复的)</p>
<h4 id="instanceof是如何判断的"><a href="#instanceof是如何判断的" class="headerlink" title="instanceof是如何判断的"></a>instanceof是如何判断的</h4><p>A instanceof B   如果B函数的显示原型对象在A对象的原型链上,返回true,不然就返回false</p>
<h4 id="执行上下文："><a href="#执行上下文：" class="headerlink" title="执行上下文："></a>执行上下文：</h4><p>在执行全局代码前将window确定为全局执行上下文<br>对全局数据进行预处理:<br>var 定义的全局变量 &#x3D;&#x3D;&gt;undefined 并添加为window的属性<br>function声明的全局函数 添加为window的方法<br>this 赋值为window<br>开始执行全局代码</p>
<h4 id="产生过几次执行上下文对象"><a href="#产生过几次执行上下文对象" class="headerlink" title="产生过几次执行上下文对象:"></a>产生过几次执行上下文对象:</h4><p>函数 执行 的次数+1（window全局）</p>
<h4 id="产生过几个作用域"><a href="#产生过几个作用域" class="headerlink" title="产生过几个作用域:"></a>产生过几个作用域:</h4><p>函数 定义 的个数+1(window全局)</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化:"></a>优化:</h4><p>for(var i&#x3D;0;length&#x3D;btns.length;i&lt;length;i++){}<br>这里第二步  如果是 i&lt;btns.length btns.length每次都需要计算，放在前面则只需要计算一次</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包:"></a>闭包:</h4><p>产生的条件:<br>一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量时，并且执行外部函数</p>
<p>闭包是是什么:<br>嵌套的内部函数</p>
<p>常见的闭包:<br>1 将函数作为另外一个函数的返回值<br>function fn1(){<br>var a&#x3D;1;<br>function fn2(){<br>a++;<br>console.log(a);<br>}<br>return fn2;<br>}</p>
<p>这里执行fn1()后  fn1,fn2变量名 都被释放了,但fn2所对应的对象没有被释放，因为有f指向这个对象,如果没有var f&#x3D;,那么这个fn2所指向的对象也会称为垃圾对象，被释放<br>var f&#x3D;fn1();<br>f();2<br>f();3</p>
<p>2 将函数作为实参传给另外一个函数调用<br>function showDelay(msg,time){<br>setTimeout(function(){<br>msg();<br>},3000)</p>
<p>showDelay(function(){console.log(1)},3000）</p>
<p>3 自定义js模块<br>具有特定功能的js文件<br>将所有数据和功能都封装在一个函数内部(私有的)<br>只向外暴露一个包含n个方法的对象或函数<br>模块的使用者只需要通过模块暴露的对象调用方法来实现对应的功能<br>如 Mymodule.js中<br>function Mymodule(){<br>var msg&#x3D;”hello the earth”;<br>function doSomething(){<br>console.log(msg.toUpperCase());<br>}<br>function doOtherthing(){<br>console.log(msg.toLowerCase());<br>}<br>return {<br>doSomething:doSomething,（这里前面代表的只是字符串，后面是函数名）<br>doOtherthing:doOtherthing<br>}<br>}</p>
<p>上述还可以写成匿名函数自调用的形式，然后通过window向外暴露出来:<br>（ function Mymodule(window){<br>var msg&#x3D;”hello the earth”;<br>function doSomething(){<br>console.log(msg.toUpperCase());<br>}<br>function doOtherthing(){<br>console.log(msg.toLowerCase());<br>}<br>window.module&#x3D; {<br>doSomething:doSomething,（这里前面代表的只是字符串，后面是函数名）<br>doOtherthing:doOtherthing<br>}<br>})(window)</p>
<p>如果:实参，形参中添加了window ,能方便代码压缩，都换成a,b,c,d,..等单个字母</p>
<p>在引入这个文件的文件的js模块中:<br>var module&#x3D;Mymodule();<br>module.doSomething();<br>module.doOtherthing();</p>
<p>函数执行时出现过几次闭包:<br>取决于 外部 函数执行的次数</p>
<p>闭包的作用:<br>函数内部的变量在函数执行完成后，仍然存活在内存中(延长了局部变量的声明周期)<br>在函数外部可以操作到函数内部的数据</p>
<p>闭包的死亡:<br>嵌套的内部函数称为垃圾对象时<br>如上述案例中:<br>执行 f&#x3D;null;</p>
<p>缺点:<br>函数执行完后，函数内的局部变量没有被释放，占用内存时间会变长。<br>容易造成内存泄漏</p>
<p>解决:<br>能不用闭包就不用闭包<br>即使释放</p>
<h4 id="内存溢出与内存泄漏："><a href="#内存溢出与内存泄漏：" class="headerlink" title="内存溢出与内存泄漏："></a>内存溢出与内存泄漏：</h4><p>内存溢出:<br>一种程序运行出现的错误<br>当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出的错误<br>如:<br>var obj&#x3D;{};<br>for(var i&#x3D;0;i&lt;100000;i++){<br>obj[i]&#x3D;new Array[10000000];<br>}<br>浏览器会直接崩溃</p>
<p>内存泄漏:<br>占用的内存没有及时释放<br>内存泄漏积累多了就会导致内存溢出</p>
<p>常见的内存泄漏:<br>1 意外的全局变量：<br> 如: function fn(){<br>a&#x3D;new Array[100000];<br>}</p>
<p>2 没有及时清理的定时器或者回调函数<br>setInterval(function（）{<br>console.log(1);<br>},1000)</p>
<p>3 闭包</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/25/%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="cl0pe0c9y0005gono5hyj60r0" data-title="面试题" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/25/%E8%AE%A1%E7%AE%97%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2022-02-25T09:01:26.000Z" itemprop="datePublished">2022-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/25/%E8%AE%A1%E7%AE%97%E9%A2%98/">计算题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="去除数组中重复的数字"><a href="#去除数组中重复的数字" class="headerlink" title="去除数组中重复的数字:"></a>去除数组中重复的数字:</h4><p>for(var i&#x3D;0;i&lt;arr.length;i++){<br>for(var j&#x3D;i+1;j&lt;arr.length;j++){<br>if(arr[i]&#x3D;&#x3D;arr[j]){<br>arr.splice(j,1);<br>j–；此处防止出现 连续重复性数字造成漏检<br>}<br>}<br>}<br><br/></p>
<h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序:"></a>数组排序:</h4><p>arr.sort(function(a,b){<br>如果升序<br>if(a&gt;b){<br>return 1（a-b）;<br>}else if(a&lt;b){<br>return -1（a-b）;<br>}else{<br>return 0<br>}<br>如果降序:<br>if(a&gt;b){<br>return -1（b-a);<br>}else if(a&lt;b){<br>return 1（b-a）;<br>}else {<br>return 0;<br>}<br><br/></p>
<h4 id="判断一个数是否是质数"><a href="#判断一个数是否是质数" class="headerlink" title="判断一个数是否是质数:"></a>判断一个数是否是质数:</h4><p>质数:只能被1和它自身整除的数，1不是质数也不是和数，质数必须是大于1的自然数。<br>var num&#x3D;prompt(“请输入一个数”);<br>var flag&#x3D;true;<br>if(num&lt;1){<br>alert(“请输入一个小于1的数”);<br>}else{<br>for(var i&#x3D;2;i&lt;num;i++){<br>&#x2F;&#x2F;优化:i&lt;&#x3D;Math.sqrt(num)  可以对一个数开方<br>if(num%i&#x3D;&#x3D;0){<br>flag&#x3D;false;  &#x2F;&#x2F;如果num能将一个数除断,就不是一个质数<br>&#x2F;&#x2F;优化：加一个break;减少时间<br>}<br>}<br>if(flag){<br>alert(num+”是一个质数”);&#x2F;&#x2F;说明上面的num%i一直都没有除断,所以flag为false一直没执行<br>}else{<br>alert(num+”不是一个质数”);<br>}<br><br/></p>
<h4 id="将三个数按从小到大排列"><a href="#将三个数按从小到大排列" class="headerlink" title="将三个数按从小到大排列:"></a>将三个数按从小到大排列:</h4><p>注:prompt返回的是一个字符串<br>var num1&#x3D;+prompt(“请输入一个数”);<br>var num2&#x3D;+prompt(“请输入第二个数”);<br>var num3&#x3D;+prompt(“请输入第三个数”);<br>if(num1&lt;num2&amp;&amp;num1&lt;num3){<br>&#x2F;&#x2F;如果num1最小<br>if(num2&lt;num3)<br>alert(num1,num2,num3)<br>else alert(num1,num3,num2);<br>}</p>
<p>else if(num2&lt;num1&amp;&amp;num2&lt;num3){<br>&#x2F;&#x2F;如果num2最小<br>…<br>}</p>
<p>else{<br>&#x2F;&#x2F;num3最小<br>…<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/25/%E8%AE%A1%E7%AE%97%E9%A2%98/" data-id="cl0pe0c9x0004gonoai2rgkat" data-title="计算题" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JS核心" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/14/JS%E6%A0%B8%E5%BF%83/" class="article-date">
  <time class="dt-published" datetime="2022-02-14T10:40:51.000Z" itemprop="datePublished">2022-02-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/14/JS%E6%A0%B8%E5%BF%83/">JS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="JS编写的位置"><a href="#JS编写的位置" class="headerlink" title="JS编写的位置:"></a>JS编写的位置:</h4><p>可写在外部文件中，然后引入<br>script type&#x3D;”text&#x2F;javascript” src&#x3D;”js&#x2F;script.js”</p>
<p>也可以写在script  &#x2F;script</p>
<p>还可以 button onclick&#x3D;””<br><br/></p>
<h4 id="字面量与变量"><a href="#字面量与变量" class="headerlink" title="字面量与变量:"></a>字面量与变量:</h4><p>字面量都是一些不可改变的值 如 1，2，3</p>
<p>变量可以用来保存字面量，变量的值是可以任意改变的</p>
<p>声明变量  var a;<br><br/></p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符:"></a>标识符:</h4><p>js中所有可以由我们自主命名的都可以称为标识符</p>
<p>1 标识符可以含有 字母，数字，_,$,<br>2 标识符不能以数字开头<br>3 标识符不能是ES中的关键字(如:var,if)和保留字(如extend,class)<br>4 标识符一般采用驼峰命名法<br>  首字母小写，每个单词的开头字母大写，其余字母小写<br>如 helloworld<br>   helloWorld<br><br/></p>
<h4 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h4><p>数据类型指的就是字面量的类型<br>String 字符串<br>Number 数字<br>Boolean 布尔值<br>Null 空值<br>Undefined 未定义 6个基本<br>Symbol</p>
<p>Object 对象 一个引用</p>
<p>基本(值)类型:<br>string  number Boolean undefined null</p>
<p>对象(引用)类型:<br>Object:任意对象<br>Function:一种特别的对象(可以执行)<br>Array：一种特别的对象(数值下标,内部数据是有序的)</p>
<p>instanceof 判断对象的具体类型</p>
<p>typeof null ：  “object”<br>typeof undefined : “undefined”<br>typeof 函数名: “function”</p>
<p>typeof 可以判断： 数字 字符串 布尔值 undefined function<br>无法判断null和object object与array<br><br/></p>
<h4 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串:"></a>String字符串:</h4><p>JS中字符串需要用引号引起来<br>使用双引号或单引号都可以，但同种引号不要混着用<br>在字符串中可以使用\作为转义字符<br>&quot; 表示 “<br>&#39;表示’<br>\n表示换行<br>\表示<br><br/></p>
<h4 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型:"></a>Number类型:</h4><p>在JS中所有数值都是Number类型<br>包括整数和浮点数(小数)<br>JS中用来表示数字的最大值Number.MAX_VALUE<br>如果超过了最大值的大小则为Infinity字面量正无穷大,这个也是Number类型<br>NaN的类型也是Number,表示not a number不是一个数字<br>Number.MIN_VALUE表示0以上的最小值<br><br/></p>
<h4 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型:"></a>Boolean类型:</h4><p>值只有两个，主要用来逻辑判断<br>true 真<br>false 假<br><br/></p>
<h4 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined:"></a>null和undefined:</h4><p>null这个值专门用来表示一个空对象 typeof null 结果是 object<br>undefined 表示 声明一个变量，但是没有赋值 typeof undefined结果为undefined<br>null转成数字为0<br>undefined转成数字为NaN<br><br/></p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换:"></a>强制类型转换:</h4><p>将其他数据类型转换为String：<br>.toString()方法 不会影响原变量，但会将结果返回<br>null和undefined没有toString()方法，但可用下面的函数转换<br>调用String()函数</p>
<p>将其他数据类型转换为Number<br>转换方式一:<br>使用Number()函数<br>字符串转成数字:<br>1 如果是纯数字的字符串,则直接将其转换成数字<br>2 如果字符串中有非数字的内容，则直接转成NaN<br>3 如果字符串是空串或者里面全部都是空格，则转成0</p>
<p>布尔转成数字<br>true 1<br>false 0</p>
<p>null转成数字为0<br>undefined转成数字为NaN</p>
<p>转换方式二:<br>parseInt()函数 parseInt可以将一个字符串中的有效数字读取出来，然后转换成Number类型，但如果第一位就是非数字，name直接转为NaN<br>parseFloat()函数  parseFloat和parseInt类似，不同的是 parseFloat还可以获得有效的小数<br>对于非String类型使用parseInt或者parseFloat，会将其先转成字符串，然后再转成Number</p>
<p>将其他类型转成Boolean类型:<br>数字中：0和NaN转布尔都是false<br>字符串中:只有空串(“”)转布尔为false<br>null和undefined转布尔都为false<br><br/></p>
<h4 id="其他进制的数"><a href="#其他进制的数" class="headerlink" title="其他进制的数:"></a>其他进制的数:</h4><p>在js中，如果要表示16进制的数，需要以0x开头<br>var a&#x3D;0x10 结果为16<br>如果要表示8进制的数，需要以0开头<br>var a&#x3D;070 结果为56<br>如果要标识2进制的数，需要以0b开头<br>var a&#x3D;0b10 结果为 2<br>像var a&#x3D;”070”<br>parseInt(a);<br>这种字符串有的浏览器当成8进制，有的当成10进制度<br>解决方法:<br>parseInt(a,10)第一个表示参数，第二个表示进制<br><br/></p>
<h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符:"></a>算数运算符:</h4><p>+：对于非Number类型的进行计算，会将其转换为number类型，然后进行计算，并将结果返回。<br>任何值和NaN计算都为NaN(若是字符串相加除外)<br>任何一个值和字符串相加，都会将其先转换为字符串，然后进行拼串。<br>var a&#x3D;1;<br>a&#x3D;1+””;<br>结果为字符串1，这里是虽然是隐式转换，但过程中还是用到了 String（）函数</p>
<p>-,<em>,&#x2F;:<br>会将参与计算的值都转换为number类型，然后计算。<br>var a&#x3D;”1”;<br>a&#x3D;a-0;<br>a&#x3D;a</em>1;<br>a&#x3D;a&#x2F;1;<br>结果为Number类型的1,可以做隐式的类型转换。</p>
<p>%：取余。<br><br/></p>
<h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符:"></a>一元运算符:</h4><p>只需要一个操作数<br>var a&#x3D;1;<br>console.log(+a);1 没有影响</p>
<p>var a&#x3D;1;<br>console.log(-a);-1 有影响</p>
<p>都会将非number类型的值转换为Number类型，<br>var a&#x3D;false;<br>console.log(+a)；0；</p>
<p>可以用+a;来做隐式转换成number类型(原理和Number()函数一样)<br><br/></p>
<h4 id="自增与自减"><a href="#自增与自减" class="headerlink" title="自增与自减:"></a>自增与自减:</h4><p>var a&#x3D;1;<br>a++;此时 表达式 的值是1<br>console.log(a):这里变成2;<br>对于一个变量自增以后，原变量的值会立即增加1;<br>无论是a++,还是++a,都会立即让原来的变量值加1，区别是a++这个表达式的值是自增以前的值，<br>而++a这个表达式的值是自增以后的值。<br>var a&#x3D;20;<br>var a&#x3D;a++;<br>等价于 var e&#x3D;a++;<br>a&#x3D;e;<br>a的结果还是20;<br><br/></p>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符:"></a>逻辑运算符:</h4><p>! 非运算符:对一个布尔值进行取反操作，false变成true,true变成false,<br>不会改变原来变量的值，<br>var a&#x3D;true;<br>console.log(!a);false;<br>console.log(a);true;<br>对于非布尔值取反，会将其先转换为布尔值，然后取反。<br>可以取两次反，将一个非布尔类型的值转换为布尔类型的值，并且不改变原值<br>var a&#x3D;1;<br>a&#x3D;!!a;true;</p>
<p>&amp;&amp; 与运算符:<br>a&amp;&amp;b;<br>只有两个值都为true,结果才是true;<br>如果有一个值为false,结果就是false;<br>如果第一个值为false,则不会再看第二个值</p>
<p>|| 或运算符:<br>只有两个值都为false,才返回false<br>若需其中一个值为true,就会返回true<br>如果第一个值为true,则不会再去看第二值<br><br/></p>
<h4 id="非布尔值的与或运算"><a href="#非布尔值的与或运算" class="headerlink" title="非布尔值的与或运算:"></a>非布尔值的与或运算:</h4><p>会将其转换成布尔值，然后进行运算,并且返回原值。<br>2&amp;&amp;1  1<br>1&amp;&amp;2  2<br>如果两个值都为true,则返回后面的。<br>0&amp;&amp;2<br>flase&amp;&amp;true<br>返回 0<br>2&amp;&amp;0  0<br>NaN&amp;&amp;0  NaN<br>0&amp;&amp;NaN  0<br>如果两个值中有false,则返回靠前的false<br>如果第一个值为true,则必然返回第二个值<br>如果第一个值为false，则直接返回第一个值<br><br/><br>2||1 2 如果第一个值为true,则直接返回第一个值<br>NaN||1  1  如果第一个值为false,则直接返回第二个值<br><br/></p>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符:"></a>赋值运算符:</h4><p>&#x3D;:可以将符号右侧的值赋值给符号左侧的变量<br>a +&#x3D;5 等价于 a&#x3D;a+5<br>a -&#x3D;5 等价于 a&#x3D;a-5<br>a %&#x3D;5 等价于 a&#x3D;a%5<br><br/></p>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符:"></a>关系运算符:</h4><p>比较两个值的大小，如果成立返回true,不成立返回false<br>4&gt;5 false<br>5&gt;&#x3D;5(大于或者等于 满足其一就成立) true<br>1&gt;”0” true  对于非数字进行比较时，会将其转换为数字然后进行比较。<br>10&lt;&#x3D;”hello” 任何值和NaN做比较都是false<br>“11”&lt;”5” true 特殊情况:如果两边都是字符串，不会将其转成数字比较，而会分别比较字符串中的Unicode编码<br>“abc”&lt;”b” true 比较字符编码时是一位一位进行比较,第一位a比b小，后面就不看了<br>“bbc”&lt;”b” false  第一位两边一样，比较下一位，第二位 左边是b 右侧没有 左边大<br><br/></p>
<h4 id="Unicode编码表的使用"><a href="#Unicode编码表的使用" class="headerlink" title="Unicode编码表的使用:"></a>Unicode编码表的使用:</h4><p>在字符串中使用转义字符使用Unicode编码:console.log(“\u0054”);<br>在网页中使用Unicode编码:&amp;#编码 这里的编码需要的是10进制<br><br/></p>
<h4 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符:"></a>相等运算符:</h4><p>&#x3D;&#x3D;  比较两个值是否相等，相等则返回true,否则返回false<br>4&#x3D;&#x3D;5 false<br>“1”&#x3D;&#x3D;1 true  如果两边的类型不同，  大部分情况都会转换为数字<br>true&#x3D;&#x3D;”1”  true  左边布尔转数字 1  右侧字符串也转成数字1<br>null&#x3D;&#x3D;0 false  左边null没有转成数字<br>undefined&#x3D;&#x3D;null true undefined衍生于null<br>NaN&#x3D;&#x3D;NaN  false NaN不和任何值相等，包括它本身</p>
<p>检查一个值是否是NaN,如果是NaN返回true,否则返回false<br>isNaN(NaN) true<br>isNaN(1)   false<br>!&#x3D; 用来判断两个值是否不相等，不相等返回true 相等返回false</p>
<p>&#x3D;&#x3D;&#x3D; 全等 用来判断两个值是否全等 若两边值的类型不同，则直接返回false，不会自动做类型转换。<br>“123”&#x3D;&#x3D;123 false<br>“123”&#x3D;&#x3D;123 true<br>null&#x3D;&#x3D;&#x3D;undefined  false  null与undefined相等但不全等</p>
<p>！&#x3D;&#x3D; 不全等  如果两个值的类型不同，直接返回true<br>1!&#x3D;&#x3D;”1” true<br><br/></p>
<h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符:"></a>条件运算符:</h4><p>语法：<br>条件表达式？语句1:语句2;<br>首先对条件表达式进行求值,若为true，则执行语句1，并返回结果,否则执行语句2，并返回结果。<br>var a&#x3D;1,b&#x3D;2;<br>a&gt;b?alert(“a大”)：alert(“b大”);<br>获取 a和b中的最大值<br>var max&#x3D;a&gt;b?a:b;<br>获取abc中的最大值<br>max&#x3D;max&gt;c?max:c;<br>或者<br>max&#x3D;a&gt;b?(a&gt;max?a:c):(b&gt;c?b:c);<br>如果条件表达式的求值为一个非布尔值，则会将其转换为布尔值，<br>“”?alert(1):alert(2);2<br>“1”?alert(1):alert(2); 1</p>
<p>if(a&#x3D;10) 表示  if(10) 即 if(true)<br><br/></p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级:"></a>优先级:</h4><p>, 运算符  可用来同时声明多个变量<br>var a,b,c;<br>1+2*3  先乘除后加减<br>1||2&amp;&amp;3  1如果或的优先级高先算或，如果与的优先级高先算与，如果两个一样高，则按从左往右的顺序<br>这里  &amp;&amp;的优先级比||高<br>可以通过()改变优先级 (1||2)&amp;&amp;3  3<br><br/></p>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块:"></a>代码块:</h4><p>程序是一条一条语句构成的,<br>语句是按照自上向下的顺序一条一条执行的<br>同一个{}中的语句称为一组语句，他们要么都执行，要么都不执行<br>{<br>alert(0);<br>console.log(1);<br>}  这里与不加{}没有区别<br>一个{}中的语句也称为一个代码块<br>在代码块的后边就不用再编写;了<br>JS中的代码块{}只具有分组的作用，没有其他用途。<br>在代码块中的内容，在外部是完全可见的<br><br/></p>
<h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句:"></a>if语句:</h4><p>if(条件表达式)<br>语句<br>if语句在执行时 会先对条件表达式进行判断<br>如果为 true 则执行if后的语句，若为false 则不执行if后的语句。<br>var a&#x3D;10;<br>if(a&gt;10） if语句只能控制紧随其后的那个语句。<br>alert(1);<br>alert(2);这句还是会执行<br>如果希望if语句可以同时控制多条语句，可以将他们放在代码块{}中<br>if(a&gt;10){<br>alert(1);<br>alert(2);<br>}<br>if…else if…else  会从上到下依次对条件表达式进行求值判断,如果所有条件都不满足，则执行<br>最后一个else后的语句。<br>该语句中，只会有一个代码块被执行，一旦代码块执行了，则直接结束语句。<br>if(a&gt;10){<br>console.log（10）；<br>}else if(a&gt;5){<br>console.log(5);<br>}else if(a&gt;3){<br>console.log(3);<br>}else{<br>console.log(0);<br>}<br><br/></p>
<h4 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句:"></a>条件分支语句:</h4><p>switch(条件表达式){<br>case 表达式:<br>语句 …<br>break; 这三行可以有多个<br>default:<br>语句 …<br>break;<br>}</p>
<p>在执行时会依次将case后面的表达式的值和switch后面的表达式的值进行 全等 比较<br>如果比较的结果为true,则从当前case处开始执行代码，当前case后的代码都会执行<br>如果比较结果为false,则继续向下比较<br>使用break可以退出switch语句<br>如果所有的比较结果都为false,则只执行default后的语句</p>
<p>var a&#x3D;1;<br>switch(a){<br>case 1:<br>console.log(“1”);<br>break;<br>}<br><br/></p>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环:"></a>while循环:</h4><p>while(条件表达式){<br>}<br>先对条件表达式进行求值判断<br>如果值为true,则执行循环体<br>循环体执行完以后，继续对表达式进行判断<br>如果为true,则继续执行循环体，以此类推<br>如果值为false，则终止循环</p>
<p>while(true){  这个称为死循环<br>alert(n++)；<br>break;可以使用break终止循环<br>} </p>
<p>do…while循环<br>先执行循环体，判断，继续执行循环体，然后判断,以此类推。<br>如果结果为false,则终止循环。<br>do{<br>语句…<br>}while（条件表达式）</p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环:"></a>for循环:</h4><p>求水仙花数：<br>for(var i&#x3D;100;i&lt;1000;i++){<br>var bai&#x3D;parseInt(i&#x2F;100); &#x2F;&#x2F;获取百位上的数字<br>var shi&#x3D;parseInt((i-bi*100)&#x2F;10);&#x2F;&#x2F;获取十位上的数字<br>var ge&#x3D;i%10;<br>if(bai*bai*bai+shi*shi*shi+ge*ge*ge&#x3D;&#x3D;i){<br>console.log(i);<br>}<br>}<br><br/></p>
<p>嵌套联系:<br>for(var i&#x3D;0;i&lt;5;i++){&#x2F;&#x2F;控制行的个数<br>i值改变一次前，j值会该改变i次<br>for(var j&#x3D;0;j&lt;&#x3D;i;j++){&#x2F;&#x2F;控制每一行显示的个数<br>document.write(“*”);<br>}<br>document.write(“<br/>“);<br>}<br><br/></p>
<h4 id="break与continue"><a href="#break与continue" class="headerlink" title="break与continue:"></a>break与continue:</h4><p>break关键字只能又来退出switch或循环语句<br>不能在if语句中使用break和continue<br>break会终止离他最近的循环语句</p>
<p>可以在break后跟一个label（随便一个标签）,可以终止指定的循环<br>outer：<br>for(…){<br>for(…){<br>break outer;</p>
<p>continue可以用来跳过当次循环<br>continue默认只会对离他最近的循环起作用<br><br/></p>
<h4 id="测试程序执行的时间"><a href="#测试程序执行的时间" class="headerlink" title="测试程序执行的时间:"></a>测试程序执行的时间:</h4><p>程序执行前，开启计时器<br>console.time(“test”);text为计时器的名字<br>…<br>console.timeEnd(“test”);终止计时器<br><br/></p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象:"></a>对象:</h4><p>对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性<br>分类:<br>1 内建对象:由ES标准标准中定义的对象，在任何的ES的实现中都可以使用<br>例如:Math,String,Number,Boolean,Function,Object,…<br>2 宿主对象:由JS的运行环境提供的对象，主要指浏览器提供的对象<br>  比如 BOM,DOM<br>  console.log()中console<br>  document.write()中的document<br>3 自建对象；由开发人员自己建立的对象<br>var obj&#x3D;new Object() 使用new关键字调用的函数，是构造函数constructor，构造函数是专门用来创建对象的函数<br>使用typeof 检查一个对象时,会返回一个object<br>对象中保存的指称为属性<br>向对象添加属性<br>语法:对象.属性名&#x3D;属性值<br>obj.name&#x3D;”孙猴子<br>读取对象中的属性:对象.属性名 obj.name<br>如果读取对象中没有的属性，不会报错，而是返回undefined<br>修改对象的属性值: obj.name&#x3D;”八戒<br>删除对象的属性 delete obj.name;<br>如果要存入特殊的属性名，不能采用 . 的方式来操作,而应该这样<br>obj[“123”]&#x3D;”monkey”<br>取的时候也必须是 obj[“123”]</p>
<p>还可以  var n&#x3D;”123”<br>obj[n]的值还是一样(读取时还是obj[“123”])</p>
<p>in 运算符<br>通过该运算符可以检查一个对象中是否含有指定的属性<br>如果由返回true,没有则返回false<br>语法:”属性名” in 对象<br>“name” in obj   true<br>“test” in obj   false</p>
<p>对象的属性值也可以是个函数,这是函数可以认为是这个对象的方法<br>obj.sayName&#x3D;function(){}<br>obj.sayName()；调方法</p>
<p>function fun(){}<br>fun();调函数</p>
<p>var obj&#x3D;{<br>sayName:function（）{}<br>}</p>
<p>枚举对象中的属性:<br>for（var 变量 in 对象）{}<br>有多少属性，循环体就执行多少次</p>
<p>变量为每次执行的属性名字<br>对象[变量] 来取每次的属性值,而对象.变量的方式不能采取<br><br/></p>
<h4 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型:"></a>基本数据类型和引用数据类型:</h4><p>JS中的变量都是保存在栈内存中<br>基本数据类型的值直接在栈内存中存储<br>值与值之间是独立存在的，修改一个变量不会影响其他的变量<br>var a&#x3D;123;<br>var b&#x3D;a;<br>过程如下<br>在栈内存中<br>变量  值<br>a     123<br>b     123 （这里的123是直接复制上面的123）<br>然后a++<br>a 124<br>b  123 不会对a有任何影响</p>
<p>对象是保存在堆内存中的<br>var obj&#x3D; new Object()  出现new 意味着在堆中开辟了一个空间，用来存储对象<br>栈内存中<br>变量 值<br>obj  0x123 这里变量保存的是一个内存地址(对象引用) 这里相当于一个指针，执行了堆内存中指定的空间</p>
<p>堆内存中<br>一部分空间  地址为0x123..<br>obj.name&#x3D;”孙猴子” 此时在堆内存指定的空间里存入数据</p>
<p>var obj2&#x3D;obj;<br>栈内存中<br>obj  0x123…<br>obj2 ox123…(此时变量值 为 从上面复制过来的地址) 此时指向的是同一个对象</p>
<p>若 obj2&#x3D;null<br>此时obj2和堆中的对象链接断开了，但不会影响obj<br><br/></p>
<h4 id="对象字面量："><a href="#对象字面量：" class="headerlink" title="对象字面量："></a>对象字面量：</h4><p>使用对象字面量创建对象，可以直接指定对象中的属性<br>var obj&#x3D;{}<br>语法:{属性名:属性值,…}<br>对象字面量的属性名可以加引号，也可以不加，建议不加<br>但如果使用特殊的属性名，需要加上引号，如 {“!#$@#”：”00”}<br>如果一个属性之后没有其他的属性了，就不要加逗号了<br><br/></p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数:"></a>函数:</h4><p>函数也是一个对象<br>函数中可以封装一些功能代码,在需要时可以执行这些功能(代码)<br>创建一个函数对象<br>var fun&#x3D;new Function()<br>console.log(typeof fun)  “function”<br>可以将要封装的代码以字符串的形式传递给构造函数<br>var fun&#x3D;new Function(“console.log(‘你是八戒吗’)”)<br>封装到函数中的代码不会立即执行<br>调用函数的语法:<br>函数对象+()</p>
<p>也可以 使用函数声明来创建一个函数<br>语法:<br>function 函数名(形参1,形参2,…,形参N,){<br>语句…<br>}</p>
<p>还可以  使用函数表达式（匿名函数）来创建一个函数<br>var 函数名&#x3D;function(形参1,形参2,…形参N){};</p>
<p>var fun3&#x3D;function(){console.log(“你是一个函数”);};<br>使用return可以结束整个函数<br>返回值可以是任意的数据类型，可以是一个对象，也可以是一个函数<br><br/></p>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数:"></a>函数参数:</h4><p>可以在函数的()指定一个或多个形参(形式参数)<br>多个形参之间使用,隔开<br>声明形参就相当于在函数内部声明了对应的变量<br>function sum(a,b){}<br>相当于 function sum(a,b){var a;var b;}<br>在调用函数时,可以在()中指定实参(实际参数)<br>实参将会赋值给函数中对应的形参<br>sum(1,2）<br>相当于<br>function sum(a,b){var a&#x3D;1;var b&#x3D;2;}</p>
<p>调用函数时，解析器不会检查实参的类型，<br>所以要注意，是否有可能接收到非法的参数，如果有可能，需要对参数进行一个类型的检查<br>调用函数时，解析器也不会检查是实参的数量</p>
<p>多余实参不会被赋值<br>如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined<br>函数的实参可以是任何的数据类型</p>
<p>return 后的值将作为函数的执行结果返回<br>在函数中 return 语句之后的语句都不会执行<br>如果return 后面不跟任何值，就相当于返回了undefined<br>如果函数中不写return,也相当于返回了undefined</p>
<p>当参数过多时，可以将他们封装到一个对象中进行传递<br>实参可以是一个对象，也可以是一个函数<br>sum() 调用函数 相当于使用函数的返回值<br>sum 函数对象<br><br/></p>
<h4 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数:"></a>立即执行函数:</h4><p>也称为 匿名函数自调用，IIEF<br>函数定义完，立即被调用<br>立即执行函数往往只会执行一次<br>(function(a,b){<br>var a&#x3D;10;<br>}<br>)(1,2)<br>好处：<br>不会影响全局命名空间<br>隐藏内部实现<br><br/></p>
<h4 id="作用域："><a href="#作用域：" class="headerlink" title="作用域："></a>作用域：</h4><p>一个变量的作用范围<br>全局作用域:<br>直接编写在script标签里面的JS代码，都在全局作用域里面<br>全局作用域在页面打开时创建，在页面关闭时销毁<br>在全局作用域中有一个全局对象window,代表的是浏览器的窗口，由浏览器创建，是可以直接使用的<br>在全局作用域中，创建的变量都会作为window对象的属性保存<br>创建的函数都会作为window对象的方法保存<br>在全局作用域下,var a&#x3D;10相当于window.a&#x3D;10;<br>function fun(){}  相当于 window.fun&#x3D;function(){}<br>在全局作用域下的变量都称为全局变量，在页面的任意位置都可以访问的到</p>
<p>函数作用域:<br>调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁<br>每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的<br>在函数作用域中可以访问到全局作用域下的变量，但是在全局作用域中无法访问到函数作用域下的变量<br>当在函数作用域操作一个变量时，它会先在自身作用域查找，如果有就直接使用，如果没有，就向上一级作用域中查找，知道找到全局作用域<br>如果全局作用域中依然没有找到，则会报错<br>在函数中要访问全局变量可以使用window对象<br>函数作用域中也有声明提前的特性，使用var 关键字声明的变量，会在函数中所有代码执行之前被声明<br>函数声明也会在函数中所有代码执行之前执行<br>在函数中，不使用var声明的变量都都成为全局变量 相当于window.变量&#x3D;…<br>定义形参就相当于在函数作用域中声明了变量</p>
<p>内部可以看到外部(通过作用域链)，但外部看不到内部<br><br/></p>
<h4 id="声明提前"><a href="#声明提前" class="headerlink" title="声明提前:"></a>声明提前:</h4><p>使用var关键字声明的变量，会在所有的代码执行之前被声明<br>console.log(a);<br>var a&#x3D;10；undefined<br>上面2行等价于<br>var a;<br>console.log(a);<br>a&#x3D;10;<br>如果声明变量时不使用var关键字，则变量不会被声明提前。<br>console.log(a);<br>a&#x3D;10;报错</p>
<p>函数声明:<br>fun();<br>fun2();报错<br>function fun(){alert(1);} 函数声明会被提前创建<br>var fun2&#x3D;function(){}函数表达式不会被提前创建(这里只是把变量提前了，赋值操作没有提前)<br>上面4行相当于<br>function fun(){alert(1);}<br>var fun2;<br>fun();<br>fun2();<br>fun2&#x3D;function(）{};<br><br/></p>
<h4 id="关于this"><a href="#关于this" class="headerlink" title="关于this:"></a>关于this:</h4><p>解析器在调用函数时，每次都会向函数内部传递一个隐含的参数，这个隐含的参数就是this,this指向的是一个对象，这个对象被称为 函数执行的上下文对象，根据函数的调用方式不同，this会指向不同的对象<br>以函数的形式调用,this永远都是window<br>以方法的形式调用，this就是调用方法的那个对象<br>以构造函数的形式调用，this就指向被创建出来的那个对象<br>使用call与apply方法调用时.this是指定的那个对象<br><br/></p>
<h4 id="使用工厂模式创建对象"><a href="#使用工厂模式创建对象" class="headerlink" title="使用工厂模式创建对象:"></a>使用工厂模式创建对象:</h4><p>返回一个对象的函数<br>通过该方法可以大批量的创建对象，节省代码<br>使用工厂模式创建的对象，使用的构造函数都是Object<br>所以创建的对象都是Object这个类型，就导致无法区分多种不同类型的对象<br>function createPerson(name,age){<br>var obj&#x3D;new Object();<br>obj.name&#x3D;name;<br>obj.age&#x3D;age;<br>return obj;<br>}</p>
<p>var obj1&#x3D;createPerson(…);<br>var obj2&#x3D;createPerson(…);</p>
<p>obj1 instanceof Object：true<br>obj1 instanceof Object： true<br><br/></p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数:"></a>构造函数:</h4><p>构造函数就是一个普通的函数，创建方式与普通函数没有区别<br>不同的是构造函数首字母大写</p>
<p>构造函数与普通函数的区别就是调用方式的不同<br>普通函数是直接调用，构造函数需要使用new关键字调用</p>
<p>构造函数的执行流程(即 new …()期间发生的事情)<br>1 立刻创建一个新的对象<br>2 将新建的对象作为函数中的this<br>3 逐行执行函数中的代码<br>4 将新建立的对象作为返回值返回</p>
<p>使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类<br>通常将通过一个构造函数创建的对象，称为是该类的实例</p>
<p>可以使用instanceof检查一个对象是否是一个类的实例,如果是，返回true,否则返回false<br>var per&#x3D;new Person();<br>per instanceof Person<br>所有的对象都是Object的后代，所以任何对象和instanceof做检查都会返回true</p>
<p>构造函数每执行一次就会创建一个新的对象，但是方法都是一样的，浪费资源，应该让所有对象共享一个方法<br>function Person(){<br>this.sayName&#x3D;function（）{}<br>}<br>var per1&#x3D;new Person();<br>var per2&#x3D;new Person();<br>per1.sayName&#x3D;&#x3D;per2.sayName;false</p>
<p>将上面改成<br>function Person(){<br>this.sayName&#x3D;fun;<br>}<br>function fun(){<br>alert(1);<br>}<br>将函数定义在全局作用域里面，污染了全局作用域的命名空间(可能其他人也不知道，起了相同的名字，于是这个就被覆盖掉了)<br><br/></p>
<h4 id="自定义构造函数-原型的组合模式："><a href="#自定义构造函数-原型的组合模式：" class="headerlink" title="自定义构造函数+原型的组合模式："></a>自定义构造函数+原型的组合模式：</h4><p>套路:自定义构造函数，属性在函数中初始化,方法添加到原型链上<br>使用场景:需要创建多个类型确定的对象<br>如： function Person(name,age){<br>this.name&#x3D;name;<br>this.age&#x3D;age;<br>}<br>Person.prototype.setName&#x3D;function(name){<br>this.name&#x3D;name;这里的this是指向实例对象<br>}</p>
<p>var person1&#x3D;new Person（）;<br>person1 instanceof Person :true<br>var person2&#x3D;new Person(); </p>
<p>如果把方法写在构造函数里面，那么person1,person2的方法是不同的，会造成浪费内存，而放在原型链上，则2个对象的方法是同一个</p>
<p>function  Animal(){…}<br>var animal1&#x3D;new animal();<br>animal1 instanceof animal:true</p>
<h4 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象:"></a>原型对象:</h4><p>原型prototype：<br>我们所创建的每一个属性，解析器都会向函数中添加一个属性prototype,这个属性(保存了一个地址)对应着一个对象，这个对象就是所谓的原型对象（默认是一个object的空对象）(如：空间地址为0x123)。<br>原型对象有一个属性constructor，它指向函数对象<br>如果函数作为作为普通函数调用,那么prototype没有任何作用。<br>当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，即 创建出来的那个对象的__proto__属性也是保存了一个地址，指向了同一个空间。<br>也就是 对象.<strong>proto</strong>&#x3D;&#x3D;函数.prototype<br>原型对象就像一个公共区域，所有同一个类的实例都可以访问到这个原型对象<br>可以将对象中公有的内容都设置在原型对象中<br>向MyClass构造函数中添加属性a（这个是在公共区间中存入a,并不是单个的实例中存入）<br>MyClass.a&#x3D;….</p>
<p>当我们访问对象的一个属性或者方法时，它会现在对象自身中查找，如果有则直接使用，如果没有，则会去原型对象中寻找,如果找到则直接使用。</p>
<p>向原型中添加方法<br>MyClass.prototype.sayName&#x3D;function(){} 这样既是公共的方法，也不会污染全局作用域的命名空间<br>使用 in 检查对象中有没有某个属性时，如果对象中没有，但原型中有，也会返回true<br>可以使用对象中的hasOwnProperty来检查 对象自身 有没有该属性<br>像  实例.<strong>proto</strong>.hasOwnProperty(“hasOwnProerty”):false</p>
<p>原型对象也是对象，它也有原型，如果原型中没有，则去原型对象的原型中寻找，也就是<br>函数名.prototype.__proto__或者是实例.<strong>proto</strong>.<strong>proto</strong></p>
<p>上面这个属性是在原型的原型中<br>而原型的原型的原型(3个)是指向空,即<br>函数名.prototype.<strong>proto</strong>.<strong>proto</strong>&#x3D;null<br>实例.<strong>proto</strong>.<strong>proto</strong>.<strong>proto</strong>&#x3D;null</p>
<p>原型对象也是对象，它也有原型，如果原型中没有，则去原型对象的原型中寻找，也就是<br>函数名.prototype.__proto__或者是实例.<strong>proto</strong>.<strong>proto</strong>,<br>如果原型的原型中也没有，则知道找到Object对象（所有对象的祖先,也就是原型的原型）的原型<br>Object对象的原型(即原型的原型 的原型)没有原型，如果在Object中依然没有找到，则返回undefined</p>
<p>原型对象(0x123)<br>a           100<br><strong>proto</strong>   0x124(这个指向下面,如果上面没有找到对象的属性，就去这个指向空间里找)</p>
<p>原型对象的原型对象<br><strong>proto</strong><br>object的原型对象的隐式原型为null,所以object的原型对象是原型链的尽头<br>实例才有隐式原型 <strong>proto</strong><br>函数只有显示原型  prototype<br>Function.prototype是一个实例<br><br/></p>
<h4 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法:"></a>toString方法:</h4><p>当我们直接在页面中打印出一个对象时，实际上是输出对象的toString()方法的返回值<br>如果希望在输出对象时不输出[object Object],可以为对象添加一个toString方法<br>对象.toString&#x3D;function(){}<br>但这样只能改变一个实例<br>应该  构造函数名.prototype.toString&#x3D;function（）{} 添加一个方法<br><br/></p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收:"></a>垃圾回收:</h4><p>var obj&#x3D;new Object();<br>这里开辟了一个内存空间<br>obj这个变量保存了这个空间的引用地址<br>但当执行  obj&#x3D;null时<br>这个变量和这个空间的链接就断开了<br>那么这个空间不被任何变量所指向，也就成垃圾了<br>这种对象过多会占用大量的内存空间，导致程序运行变慢<br>在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁<br>我们不需要也不能进行垃圾回收的操作</p>
<p>如果需要回收 就执行null操作，让浏览器自动将这些垃圾对象销毁<br><br/></p>
<h4 id="数组简介"><a href="#数组简介" class="headerlink" title="数组简介:"></a>数组简介:</h4><p>数组也是对象<br>和普通对象功能类似，也是用来存储一些值的<br>不同的是，普通对象是使用字符串作为属性值，而数组是使用数字作为索引来操作元素<br>索引:从0开始的整数<br>创建数组对象: var obj&#x3D;new Array();<br>使用typeof检查一个数组时，会返回object<br>向数组中添加元素:数组[索引]&#x3D;值<br>如果读取不存在的值，不会报错，而是返回undefined</p>
<p>获取数组的长度 数组.length<br>对于非连续的数组,使用length会获取到数组的最大索引+1<br>尽量不要创建非连续的数组<br>如果修改的lenth大于原长度，则多出部分会空出来<br>如果修改的length小于原长度，则多出的元素会被删除<br>向数组的最后一个位置添加元素 arr[arr.length]&#x3D;…</p>
<p>存值还可以 arr.hello&#x3D;”hello” 但没有意义<br>还可以使用字面量创建数组<br>var arr&#x3D;[];<br>使用构造函数创建数组时，也可以同时添加元素，元素之间用,隔开<br>new Array(10,20,30);</p>
<p>arr&#x3D;[10];表示只用一个元素，这个元素内容为10<br>new Array(10) 表示数组的长度为10,10个元素的内容暂时为空</p>
<p>arr.push(1,2,3)向数组中添加新的元素，这些元素将自动添加到数组的末尾，并返回新的长度<br>arr.pop()删除数组的最后一个元素，并将删除的值作为返回值<br>arr.unshift() 向数组的开头添加一个或者多个元素，并且返回新的数组长度，向前面插入元素以后，后面的元素的索引会依次改变<br>arr.shift() 删除数组的第一个元素，并将删除掉的元素作为返回值</p>
<p>forEach方法需要一个函数作为参数,像这种函数，由我们创建但不由我们调用的（由浏览器自己调用的），称为回调函数。<br>数组中有几个元素，这个函数就会执行几次<br>浏览器会在回调函数中传递三个参数，a为正在遍历的元素，b为正在遍历的元素的索引，第三个参数就是正在遍历的数组<br>arr.forEach(function(a,b,c){<br>})</p>
<p>arr.slice(a,b)可以用来从数组中提取指定元素,a为起始位置 b为末端位置，但截取的内容不包括末端的那个元素<br>该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回</p>
<p>arr.slice(a) 截取从索引a开始以后的所有元素，索引可以传递一个负值,如-1就是倒数第一个</p>
<p>arr.splice(m,n)可以用来删除数组中的指定元素 m起始，n表示删除的数量，并将被删除的元素作为返回值返回<br>arr.splice(m,n,k)第三个元素及以后，这些元素将替换掉之前被删掉的元素<br>如果n为0，则表示不删，那么k代表的元素还是将插入到开始的位置(级索引m的前面)的前面</p>
<p>arr.concat(arr2) 连接两个或者多个数组(也可以是元素)，并将新数组返回，该方法不会对原数组产生影响</p>
<p>arr.join()该方法可以将一个数组转换为字符串，<br>该方法不会改变原数组，而是将转换后得到的字符串作为结果返回<br>还可以指定一个字符串作为参数，该字符串会作为元素之间的连接符<br>如果不适用连接符，默认会使用,作为连接符<br>如果连，也不想要，可以指定空字符串 “”</p>
<p>arr.reverse() 会翻转数组 前后颠倒过来<br>会改变原数组</p>
<p>arr.sort()  对数组进行排序<br>会改变原数组 默认会按照unicode编码来进行排序<br>即使对于纯数字的数组，也会按照unicode编码来进行排序，所以对数字进行排序时，可能会得到错误的结果<br>也可以自己来指定排序的规则<br>可以在sort()中放一个回调函数来指定排序规则<br>a，b代表数组中的连续的某两个元素<br>并且a代表的元素的位置一定在b代表的元素的前面<br>浏览器会根据元素的返回值来决定元素是否会交换位置<br>如果大于0 元素会交换位置<br>如果小于0 元素不变<br>如果等于0 则认为两个元素相等，也不交换位置<br>arr.sort(function(a,b){<br>如果升序<br>if(a&gt;b){<br>return 1;<br>}else if(a&lt;b){<br>return -1;<br>}else{<br>return 0<br>}<br>如果降序:<br>if(a&gt;b){<br>return -1;<br>}else if(a&lt;b){<br>return 1;<br>}else {<br>return 0;<br>}</p>
<p>})<br><br/></p>
<h4 id="call与apply"><a href="#call与apply" class="headerlink" title="call与apply:"></a>call与apply:</h4><p>这两个方法都是函数对象的方法，需要通过函数对象来调用<br>当函数调用call()和apply()都会让函数执行<br>可以将一个对象指定为第一个参数，这个对象将成为函数执行时的this<br>call方法中实参是在对象之后(第一个参数以后)依次传递<br>fun.call(obj,1,2)<br>apply方法中实参在对象之后需要以数组的形式传递<br>apply(obj,[1,2])<br><br/></p>
<h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments:"></a>arguments:</h4><p>当调用函数时，浏览器每次都会传递进两个隐含的参数:<br>1 函数的上下文对象this<br>2 封装实参的对象arguments<br>arguments是一个类数组对象，可以通过索引来操作数据<br>当调用函数时，所用的实参都会在arguments中保存<br>arguments.length可以获取实参的长度<br>arguments.callee这个属性对应一个函数对象，就是当前正在执行的函数的对象<br><br/></p>
<h4 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象:"></a>Date对象:</h4><p>在JS中使用Date对象来表示一个时间<br>如果直接使用构造函数创建一个Date对象，则会封装成当前代码执行的时间<br>var d&#x3D;new Date()<br>创建一个指定的时间对象:需要在构造函数中传递一个表示时间的字符串作为参数<br>日期的格式:月&#x2F;日&#x2F;年 时:分:秒<br>new Date(“12&#x2F;03&#x2F;2016 11:10:13”);<br>d.getDate() 获取当前日期是几号<br>d.getDay()  获取当前日期是星期几 会返回一个0-6的值，0表示周日，1表示周一<br>d.getMonth() 获取当前时间的月份 0-11的值 0表示1月 1表示2月  11表示12月<br>d.getFullYear() 获取当前日期对象的年份<br>d.getTime() 获取当前日期对象的时间戳<br>时间戳：从格林威治标准时间的1970年1月1日 0时0分0秒到当前日期所花费的毫秒数(1s&#x3D;1000ms<br>)<br>计算机底层在保存时间时使用的都是时间戳<br>Date.now() 获取当前代码执行时的时间戳<br>可以利用时间戳来测试代码执行的性能<br><br/></p>
<h4 id="Math"><a href="#Math" class="headerlink" title="Math:"></a>Math:</h4><p>不是构造函数<br>里面封装了数学相关计算的一些属性和方法<br>Math.PI 圆周率 常量<br>Math.abs() 计算一个数的绝对值<br>Math.ceil() 可以对一个数进行向上取整，小数位只要有值就会向上进1<br>Math.floor() 可以对一个数进行向下取整，小数部分会被省掉<br>Math.round() 四舍五入取整<br>Math.random() 可以生成一个0到1之间的随机数 不包括0和1<br>若要随机出现0到10(包括0和10)的数<br>Math.round(Math.random()*10)<br>若要生成0到x之间的随机数<br>Math.round(Math.random()*x)<br>若要生成1到10的数<br>Math.round(Math.random()*9+1)</p>
<p>生成一个x到y之间的随机数:<br>Math.round(Math.random()*(y-x)+x)</p>
<p>Math.max(1,10,5) 可以获取多个数中的最大值<br>Math.min()  可以获取多个数中的最小值</p>
<p>Math.pow(2,2) 4 可以获取一个数的几次方<br>Math.sqrt(4) 2 可以对一个数进行开方<br><br/></p>
<h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类:"></a>包装类:</h4><p>主要是给浏览器自己用的<br>String() Number() Boolean()<br>通过包装类可以将基本数据类型转化为对象<br>var a&#x3D;new Number(1)<br>new String(“123”)<br>new Boolean(true)<br>用typeof 检测后都是object</p>
<p>转换为对象后有一个好处，可以添加属性<br>a.hello&#x3D;”123”;</p>
<p>当我们对一些基本数据类型调用一些属性和方法时,浏览器会临时使用一些包装类将其转换为对象，然后再调用对象的属性和方法，调用完以后，再将其转换为基本数据类型<br>所以<br>var s&#x3D;123;<br>s&#x3D;s.toString();<br>s.hello&#x3D;”你好”; 这里是添加到临时的对象里了，添加完后，这个对象就销毁了<br>console.log(s.hello) undefined  </p>
<p>上面一共转换了两次对象<br>s.toString()1次<br>s.hello 1次  但这两个不是同一个<br>这上面两个都是临时转换为对象，然后被销毁<br><br/></p>
<h4 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法:"></a>字符串的方法:</h4><p>var str&#x3D;”hello”<br>在底层 字符是以字符数组的形式保存的<br>[‘h’,’e’,’l’]<br>str.charAt(0) h 可以返回字符串中指定位置的字符<br>str.charCodeAt(1) 获取指定位置的字符的字符编码（uniCode编码）</p>
<p>String.fromCharCode(72)  可以根据字符编码去获取字符 ‘H’<br>str.concat(“你好”,”再见”) 可以用来链接两个或多个字符串<br>str.indexOf(“h”) 可以用来检查一个字符串中含有指定内容，如果有，则胡返回其出现的第一次的索引，如果没有找到指定的内容，则返回-1<br>str.indexOf(“h”,1) 可以指定第二个参数，指定开始查找的位置，返回的还是索引<br>str.lastIndexOf(“h”) 从后往前面找<br>str.lastIndexOf(“h”，5) 也可以指定位置</p>
<p>str.slice(1,2)  可以从字符串中截取指定的内容，不会影响原字符串，而是将截取到的内容返回<br>参1: 开始位置的索引，包括开始的位置<br>参2:结束位置的索引，不包括结束位置</p>
<p>如果省略第二个，则会截取到开始位置以后所有的<br>str.slice(1,-1) -1表示倒数第一个，截取原则还是不变</p>
<p>str.substring()  可以用来截取一个字符串，和slice类似<br>参1 :开始截取位置的索引，包括开始位置<br>参2:结束位置的索引，不包括结束位置<br>不同的是 这个不能接收负值作为参数<br>如果是负值，则默认使用0，并且如果第二个参数小于第一个，还会互换位置</p>
<p>str.substr() 截取指定位置的内容<br>参1:开始位置的索引<br>参2:截取的数量</p>
<p>str.split()<br>可以将一个字符串拆分成一个数组<br>参数:需要一个字符串作为参数，将会根据这个字符串去拆分成数组<br>如果传递一个空串作为参数表，则会将每个字符拆分成数组中的一个元素<br>var str&#x3D;”abc,def,g”<br>str.split(“,”);[“abc”,”def”,”g”]<br>str.split(“d”) [“abc,”,”ef,g”]</p>
<p>str.toUpperCase() 将一个字符串转换为大写并返回<br>str.toLowerCase() 将一个字符串转换为小写并返回<br><br/></p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式:"></a>正则表达式:</h4><p>用来定义一些字符串的规则<br>创建正则表达式的对象<br>var reg&#x3D;new RegExp(“正则表达式”,”匹配模式”);</p>
<p>只要字符串中有a,严格区分大小写,就返回true<br>var reg&#x3D;new RegExp(“a”); reg： &#x2F;a&#x2F;</p>
<p>在构造函数中可以传递一个匹配模式作为第二个参数<br>可以是:<br>i 忽略大小写<br>g 全局匹配模式</p>
<p>var reg&#x3D;new RegExp(“a”,”i”)</p>
<p>var str&#x3D;”a”;<br>test（）  用来检测一个字符串是否符合正则表达式的规则，符合就返回true,反之则返回false<br>reg.test(str); 使用reg这个规则去测试str这个字符串</p>
<p>使用字面量来创建正则表达式<br>var 变量&#x3D;&#x2F;正则表达式&#x2F;匹配模式<br>var reg&#x3D;&#x2F;a&#x2F;i  和上面是一样的</p>
<p>使用|表示或者的意思<br>reg&#x3D;&#x2F;a|b&#x2F; 有其中一个就会返回true</p>
<p>[]也是或的关系<br>reg&#x3D;&#x2F;[ab]&#x2F;<br>优势 &#x2F;[a-b]&#x2F; 表示任意小写字母 [A-B] 任意大写字母 [A-z] 任意字母</p>
<p>reg&#x3D;&#x2F;a[bde]c&#x2F; 表示是否含有 abc或者adc或者aec</p>
<p>[^] 除了<br>reg&#x3D;&#x2F;[^ab]&#x2F; 字符串中如果有ab之外的字符就返回true,如果没有则返回false</p>
<p>[0-9] 任意的数字</p>
<p>split() 可以传递一个正则表达式作为参数，默认是全局匹配<br>var str&#x3D;”1a2b3c4D5”<br>var reg&#x3D;&#x2F;A-z&#x2F;<br>str&#x3D;str.split(reg) [“1”,”2”,”3”,”4”,”5”]</p>
<p>search()可以指定字符串中是否含有指定内容,如果搜索到指定内容，会返回第一个字母的索引，如果没有则返回-1,还可以接收一个正则表达式作为参数，根据这个来检索字符串<br>默认只会查找第一个<br>str.search(“abc”)<br>str.search(&#x2F;a[bef]c&#x2F;)</p>
<p>match()  可以根据正则表达式，将符合条件的内容找出来，默认情况下，只会找到第一个符合条件的内容，找到以后就停止检索，match还会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果<br>需要设置匹配模式为全局，才会将所有内容取出来<br>str.match(&#x2F;[A-z]&#x2F;);<br>str.match(&#x2F;a-z&#x2F;gi)</p>
<p>replace()  可以将字符串中指定的内容替换为新的内容,默认只会替换第一个<br>参数1 ：被替换的内容 可以接收一个正则表达式作为参数<br>参数2：  新的内容<br>str.replace(“a”,”@<em>@”)<br>str.replace(&#x2F;a&#x2F;g,”@</em>@”)<br>str.replace(&#x2F;[A-z]&#x2F;g,””) 直接删除字母</p>
<p>量词:可以设置一个内容出现的次数<br>{n}：正好出现n次<br>var str&#x3D;&#x2F;a{3}&#x2F;<br>量词只对前面的一个内容其作用<br>&#x2F;ab{3}&#x2F;  指的是  abbb<br>但可以这样 &#x2F;(ab){3}&#x2F;  这就表示 ababab<br>{m,n} 可以出现m到n次<br>{m,}  出现m次及以上<br>&#x2F;ab{1,3}c&#x2F; b可以出现1到3次</p>
<p>加号代表 至少一个  &gt;&#x3D;1<br>&#x2F;ab+c&#x2F;<br>星号代表0个或多个<br>&#x2F;ab*c&#x2F;<br>问号代表0个或1个<br>&#x2F;ab?c&#x2F;</p>
<p>^ 以什么开头<br>&#x2F;^a&#x2F;<br>$ 以什么结尾<br>&#x2F;a$&#x2F;</p>
<p>&#x2F;^a$&#x2F;  开头又结束代表只能有一个a</p>
<p>&#x2F;.&#x2F; 表示任意字符，除了换行和结束符</p>
<p>在正则表达式中可以使用\表示转义字符<br>&#x2F;.&#x2F;  表示.</p>
<p>reg&#x3D;/&#x2F;\ 表示一个\</p>
<p>reg.test(“b.\“)  true  这里字符串中的\也转义了，实际上是一个\ （\在字符串中也是一个转义字符）</p>
<p>\w：任意字母,数字,_ [A-z0-9_]<br>\W：除了 字母，数字,_ [^A-z0-9_]<br>\d：任意的数字 [0-9]<br>\D：除了数字<br>\s：空格<br>\S:除了空格</p>
<p>\b：单词边界<br>&#x2F;\bchild\b&#x2F;  表示child为一个独立的单词 前面和后面一个位置都有空格 或后面什么都没有<br>\B：除了单词边界</p>
<p>去除字符串中的空格<br>str&#x3D;str.replace(&#x2F;\s&#x2F;g,”_”)</p>
<p>去除开头的空格<br>str&#x3D;str.replace（&#x2F;^\s*&#x2F;，” “）<br>去除结尾的空格<br>str&#x3D;str.replace(&#x2F;\s*$&#x2F;,” “)<br>去除开头和结束的空格<br>str&#x3D;str.replace(&#x2F;^\s*|\s*$&#x2F;g,” “)<br><br/></p>
<h4 id="文档的加载"><a href="#文档的加载" class="headerlink" title="文档的加载:"></a>文档的加载:</h4><p>浏览器在加载一个页面时，是按照自上向下的顺序加载的，读取到一行就运行一行<br>如果将script标签写在页面的上面,代码执行时，页面还没有加载<br>onload事件会在整个页面加载完成之后触发<br>window.onload&#x3D;function(){} 这个可以确保当代码执行时所有dom对象已经加载完毕<br><br/></p>
<h4 id="dom查询"><a href="#dom查询" class="headerlink" title="dom查询:"></a>dom查询:</h4><p>下面五个通过 document对象(在整个页面查询)调用<br>getElementById() 通过id获取一个元素节点对象</p>
<p>getElementsByTagName() 通过标签名获取一组元素节点对象</p>
<p>getElementsByName() 通过name属性获取一组元素节点对象</p>
<p>getElementsByClassName()  通过class属性获取一组元素节点对象</p>
<p>querySelector(“.box1&gt;div1”) 里面放css选择器</p>
<p>querySelectorAll(“”)</p>
<p>元素.id 元素.name 元素.value<br>读取class时:元素.className<br>s<br>下面四个通过具体的元素（在指定的元素中查询）节点调用</p>
<p>方法:getElementsByTagName() </p>
<p>属性:childNodes  当前节点的所有子节点(包含文本节点（空格）， 元素节点)</p>
<p>属性:firstNode  当前节点的第一个子节点</p>
<p>属性:lastChild  当前节点的最后一个子节点</p>
<p>属性:children  获取当前元素的所有子元素</p>
<p>属性:firstElementChild 获取当前元素的第一个子元素</p>
<p>属性:parentNode 获取当前节点的父节点</p>
<p>属性:previosSibling 表示当前节点的前一个兄弟节点</p>
<p>属性:previosElementSibling 表示当前节点的前一个兄弟元素节点</p>
<p>属性:nextSibling  表示当前节点的后一个兄弟节点</p>
<p>属性:innerHTML  可以获取到元素内部的文本内容</p>
<p>属性:innerText  同上,但获取不到标签元素</p>
<p>属性：nodeValue 获取节点内容</p>
<p>获取body：document.body<br>或者  document.getElementsByTagName(“body”)[0]</p>
<p>获取html根标签:document.documentElement</p>
<p>获取页面中所有的元素: document.all<br>或者  document.getElementsByTagName(“*”）<br><br/><br>dom的增删改<br> document.createElement(“li”)  创建一个元素节点对象，需要一个标签名作为参数，并根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回<br> document.createTextNode(“你是啥子”) 创建文本节点对象</p>
<p>父元素.appendChild(“”)  向一个父节点中添加一个子节点<br>（父节点.innerHtml+&#x3D;”<li>cat</li>“一样的效果）（有时会有隐患）<br>父元素.insertBefore(a1,a2)  a1为新节点，a2为指定节点 可以在指定的子节点前插入新的子节点<br>父元素.replaceChild(新节点，旧节点)  可以使用新节点替换已有的子节点<br>父元素.removeChild(子节点) 可以删除一个子节点<br><br/></p>
<h4 id="操作内联样式"><a href="#操作内联样式" class="headerlink" title="操作内联样式:"></a>操作内联样式:</h4><p>通过style属性设置和读取的样式都是内联样式<br>元素.style.width&#x3D;”300px”<br>元素.style.backgroundColor&#x3D;”yellow” 需要将样式名改为驼峰命名的写法</p>
<p>读取样式 (但通过style无法读取样式表中的样式)<br>元素.style.backgroundColor<br><br/>  </p>
<h4 id="获取元素的样式"><a href="#获取元素的样式" class="headerlink" title="获取元素的样式:"></a>获取元素的样式:</h4><p>读取当前元素正在显示的样式:元素.currentStyle.width（这个只有IE支持）<br>在其他浏览器中可以使用getComputedStyle(元素,null)来获取当前样式，返回的是一个对象，读取样式:对象.样式名<br>上面这两个都是只读，不能修改，<br>而修改必须要用style属性<br><br/></p>
<h4 id="其他样式相关的属性"><a href="#其他样式相关的属性" class="headerlink" title="其他样式相关的属性:"></a>其他样式相关的属性:</h4><p>元素.clientWidth  可见宽   没有单位(包括内容区和内边距) 只读属性<br>元素.offsetWidth  包括内容区，内边距，边框  没有单位<br>offsetParent  会获取到离当前元素最近的并且开启了定位的祖先元素<br>offsetLeft 当前元素相对于其定位元素的水平偏移量<br>scollWidth  滚动区域的高度<br>scrollLeft  获取水平滚动条滚动的距离<br>说明垂直滚动条到底了: scrollHeight-scrollTop&#x3D;clientHeight<br>元素.onscroll&#x3D;function(){}滚动条的滚动事件<br>input.disabled&#x3D;true 设置元素禁用<br>input.disabled&#x3D;false  设置元素可用<br><br/></p>
<h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象:"></a>事件对象:</h4><p>onmousemove：在元素内移动时触发<br>事件对象:当事件的响应函数被触发时,浏览器每次都会将一个事件对象作为实参传递进响应函数。事件对象中封装了当前事件相关的所有细节<br>window.event 在ie8以下，还有chrome中将事件对象作为window的属性保存的，<br>在火狐中是作为实参传进来(function(event))</p>
<p>event&#x3D;event||window.event 解决兼容性问题<br><br/></p>
<h4 id="div跟随鼠标移动"><a href="#div跟随鼠标移动" class="headerlink" title="div跟随鼠标移动:"></a>div跟随鼠标移动:</h4><p>document.onmousemove&#x3D;function(event){<br>event&#x3D;event||window.event;<br>var left&#x3D;event.clientX;鼠标在当前的 可见窗口 中的坐标，当页面出现滚动条，容易出现bug<br>var top&#x3D;event.clientY;</p>
<p>var left&#x3D;event.pageX；鼠标相对于整个页面的坐标,这个属性在ie8中不支持</p>
<p>box1.style.left&#x3D;left+”px”;  这里元素需要开启定位才能生效，这里的参照物是整个页面</p>
<p>}<br><br/></p>
<h4 id="事件的冒泡"><a href="#事件的冒泡" class="headerlink" title="事件的冒泡:"></a>事件的冒泡:</h4><p>指事件的向上传导，当后代元素的事件被触发时，它的祖先元素的相同事件也会被触发<br>document.body.onclick&#x3D;function(event){<br>如果要取消冒泡 event.cancelBubble&#x3D;true;<br><br/></p>
<h4 id="事件的委派"><a href="#事件的委派" class="headerlink" title="事件的委派:"></a>事件的委派:</h4><p>指事件统一绑定给元素共同的祖先元素,当后代元素身上的事件触发时,会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件</p>
<p>好处:可以减少事件绑定的次数，提高程序的性能<br>event.target 表示事件触发的对象<br><br/></p>
<h4 id="事件的绑定"><a href="#事件的绑定" class="headerlink" title="事件的绑定:"></a>事件的绑定:</h4><p>1 使用对象.事件&#x3D;函数 的形式绑定响应函数<br>它只能为一个元素的同一个事件绑定一次响应函数<br>不能绑定多个，如果绑定多个，则后面的会覆盖前面的</p>
<p>2 addEventListener()<br>可以为同一个元素的同一个事件绑定多个响应函数(ie8及以下不支持)<br>参数:<br>事件的字符串，不要on<br>回调函数，当事件触发时，该函数会被调用<br>是否在捕获阶段触发事件，需要一个值，一般都为false<br>btn1.addEventListener(“click”,function(){},false)<br>这里的this是绑定事件的对象</p>
<p>在ie8中可以使用<br>btn.attachEvent(“onclick”,function(){}）和上面不同的是 这个 是 事件后绑定先执行，<br>这里的this是window<br><br/></p>
<h4 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播:"></a>事件的传播:</h4><p>W3C将事件传播分为3个阶段:<br>1 捕获阶段<br>从最外层的祖先元素向目标元素进行事件的捕获，但是默认此时不会触发事件</p>
<p>2 目标阶段<br>事件捕获到目标元素 捕获结束 开始在目标元素上触发事件</p>
<p>3 冒泡阶段<br>事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件</p>
<p>如果希望在捕获阶段触发事件，可以将addEventListener的第三个参数设置为true</p>
<p>在ie8及一下的浏览器中没有捕获阶段<br><br/></p>
<h4 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽:"></a>拖拽:</h4><p>取消事件</p>
<p>document.onmouseup&#x3D;null<br>当拖拽网页中的内容时,浏览器会默认在搜索引擎中搜索内容，<br>此时会导致拖拽功能的异常，这是浏览器提供的默认行为，<br>如果不希望出现这个行为,可以通过return false 来取消默认行为，但在ie8中不奏效</p>
<p>使用addEventListener绑定事件取消默认行为是不能使用return false,<br>而是使用event.preventDefault()<br><br/></p>
<h4 id="滚轮事件"><a href="#滚轮事件" class="headerlink" title="滚轮事件:"></a>滚轮事件:</h4><p>box1.onmousewheel&#x3D;function(event){但火狐不支持<br>event.wheelDelta 可以获取鼠标滚轮滚动的方向  正值向上  负值向下<br>}<br><br/></p>
<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件:"></a>键盘事件:</h4><p>一般都会绑定给一些可以获取到焦点的对象或者是document(input,..)<br>onkeydown：键盘被按下<br>onkeyup:键盘被松开</p>
<p>document.onkeydown&#x3D;function(event){<br>console.log(event.keyCode) 按键的编码</p>
<p>event.altKey<br>event.ctrlKey<br>event.shiftKey 这三个用来判断alt,ctrl,shift是否被按下，如若按下了则返回true</p>
<p>在文本框中输入内容，属于onkeydown的默认行为<br>使文本框中不能输入数字<br>if(event.keyCode&gt;&#x3D;48&amp;&amp;event.keyCode&lt;&#x3D;57){<br>return false;<br>}<br><br/></p>
<p>BOM对象:</p>
<p>BOM（Brower Object Model）：浏览器对象模型，可以通过js来操作浏览器</p>
<p>DOM(Document Object Model):文档对象模型</p>
<p>BOM对象:</p>
<p>Window 整个浏览器的窗口,同时也是网页中的全局对象</p>
<p>Navigator 当前浏览器的信息，可以用这个识别不同的浏览器</p>
<p>Location  浏览器的地址栏  可以获取地址栏信息,或者操作浏览器跳转页面，location&#x3D;”<a target="_blank" rel="noopener" href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a> 或者 “01.html”直接跳转页面,并且会生成相对应的历史记录 ，location.reload(true):强制清空缓存刷新 location.assigin(“http:&#x2F;&#x2F;…”) 与location一样,location.replace(“http:&#x2F;&#x2F;…”)也能跳转，但不会生成历史记录</p>
<p>History 可以操作浏览器的历史记录，只能向前或向后翻页，只能在当次访问时有效,history.length:当前访问的链接数量（如果关闭浏览器就没了）,history.back():可以回到到上一个页面，和浏览器的回退按钮一样，history.forward():跳转到下一个页面，和浏览器的前进按钮一样，history.go() 可以跳转到指定的页面，需要一个整数作为参数 1表示向前跳转一个页面,-1表示向后跳转一个页面</p>
<p>Screen 用户的屏幕的信息,</p>
<p>这些BOM对象都是作为window对象的属性保存的<br>可以通过window的对象使用，也可以直接使用<br><br/></p>
<h4 id="定时器简介"><a href="#定时器简介" class="headerlink" title="定时器简介:"></a>定时器简介:</h4><p>setInterval(function(){},1000)<br>定时调用:每隔一段时间执行一次回调函数<br>时间单位是毫秒<br>返回一个number类型的数据<br>这个数字作为定时器的唯一标识</p>
<p>清除上面的定时器<br>var timer&#x3D;setInterval(…)<br>clearInterval(timer);<br>可以接收任意参数，<br>如果参数是一个有效的定时器标识，则会停止定时器<br>如果不是一个有效的标识，则什么也不会做</p>
<p>如果同时开启多个定时器，则会速度变快，需要在开启前清除掉上一个</p>
<p>setTimeout(function(){},300)<br>延时调用一个函数不马上执行，而是隔一段时间之后再执行，而且只会执行一次<br>clearTimeout(…)<br><br/></p>
<h4 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图:"></a>轮播图:</h4><p>为每一个链接添加属性 all[i].num&#x3D;i;<br><br/></p>
<h4 id="类的操作"><a href="#类的操作" class="headerlink" title="类的操作:"></a>类的操作:</h4><p>可以修改元素class的属性来间接修改样式<br>box.className&#x3D;”m2”;</p>
<p>.m2{<br>…<br>}</p>
<p>box.className+&#x3D;” m2”<br><br/></p>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON:"></a>JSON:</h4><p>是一个特殊格式的字符串，这个字符串可以被任何的语言识别，主要用来数据的交互<br>‘{“name”:”涨潮”,”action”：”冲刷”}’<br>JSON中的属性名必须加双引号<br>JSON中允许的值：<br>1 字符串<br>2 布尔值<br>3 数值<br>4 null<br>5 对象(普通对象)<br>6 数组</p>
<p>JSON.parse()<br>可以将JSON字符串转换为js对象，<br>需要一个JSON字符串作为参数</p>
<p>JSON.stringify()<br>可以将一个js对象转换为JSON字符串</p>
<h4 id="eval"><a href="#eval" class="headerlink" title="eval:"></a>eval:</h4><p>eval（）<br>可以执行一段字符串形式的JS代码,并将执行结果返回<br>eval(“alert(‘hello’);”)</p>
<p>如果eval执行的过程中有{},它会将{}当成是代码块，<br>如果不希望将其当成代码块解析，则需要在字符串前后各加一个<br>如<br>‘{“name”:”涨潮”,”action”：”冲刷”}’ 改成<br> ‘({“name”:”涨潮”,”action”：”冲刷”})’<br>或者 eval(“(“+str+”)”)<br><br/></p>
<h4 id="变量声明提升与函数提升："><a href="#变量声明提升与函数提升：" class="headerlink" title="变量声明提升与函数提升："></a>变量声明提升与函数提升：</h4><p>变量提升在函数提升之前</p>
<p>通过var定义的变量，在定义语句之前就可以访问到，只是值为undefined<br>通过function声明的函数,在之前就可以直接调用<br><br/></p>
<h4 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链:"></a>作用域与作用域链:</h4><p>作用域:在编写代码时就确定了，和函数调用没有关系。<br>分类:<br>全局作用域<br>函数作用域<br>没有块作用域(ES6有了)<br>作用:<br>隔离变量,不同作用域下同名变量不会有冲突。</p>
<p>作用域链:<br>多个上下级关系的作用域形成的链,它的方向是从下往上的(从内到外)。<br>查找变量时就是沿着作用域链来查找的。</p>
<h4 id="循环遍历加监听"><a href="#循环遍历加监听" class="headerlink" title="循环遍历加监听:"></a>循环遍历加监听:</h4><p>for(var i&#x3D;0,length&#x3D;btns.length;i&lt;length;i++){<br>var btn&#x3D;btns[i];<br>btn.index&#x3D;i;&#x2F;&#x2F;将btn所对应的下标保存在btn上<br>btn.onclick&#x3D;function(){<br>alert(‘第+(this.index+1)+个’)<br>}</p>
<p>1 2 3 4 …</p>
<p>利用闭包同样可以实现:<br>for(var i&#x3D;0,length&#x3D;btns.length;i&lt;length;i++){<br>(function(i){ 这里据作用域是不同的，每次执行立即执行函数中的i和for循环里的i都不一样，因为作用域不同<br>var btn&#x3D;btns[i];<br>btn.onclick&#x3D;function(){<br>alert(‘第+(i+1)+个’)<br>}<br>)(i)<br>}<br><br/><br><br/></p>
<h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承:"></a>原型链继承:</h4><p>关键点:子类型的原型是父类型的一个实例对象<br>父类型:<br>function Supper(){<br>this.supProp&#x3D;”Supper property”;<br>}</p>
<p>Supper.prototype.showSupperProp&#x3D;function(){<br>console.log(this.supProp);<br>}</p>
<p>子类型:<br>function Sub(){<br>this.subProp&#x3D;”Sub property”;<br>}</p>
<p>Sub.prototype.showSubProp&#x3D;function(){<br>console.log(this.subProp);<br>}</p>
<p>vra sub&#x3D;new Sub();<br>sub.showSupperProp();报错<br>sub.toString();可以 （内部执行了一句代码:Sub.prototype&#x3D;{}；透过这个对象可以看到 object.prototype身上的toString方法）</p>
<p>所以想让子类型实例对象看到父类型中的方法，需加上:<br>Sub.prototype&#x3D;new Supper();</p>
<p>此时 Sub.constructor 是 Supper函数，因为这个construtor构造器属性只在原型对象身上(即Sub.prototype),并且人为指向了Supper实例对象</p>
<p>所以还应该加上；<br>Sub.prototype.constructor&#x3D;Sub;让子类型的原型的constructor指向子类型<br><br/><br><br/></p>
<h4 id="借用构造函数继承（假的）"><a href="#借用构造函数继承（假的）" class="headerlink" title="借用构造函数继承（假的）:"></a>借用构造函数继承（假的）:</h4><p>s实际上只是简化了代码(借用其他函数初始化了一些相同的属性)<br>关键：在子类型的构造函数中通过call（）调用父类型的构造函数<br>function Person(name,age){<br>this.name&#x3D;name;<br>this.age&#x3D;age;<br>}</p>
<p>function Student(name,age,price){<br>Person.call(this,age,price);相当于 this.age&#x3D;age;this.price&#x3D;price;<br>this.price&#x3D;price;<br>}</p>
<p>new Student(‘Tom’,20,100);</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/14/JS%E6%A0%B8%E5%BF%83/" data-id="cl0pe0c9q0001gono63a8dmgs" data-title="JS" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-github官网快速进入的方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/14/github%E5%AE%98%E7%BD%91%E5%BF%AB%E9%80%9F%E8%BF%9B%E5%85%A5%E7%9A%84%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2022-02-14T05:45:50.000Z" itemprop="datePublished">2022-02-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/14/github%E5%AE%98%E7%BD%91%E5%BF%AB%E9%80%9F%E8%BF%9B%E5%85%A5%E7%9A%84%E6%96%B9%E6%B3%95/">github官网快速进入的方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>C:\Windows\System32\drivers\etc 在hosts文件中最后添加<br>#github<br>140.82.114.3 github.com<br>199.232.69.194 github.global.ssl.fastly.net</p>
<p>ip地址需要在<a target="_blank" rel="noopener" href="https://ipaddress.com/%E4%B8%AD%E6%9F%A5%E6%89%BE">https://ipaddress.com/中查找</a></p>
<p>最后在cmd窗口执行 ipconfig &#x2F;flushdns 来刷新DNS缓存</p>
<p>还可以在cmd窗口中输入 ping github.com 查询github.com&#x2F;的访问时间</p>
<p>或者换网  从wifi到热点（数据线连接)，从热点到wifi</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/14/github%E5%AE%98%E7%BD%91%E5%BF%AB%E9%80%9F%E8%BF%9B%E5%85%A5%E7%9A%84%E6%96%B9%E6%B3%95/" data-id="cl0pe0c9u0002gono0rincj1m" data-title="github官网快速进入的方法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CSS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/11/CSS/" class="article-date">
  <time class="dt-published" datetime="2022-02-10T16:59:54.000Z" itemprop="datePublished">2022-02-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/11/CSS/">CSS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型:"></a>盒模型:</h4><p>每个盒子都由 内容区(content) 内边距(padding) 边框(border) 外边距(margin) 组成</p>
<p>内容区由width 和 height决定</p>
<p>border-width:<br>四个值: 上 右 下 左</p>
<p>三个值:上 左右 下</p>
<p>两个值: 上下 左右</p>
<p>一个值: 四个方向</p>
<p>border-color值的设置也与border-width一样<br>padding值的设置也是一样的</p>
<p>若添加background-color属性，并且添加padding-top<br>那么除了内容区(content)会有背景色外，内边距区域也会有背景色<br>边框(border)不会受到影响</p>
<p>外边距不会影响可见框的大小，但会影响盒子的位置</p>
<p>元素在页面中是按照自左向右边排列的<br>默认情况下如果设置左和上外边距 则会移动元素自身<br>如果是设置右和下外边距则会移动其他元素<br>（如果margin取赋值  移动的方向改变  但移动的对象还是与正值时的对象一样）</p>
<p>盒子实际占用空间（包括margin部分）</p>
<p>IE盒子模型:box-sizing:border-box;(怪异模式) width&#x2F;height属性包含padding和border+内容区</p>
<p>W3C标准盒子模型:box-sizing:content-box;（标准模式）默认模式 width&#x2F;height属性包含不包含padding和border </p>
<p>默认情况下:盒子可见框的大小由边框，内边距，内容区组成</p>
<p>默认值: content-box </p>
<br/>
<br/>
#### 垂直外边距: ####
相邻的情况:
当上面盒子设置 margin-bottom

<p>下面盒子设置 margin-top</p>
<p>这其中的间距 取其中的最大值</p>
<p>特殊情况:<br>如果相邻的外边距一正一负,取他们的和<br>如果相邻的外边距都是负的,取其中绝对值较大的</p>
<p>父子的情况:<br>给子元素设置上外边距,它会传给父元素，导致整体移动<br>解决方法:<br>给父元素设置border(起到隔开的作用)<br><br/><br><br/></p>
<h4 id="display的可选值"><a href="#display的可选值" class="headerlink" title="display的可选值:"></a>display的可选值:</h4><p>inline 转换成行内<br>block  转成块级<br>inline-block 转成行内块<br>table  将元素设置为一个表格<br>none   元素不会在页面中显示<br>flex   弹性盒子<br><br/><br><br/></p>
<h4 id="隐藏元素的方式与区别"><a href="#隐藏元素的方式与区别" class="headerlink" title="隐藏元素的方式与区别:"></a>隐藏元素的方式与区别:</h4><p>display:none 隐藏元素 不会占据位置</p>
<p>visibility: hidden 隐藏元素  仍然占据位置</p>
<p>height:0;overflow:hidden;<br><br/><br><br/></p>
<h4 id="有序列表与无序列表"><a href="#有序列表与无序列表" class="headerlink" title="有序列表与无序列表:"></a>有序列表与无序列表:</h4><p>无序 ul</p>
<p>有序 ol</p>
<p>定义列表</p>
<p>dl创建一个定义列表<br>dt表示定义的内容<br>dd对内容进行解释说明</p>
<p>dl dt dd都是块级<br><br/><br><br/></p>
<h4 id="超链接："><a href="#超链接：" class="headerlink" title="超链接："></a>超链接：</h4><p>a 行内  里面可以嵌套除了自身外的任何元素(如果嵌套了自身，还是算作两对同级的a标签)</p>
<p>a href&#x3D;”2.html”  除了能跳指定网站，还能跳转到其他页面</p>
<p>a target&#x3D;”_self” 在当前页打开超链接</p>
<p>a  target&#x3D;”_blank”  在新的页面打开超链接</p>
<p>href&#x3D;”#”  直接跳转到当前页的顶部位置</p>
<p>跳转到页面中的任意位置(如：底部)</p>
<p>a href&#x3D;”#bottom” </p>
<p>a id&#x3D;”bottom”（是放在底部的 这里可以是任意标签 但id是必要条件）</p>
<p>a  href&#x3D;”javascript:;” 点击后什么都不会发生<br>href&#x3D;””  默认为#<br><br/><br><br/></p>
<h4 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径:"></a>相对路径:</h4><p>如果不写.&#x2F;也不写 ..&#x2F;  ，相当于写了.&#x2F;<br>.&#x2F; 表示当前文件夹内查找<br><br/><br><br/></p>
<h4 id="img标签"><a href="#img标签" class="headerlink" title="img标签:"></a>img标签:</h4><p>自结束标签 替换元素<br>img src&#x3D;””   绝对路径（如:http:&#x2F;&#x2F;…）和相对路径都可以</p>
<p>alt&#x3D;””  图片无法加载出来时显示的信息,主要是给搜索引擎识别图片</p>
<p>width&#x3D;””   若设置宽或高其中一个属性值 则另外一个会等比例缩放,若同时设置两个 则不会</p>
<p>图片属于网页中的外部资源，外部资源都需要浏览器单独发送请求加载。</p>
<p>浏览器加载外部资源时是按需加载的，用则加载，不用则不加载</p>
<p>a:link  (a标签默认就是处于这个状态)</p>
<p>a:link 会首先加载,而a：active 和 a:hover 会在指定状态触发时加载<br><br/><br><br/></p>
<h4 id="内联框架"><a href="#内联框架" class="headerlink" title="内联框架:"></a>内联框架:</h4><p>iframe src&#x3D;””  向当前页面中引入一个其它页面（图片地址也行,引入相对路径下的页面也行）<br>frameborder&#x3D;”0” 边框<br><br/><br><br/></p>
<h4 id="音频与视频标签"><a href="#音频与视频标签" class="headerlink" title="音频与视频标签:"></a>音频与视频标签:</h4><p>audio src&#x3D;”” 引入外部的音频文件  默认是没有任何显示的<br>必须加上 controls(加上就行了，不需要给值)<br>autoplay 自动播放(大部分浏览器不支持，但IE9及以上支持)<br>loop  播放完之后又自动从开始播放<br>在不同浏览器中显示的可能不一样</p>
<p>audio controls<br>文字提示。。。<br>source src&#x3D;”   可以用source来指定文件的路径<br>对于支持audio标签的直接会找到source标签,对于不支持audio标签的，自然不会找到source标签，所以文字就会显示出来</p>
<p>若同时指定多个source（对于不同浏览器支持的文件格式不一样，主要是以前的老版，现在几乎没了） 从第一个开始 若支持此文件格式 就用它 ，不会管后面的，若所有都不支持，则出现文字</p>
<p>embed src&#x3D;”  width&#x3D;” height&#x3D;” 对ie8及以下支持(这个标签一般放在source平级的最后面<br>type&#x3D;”audio&#x2F;mp3” </p>
<p>写完这些，所有浏览器就都支持了，所以文字就不要了</p>
<p>视频标签<br>video 与上面一样的<br><br/><br><br/></p>
<h4 id="样式可编写的位置"><a href="#样式可编写的位置" class="headerlink" title="样式可编写的位置:"></a>样式可编写的位置:</h4><p>1 标签内 style&#x3D;”” 开发中禁止使用</p>
<p>2 &lt;style…</p>
<p>3 外联样式 .css文件   link rel&#x3D;”stylesheet” href&#x3D;””<br>  使样式在不同页面中得到复用<br>  这种访问速度更快 利用到了浏览器的缓存机制<br><br/><br><br/></p>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器:"></a>选择器:</h4><p>交集选择器:<br>p class&#x3D;”a<br>p.a{… 同时满足p标签 又满足类名a<br>class&#x3D;”a b c” 多个类名<br>.a.b.c{…<br>并集选择器:<br>.a,span{…<br>子元素选择器:<br>ul&gt;li</p>
<p>后代选择器:<br>ul li (子元素也是后代选择器)</p>
<p>兄弟选择器:<br>p &#x2F;p&gt;<br>span &#x2F;span</p>
<p>p+span  选择p元素的兄弟元素span<br>&lt;+ 代表 紧挨着p标签的  ，下一个，隔了一个标签就不算</p>
<p>p~span  代表选择p标签下面所有的兄弟元素span</p>
<p>属性选择器:</p>
<p title=""   
鼠标放上去后显示的提示内容

<p>p[title]{…表示选中p元素同时还带有title属性</p>
<p title="abc" 这里引号也可以去掉

<p>p[title&#x3D;”abc”]  还可以指定title属性的值 特指 </p>
<p>p[title^&#x3D;”abc”]  选中title属性值以abc开头的</p>
<p>p[title$&#x3D;”abc” 选中title属性值以abc结尾的</p>
<p>p[title*&#x3D;”abc”] 选中title属性值中存在abc的</p>
<p>伪类选择器:</p>
<p>ul&gt;li:first-child{…第一个li</p>
<p>ul&gt;li:last-child{…最后一个li</p>
<p>ul&gt;li:nth-child(3){…第3个li 特殊值:n  代表从0到正无穷，即选中了所有</p>
<p>值为2n或even:选中所有偶数(0没有，从2开始)<br>值为2n+1或odd：选中所有奇数</p>
<p>:first of type<br>:last of type<br>:nth of type </p>
<p>这三个和上面类似，唯一不同的是  这三个是指同类型的</p>
<p>否定伪类<br>ul&gt;li:not(:nth-child(3))</p>
<p>伪元素选择器:<br>p::first-letter{… p标签中的第一个字母</p>
<p>p::first-line{… p标签中的第一行</p>
<p>p::selection{… p标签中选中的内容</p>
<p>p::before{… 元素的开始 这两个是不会被上面::selection选中的</p>
<p>p::after{… 元素的最后<br><br/><br><br/></p>
<h4 id="行内元素与块级元素"><a href="#行内元素与块级元素" class="headerlink" title="行内元素与块级元素:"></a>行内元素与块级元素:</h4><p>块元素:在网页中用来对页面布局<br>特点:独占一行 不能与其他元素并排<br>可以设置宽高，如果不设置宽度，那么宽度默认变为父级的100%</p>
<p>行内元素:主要用来包裹文字<br>特点:与其他行内元素并排<br>不能设置宽高，默认宽度就是文字的宽度</p>
<p>一般情况下，会在块级元素中放行内元素，而 不会 在行内元素中放块元素<br>p元素中不能放任何的块元素</p>
<h4 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签:"></a>语义化标签:</h4><p>em  行内  让字体倾斜</p>
<p>strong 行内  加粗字体</p>
<p>q  行内  引号 </p>
<p>h1~h6 （h1字体最大）</p>
<p>p（p元素内不能放块级元素）</p>
<p>header 块级 表示网页头部<br>main  块级 表示网页主体部分<br>footer 块级 表示网页底部<br>nav 块级 表示网页中的导航<br>aside  块级 表示网页的侧边栏<br>article 块级 表示文章<br>section 块级 表示区块</p>
<p>单个的:<br>br  换行<br><br/><br><br/></p>
<h4 id="权重的比较"><a href="#权重的比较" class="headerlink" title="权重的比较:"></a>权重的比较:</h4><p>！important   权重最高   （这个在开发中能不用就不用）<br>内联  1000<br>id    100<br>类和伪类，属性选择器 10<br>元素      1<br>通配     0<br>继承     没有优先级</p>
<p>div#box1  权重是叠加的   1 + 100 &#x3D;101</p>
<p>div,p,span   分组选择器是单独计算的</p>
<p>不能跨数量级<br>如果优先级计算相同，则优先使用靠下的样式<br><br/><br><br/></p>
<h4 id="像素与百分比"><a href="#像素与百分比" class="headerlink" title="像素与百分比:"></a>像素与百分比:</h4><p>像素:屏幕(显示器)实际是由一个一个小点点（正方形）构成的<br>不同屏幕的像素大小是不同的，像素越小的屏幕显示的效果越清晰<br> 所以同样的200px在不同设备下显示效果不一样</p>
<p>百分比:可以将属性设置为相对于父元素的百分比<br>使子元素跟随父元素的改变而改变<br><br/><br><br/></p>
<h4 id="em与rem"><a href="#em与rem" class="headerlink" title="em与rem:"></a>em与rem:</h4><p>em是相对自身的字体大小设置的 ，默认为 1em &#x3D; 16px<br>这个font-size属性可以自己定义</p>
<p>rem 是相对于根元素的字体大小(即html)设置的<br><br/><br><br/></p>
<h4 id="RGB"><a href="#RGB" class="headerlink" title="RGB:"></a>RGB:</h4><p>通过三种颜色的不同浓度调配出不同的值<br>每一种颜色的范围在0~255(0% ~ 100%)之间</p>
<p>R :red</p>
<p>G:green</p>
<p>B：blue</p>
<p>蓝色:  background-color:rgb（0,0,255）</p>
<p>黑色: 0,0,0<br>白色: 255,255,255</p>
<p>rgba(0,0,0,.5)  第四个值表示透明度  .5代表0.5  1代表不透明 0表示完全透明</p>
<p>16进制的rgb值<br>语法#红绿蓝<br>颜色浓度在 00 - ff之间<br>background-color:#ff0000 红色</p>
<p>如果颜色两位两位重复则可以简写 如上面可以简写成 #f00</p>
<p>项 #aabbcd  则不能简写了<br><br/><br><br/></p>
<h4 id="HSL："><a href="#HSL：" class="headerlink" title="HSL："></a>HSL：</h4><p>H :色相（取值范围 0 - 360，一个环）</p>
<p>S: 饱和度(颜色的浓度 0% - 100%)</p>
<p>L: 亮度(0% - 100%)</p>
<p>红色  background-color:hsl(0, 100%, 50%);</p>
<p>hsla（, , , x,） x表示透明度<br><br/><br><br/></p>
<h4 id="过度约束"><a href="#过度约束" class="headerlink" title="过度约束:"></a>过度约束:</h4><p>一个元素在其父元素中，水平布局必须要满足一下的等式:<br>margin-left + border-left + padding-left + width + padding-right+ border-right + margin-right &#x3D; 其父元素内容区的宽度(必须满足)</p>
<p>如果相加结果使等式不成立，则称为过渡约束,则等式会自动调整</p>
<p>调整情况:</p>
<p>如果这七个值中没有auto的情况,则浏览器会自动调整margin-right的值来使等式成立</p>
<p>这七个值中有三个值可以设置为auto<br>width<br>margin-left<br>margin-right</p>
<p>width若为auto,（若其它值为0）则width和父元素内容区一样宽，<br>若其它有值,则auto&#x3D;父内容区宽 - 其他值宽和<br>如果同时将width和（一个或两个）外边距设置为auto ,则width会调整到最大，外边距会自动调整为0<br>如果将两个外边距设置为auto ,宽度固定,那么会两个外边距的值是相同的</p>
<p>如果其他值为0 宽度大于父元素内容区 则调整margin-right为负值<br><br/><br><br/></p>
<h4 id="轮廓阴影与圆角"><a href="#轮廓阴影与圆角" class="headerlink" title="轮廓阴影与圆角:"></a>轮廓阴影与圆角:</h4><p>起到边框作用但不会影响壳子可见框大小（周围的元素的布局不会受到影响),outline:10px solid blue;</p>
<p>box-shadow 默认处于元素内，默认是看不见的<br>  10px               10px            50px     black;<br>  水平向右移动        垂直向下移动   设置阴影的模糊半径</p>
<p>四个圆角<br>border-radius: 左上 右上 右下 坐下</p>
<p>三个值  左上  右上&#x2F;下左 右下</p>
<p>border-top-left-radius<br>border-top-right-radius<br>border-bottom-right-radius<br>border-bottom-left-radius</p>
<p>若border-bottom-right-radius:50px;  在右边底部的顶点处  向左50px处  向上50px处  垂直画线 焦点处就是圆心  半径为 50px  然后和原来的两个点相切 出来的圆角</p>
<p>border-radius: 20px &#x2F; 40px ;横向20px 纵向 40px</p>
<p>border-radius:50% 将元素设置为一个圆形<br><br/><br><br/></p>
<h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动:"></a>浮动:</h4><p>三个值<br>none 默认值 元素不浮动<br>left<br>right</p>
<p>设置浮动的元素，会完全从文档流中脱离，不再占用文档流的位置<br>设置浮动以后，元素会向父元素的左边或者右边移动<br>浮动元素默认不会从父元素中移出<br>浮动元素向左或者向右移动时，不会超过它前面的其他浮动元素<br>浮动元素不会超过它前边浮动的兄弟元素，最多最多就是和它一样高<br>浮动元素不会盖住文字，文字会自动环绕在浮动元素周围</p>
<p>脱离文档流的特点:</p>
<p>1 块元素不再独占页面的一行</p>
<p>2 脱离文档流以后，块元素的宽度和高度默认被内容撑开</p>
<p>脱离文档流后，不需要再区分块和行内了<br><br/><br><br/></p>
<h4 id="BFC"><a href="#BFC" class="headerlink" title="BFC:"></a>BFC:</h4><p>在浮动布局中，父元素的高度默认是被子元素撑起的，<br>当子元素浮动后，会完全脱离文档流，将不会撑起父元素的高度</p>
<p>开区BFC的元素会变成一个独立的布局区域</p>
<p>特点:<br>开启BFC的元素不会被浮动元素覆盖<br>开启BFC的元素子元素和父元素外边距不会重叠(例子:给子元素margin-top不会作用到父元素身上)<br>开启BFC的元素可以包裹住浮动的元素，不会出现高度塌陷</p>
<p>开启方式:</p>
<p>1 float:left&#x2F;right（缺点:脱流，宽度被内容撑开）</p>
<p>2 display:inline-block(缺点:宽度被内容撑开)&#x2F;table-cell&#x2F;table-caption&#x2F;flow-root</p>
<p>3 overflow:auto&#x2F;hidden&#x2F;scroll（缺点:这个值有滚动条）</p>
<p>4 position:absolute&#x2F;fixed</p>
<p>此外解决高度坍塌方法还有:<br>clear:<br>作用:清除浮动元素对当前元素所产生的影响</p>
<p>left  清除左侧浮动元素对当前元素所产生的影响<br>right 清除右侧浮动元素对当前元素所产生的影响<br>both  清除两侧中影响最大的那侧</p>
<p>原理:设置清除浮动以后，浏览器会自动为元素添加一个上外边距</p>
<p>这个也可以解决高度塌陷问题</p>
<p>子元素末尾添加一个div ，然后给这个元素添加clear:both 属性</p>
<p>在父元素身上添加 ::after (默认为行内元素)</p>
<p>给属性:<br>content:’’;<br>clear:both;<br>display:block;</p>
<p>同时解决高度塌陷和外边距重叠:<br>.clearfix::before,<br>.clearfix:after{<br>content:’’;<br>display:table;<br>clear:both;<br><br/><br><br/></p>
<h4 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位:"></a>相对定位:</h4><p>特点:<br>【相对于自身原来的位置（文档流中的位置，更细致就是指 元素的左上角的一个点，画两条线，向右是x轴正方向，向下是y轴正方向），如 想要移动到在元素的位置上边 top 取负值，自身原来的位置还会被保留下来】</p>
<p>开启相对定位的元素如果不设置偏移量(offset 即 top bottom left right)，元素不会有任何的变化</p>
<p>相对定位会提高元素的层级，会高于文档流中的元素</p>
<p>相对定位不会使元素脱离文档流</p>
<p>相对定位不会改变元素的性质 块级还是块级 行内还是行内</p>
<p>top：定位元素与定位位置上边的距离（这样的属性只存在于开启了定位的元素中，一般元素不适用），这个与margin-top的区别在于 top 只会影响自身，margin-top还会影响别的元素<br><br/><br><br/></p>
<h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位:"></a>绝对定位:</h4><p>会从文档流中脱离</p>
<p>会改变元素的性质  行内变成块  块的宽高被内容撑开</p>
<p>会使元素提升一个层级</p>
<p>参照物为最近的开启了定位的祖先级元素(只要position不为static),如果所有祖先级元素都没有开启定位，则参照物为根元素(html,也称为初始包含块)<br><br/><br><br/></p>
<h4 id="绝对定位元素的过渡约束"><a href="#绝对定位元素的过渡约束" class="headerlink" title="绝对定位元素的过渡约束:"></a>绝对定位元素的过渡约束:</h4><p>当为绝对定位时,<br>left + … +right （共9个值）&#x3D;父元素内容区的宽度</p>
<p>当发生过渡约束时,9个值中如果没有auto,会调整right来使等式成立(如  left:0 right:0  实际上是在左边 right值被改变了)</p>
<p>如果有auto ,则调整auto来使等式成立<br>可设置成auto的值  margin width  left right</p>
<p>当margin-left:auto margin-right:auto  (此时没写left,right  则都默认为auto,这种情况下写margin-left margin-right 无效  需要写left 0 ;right 0 才能生效 为居中，没有写left right的结局是在左边)</p>
<p>垂直方向的等式必须满足 top +margin-top&#x2F;bottom + padding-top&#x2F;bottom +height + border + bottom&#x3D; …包含块的高度</p>
<br/>
<br/>
#### 固定定位: ####
position:fixed
也是一种绝对定位 大部分特点与绝对定位一致

<p>唯一不同的是  固定定位的参照物永远都是  浏览器的视口(视口就是看到的固定不变的 而html  网页 还包含后面可以滚动的部分)，【永远都固定到刚开始看到的位置，不会随着滚动条滚动而<br><br/><br><br/></p>
<h4 id="粘滞定位"><a href="#粘滞定位" class="headerlink" title="粘滞定位:"></a>粘滞定位:</h4><p>position:sticky </p>
<p>当元素到达某个位置时将其固定(不会随着滚动条滑动而滑动)</p>
<p>如  top:100  当元素到达浏览器的视口的100px时固定不动<br><br/><br><br/></p>
<h4 id="层级"><a href="#层级" class="headerlink" title="层级:"></a>层级:</h4><p>定位的元素（position不为static）比一般的元素层级高</p>
<p>定位的元素 层级默认都一样</p>
<p>对于定位的元素:</p>
<p>z-index需要一个整数作为参数 值越大 层级大层级越高  越高越优先显示</p>
<p>如果层级一样 靠下的元素优先显示<br><br/><br><br/></p>
<h4 id="字体族"><a href="#字体族" class="headerlink" title="字体族:"></a>字体族:</h4><p>font-family:<br>字体分类<br>serif 衬线字体<br>sans-serif 非衬线字体<br>monospace 等宽字体</p>
<p>有空格的用’’ 包裹</p>
<p>1 ，2 ，3  电脑里面若有字体1就采用1，没有就采用2, …</p>
<p>电脑里面的字体文件存储的位置  c&gt;Windows&#x2F;Fonts （C:\Windows\Fonts）</p>
<p>如果想让用户使用指定的字体，但用户电脑里面本身没有</p>
<p>@font-face{<br>font-family:myfont;(自定义字体的名字)(这里要注意版权)<br>src：url(…)（如 ZCOOLKuaiLe-Regular.ttf），url(…) 先考虑前面<br>}</p>
<p>div{<br>font-family:myfont;<br>}</p>
<p>这样可以使用在线(服务器上的字体)<br><br/><br><br/></p>
<h4 id="图标字体"><a href="#图标字体" class="headerlink" title="图标字体:"></a>图标字体:</h4><p>li::before{<br>content:”.…”;<br>font-family:…<br>font-weight:…</p>
<p>&lt;span class&#x3D;”fan” &amp;#xs12..;&lt;&#x2F;span</p>
<p>在iconfont中</p>
<p>如:<br>content:’\e625’</p>
<p>而在<span class='iconfont'>&amp;#xe625</span><br><br/><br><br/></p>
<h4 id="行高"><a href="#行高" class="headerlink" title="行高:"></a>行高:</h4><p>行高:文字占有的实际高度(是指单行的行高)<br>line-height:2<br>若为整数，则为自身字体的倍数(font-size的倍数)<br>如<br>font-size:50px;<br>line-height:200px;</p>
<p>则上面75px,下面75px的空隙<br><br/><br><br/></p>
<h4 id="字体的简写属性"><a href="#字体的简写属性" class="headerlink" title="字体的简写属性:"></a>字体的简写属性:</h4><p>font:italic bold  50px&#x2F;2(这里2代表行高，如果不写，会有一个默认值，会覆盖掉前面的line-height)  ‘Times …(字体)’，字体1，字体2;<br>其中字体大小&#x2F;行高,字体族必须放在最后<br><br/><br><br/></p>
<h4 id="文本的垂直对齐"><a href="#文本的垂直对齐" class="headerlink" title="文本的垂直对齐:"></a>文本的垂直对齐:</h4><p>&lt;div…(font-size:50px) &lt;span…(font-size:20px)</p>
<p>给span 添加vertical-align:middle(其他值:bottom top baseline)（这个是在行高范围内，而不是font-size的文字大小内）</p>
<p>图标对齐方式默认为基线baseline<br><br/><br><br/></p>
<h4 id="省略号"><a href="#省略号" class="headerlink" title="省略号:"></a>省略号:</h4><p>white-space:nowrap 设置网页如何处理空白<br>overflow:hidden<br>text-overflow:ellipsis<br><br/><br><br/></p>
<h4 id="hover的使用场景"><a href="#hover的使用场景" class="headerlink" title="hover的使用场景:"></a>hover的使用场景:</h4><p>.current-city:hover + .city-list  前者触发时 后者对应…</p>
  <div class="location"

  <div class="current-city"
  <div class="city-list"
</div
但当移到city-list区域时就会消失

<p>于是将hover给到location(这个就包含了整个区域，上面的current-city就不会包括city-list区域) </p>
<p>浮出的盒子需要设置绝对定位，使其不占页面位置</p>
<p>一些样式考虑除了加给hover之后的，还有本身<br><br/><br><br/></p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景:"></a>背景:</h4><p>如果背景图片小于元素，则图片会在元素中自动平铺将元素铺满<br>如果背景图片和元素一样大，则会正常显示<br>background-repeat:repeat(默认值)&#x2F;repeat-x&#x2F;repeat-y 沿着某个方向重复&#x2F;no-repeat 不重复<br>background-position:top left 在元素左上角</p>
<p>background-position：10px(往右走)  10px（往下走） </p>
<p>background-clip:border-box(默认值，背景还会出现在边框的下边)&#x2F;padding-box(出现在内容区和内边距)&#x2F;content-box(背景只会出现在内容区)</p>
<p>当背景图片大于元素时:<br>background-size:100px（宽） 100px(高) &#x2F;如果只写一个值，第二个值默认为auto&#x2F;cover（图片比例不变，将元素铺满，这样可能图片显示不全）&#x2F;contain（图片比例不变，显示完整，但可能没有铺满元素）<br>background-attachment:scroll 背景图片会随元素滚动&#x2F; fixed 背景图片不会随元素滚动<br>background:url(‘…’) #bfa  center center&#x2F;contain(这个值必须固定在位置后面)<br>content-box border-box no-repeat</p>
<p>没有顺序要求，也没有哪个属性是必须写的</p>
<p>background-origin:背景图片偏移量计算的原点 padding-box(background-position从内边距开始计算)  content-box(从内容区开始计算)  border-box(从边框处开始计算)</p>
<p>origin 写在前    clip写在后面</p>
<p>渐变颜色:<br>用正方形线条 从上到下选1px  图像-&gt;裁剪  文件_-&gt;存储为web所用格式 存储<br>background-image:url(…)<br>background-repeat:repeat-x<br>前提是高度一致<br><br/><br><br/></p>
<h4 id="雪碧图"><a href="#雪碧图" class="headerlink" title="雪碧图:"></a>雪碧图:</h4><p>解决图片闪烁的问题<br>可以将多个小图片保存在一张大图片中，然后通过background-position来显示图片的位置<br>优点:降低请求的次数，加快访问速度<br><br/><br><br/></p>
<h4 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变:"></a>线性渐变:</h4><p>颜色沿着一条直线发生变化<br>渐变是图片，需要通过background-image来设置</p>
<p>background-image:linear-gradient(red,yellow)   从上(红色)到底部(黄色)，中间是过渡区域</p>
<p>background-image:linear-gradient(to right ，red,yellow) 从左向右变<br> to top left, 从右下到左上</p>
<p>可以指定多个颜色，多个颜色默认情况下平均分布</p>
<p>background-image:linear-gradient(to right ,red 50px ,yellow)<br>从50px 开始渐变(50px以前的都是红色)  </p>
<p>background-image:linear-gradient(to right ,red 50px ,yellow 100px）如果是200px, 100px后面都是黄色   </p>
<p>background-image: repeating-linear-gradient(to right ,red 50px ,yellow 100px）  重复的线性渐变<br><br/><br><br/></p>
<h4 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变:"></a>径向渐变:</h4><p>background-image:radial-gradient(red,green)<br>默认情况下 径向渐变的圆心形状根据元素的形状来计算的<br>正方形 -&gt; 圆形</p>
<p>长方形 -&gt; 椭圆形</p>
<p>也可以手动指定径向渐变的大小</p>
<p>background-image：radial-gradient(100px 100px red,green)  100px正方形内的圆中从内到外 渐变</p>
<p>radial-gradient(100px 100px at 0px 0px, red,green) 可以指定渐变的圆心<br><br/><br><br/>      </p>
<h4 id="超链接的伪类"><a href="#超链接的伪类" class="headerlink" title="超链接的伪类:"></a>超链接的伪类:</h4><p>a:link{…表示没有访问过的链接</p>
<p>a:visited{… 表示访问过的链接 由于隐私的原因，只能修改颜色</p>
<p>下面这两个对任何标签都适用<br>：hover{…鼠标移上去的状态 </p>
<p>:active{…点击不松手时的状态<br><br/><br><br/></p>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格:"></a>表格:</h4><table>
thead>tr>td /th (加粗 居中 的效果)  头部
tbody>tr>td 主题
tfoot>tr>td 脚步

<td>这个是行内元素

<p>合并两列: colspan&#x3D;’2’ </p>
<p>合并两行: rowspan&#x3D;’2’</p>
<p>table{</p>
<p>border-spacing:0px; 指定边框之间的距离</p>
<p>border-collapse:collapse;合并边框</p>
<p>}</p>
<p>如果表格中没有写tbody,而是直接写tr,那么浏览器会自动创建一个tbody,并且将tr放到里面</p>
<p>display:table-cell;将元素可以设置成单元格<br>这种情况下 vertical-align:middle; 可以将里面的元素 设置成 垂直居中<br><br/><br><br/></p>
<h4 id="表单"><a href="#表单" class="headerlink" title="表单:"></a>表单:</h4><p>用于提交数据</p>
<form action=""  
actio. 表单要提交数据的服务器的地址
<input type="text" name="..." 
autocomplete="on /off"   历史记录显示与否 （也可以直接给到form 属性上，可直接作用在所有input type="text" 上  

<p>数据要提交到服务器，必须要为元素指定一个name属性</p>
<p>单选按钮  <input type="radio" name='...'>  &lt;input …<br>两个必须是同一个name属性 同时还需要有一个value属性<br>checked 默认选中</p>
<p>多选框 type&#x3D;’checkbox’ …</p>
<p>下拉列表</p>
<p>&lt;select name&#x3D;’</p>
<option value='...' selected> ...</option>

<p>input type&#x3D;”submit”  点完就提交了</p>
<p>input type&#x3D;”button”  只是可以点击</p>
<p>input type&#x3D;”reset”  点完重置所有</p>
<p>readonly  将表单项设置为只读性 数据会提交</p>
<p>disabled  将表单项设置为禁用  数据不会提交</p>
<p>autofocus 用于设置表单项 自动获取焦点<br><br/><br><br/></p>
<h4 id="vscode快捷键"><a href="#vscode快捷键" class="headerlink" title="vscode快捷键:"></a>vscode快捷键:</h4><p>按住alt 点击多个 会出现多个光标 可以同时控制多个</p>
<p>.a$*3 &#x3D;&gt;.a1+.a2+.a3<br><br/><br><br/></p>
<h4 id="过渡"><a href="#过渡" class="headerlink" title="过渡:"></a>过渡:</h4><p>属性<br>transition-property:width,height;（all）</p>
<p>过渡时间:<br>transition-duration:2s;</p>
<p>颜色也能适用</p>
<p>必须是一个有效数值向另一个有效数值过渡(如 margin-left:auto   margin-left:0; 不会有过渡效果)</p>
<p>过渡的执行方式<br>transition-timing-function:<br>ease 默认值 慢速开始 先加速 后减速<br>linear  匀速运动<br>ease-in 加速运动<br>ease-out 减速运动<br>ease-in-out 先加速 后匀速</p>
<p>steps(3) 分步骤</p>
<p>transition-delay:2s  等待一定时间后再执行过渡</p>
<p>transition 可以同时设置所有<br>有一个要求 如果要写延迟  第一个是持续时间 第二个是延迟时间<br><br/><br><br/></p>
<h4 id="动画"><a href="#动画" class="headerlink" title="动画:"></a>动画:</h4><p>@keyframes name1{  设置一个关键帧  设置了动画执行的每一个步骤<br>….<br>from （动画的开始位置 ,也可以用0%表示）{ margin-left:0; </p>
<p>to(动画的结束位置,也可以用100%表示){margin-left:200px;</p>
<p>与过渡的区别是  动画不需要操作</p>
<p>.box2{<br>animation-name:name1  对当前元素生效的关键帧的名字<br>animation-duration:2s 动画的执行时间</p>
<p>animation-delay:2s;</p>
<p>animation-timing-function:linear;</p>
<p>animation-iteration-count:2;动画执行的次数 infinite  无限</p>
<p>animation-direction:reverse(反着执行);指定动画运行的方向  （normal）<br>alternate 开始也是从 from 到 to  重复执行动画时反向执行<br>alternate-reverse  开始是从to 到 from  重复执行动画时反向执行</p>
<p>animation-play-state:running（默认值）;设置动画的执行状态 paused（暂停状态）</p>
<p>动画的填充模式<br>animation-fill-mode:none(默认值) 动画执行完毕后 元素回到原来的位置<br>forwards 动画执行完毕后 元素会停止在动画结束的位置<br>backwards  动画延迟等待时 元素就会处于开始状态<br>both 结合了上面两个（forwards 和 backwards）</p>
<h4 id="变形"><a href="#变形" class="headerlink" title="变形:"></a>变形:</h4><p>设置变形效果<br>transform:scaleX&#x2F;Y（2） 水平&#x2F;垂直放大2倍</p>
<p>scale(2) 双方向放大2倍</p>
<p>变形的原点 默认值center center<br>transform-origin:0 20px</p>
<p>transform: translateX（）沿着x轴方向 （水平 向右） translateY)() 垂直向上 translateZ()  向外</p>
<p>不会对布局造成影响</p>
<p>transform:translateX(100%)  相对于自身的百分百  </p>
<p>transform:rotate(X&#x2F;Y&#x2F;Z)<br>transform:rotateZ(180deg&#x2F;1turn 一圈)</p>
<p>是否显示元素的背面<br>backface-visibility:visible 显示   hidden 隐藏<br>z轴；<br>调整元素和人眼之间的距离<br>距离越大，离人越近。<br>z轴平移属于立体效果（近大远小） 默认情况下网页是不支持立体效果的 如果需要看见效果，需要设置网页的视距</p>
<p>html：{<br>perspective:800px(一般 800 到 1000)</p>
<p>…:hover{<br>transform:translateZ（800px）  直接贴满<br><br/><br><br/></p>
<h4 id="元素垂直水平居中"><a href="#元素垂直水平居中" class="headerlink" title="元素垂直水平居中:"></a>元素垂直水平居中:</h4><p>对于盒子大小是确定的</p>
<p>position:absolute;<br>top,right,bottom,left :0;<br>margin:auto;</p>
<p>但对于盒子大小是被内容撑开的:</p>
<p>left:50%;<br>top:50%;<br>transform:translateX(-50%) translateY(-50%);</p>
<h4 id="变量与计算器"><a href="#变量与计算器" class="headerlink" title="变量与计算器:"></a>变量与计算器:</h4><p>css原生支持变量的设置</p>
<p>html{<br>–color:#bfa;<br>–length:100px;</p>
<p>.box1{<br>background-color:var(–color); 使用这个变量<br>width:var(–length)</p>
<p>width:calc(1000px&#x2F;2)  calc相当于计算器( * …</p>
<h4 id="关于less："><a href="#关于less：" class="headerlink" title="关于less："></a>关于less：</h4><p>是css的预处理语言<br>是css的增强版 用更少的代码实现更强的样式</p>
<p>浏览器无法直接执行less代码，必须先转换成css代码，再教给浏览器去执行</p>
<p>easy-less插件<br>建一个less文件，保存后会自动多出一个css文件</p>
<p>好处：<br>less中写的是<br>body{<br>div{<br>color:green;<br>}<br>}</p>
<p>css中会出现<br>body div{<br>color:green;</p>
<p>变量:可以存储任意值 语法: @变量名<br>@a:100px; 这个不会出现在css中<br>.box{<br>width:@a;</p>
<p>作为一部分使用时<br>@c:box6;</p>
<p>background-image:url(“@{c}&#x2F;1.jpg”) 这里引号必须加上</p>
<p>可以在变量声明前使用</p>
<p>&amp;相当于父级元素<br>&amp;:hover{<br>…</p>
<p>.p2:extend(.p1){ 可以拥有p1的样式,同时还能设置自己的样式<br>…</p>
<p>.p3{<br>.p1（） 直接复制了p1的样式</p>
<p>.p4(){专门用来给别人用 混合函数<br>….</p>
<p>.p5{<br>.p4();</p>
<p>上面混合函数中还可以设置变量</p>
<p>.p4(@w,@h,@bg-color){  这里还可以设置默认值 @w:100px;<br>width:@w;</p>
<p>.p5{<br>.p4（200px,300px,green);按顺序传递参数</p>
<p>还可以指定变量名<br>.p5{<br>.p4(@bg-color:red,@w:200px,@h:300px)</p>
<p>color:average(red,orange) 取两个颜色之间的平均值</p>
<p>background-color:darken(#bfa,20%);加深前面的颜色20%</p>
<p>在less中所有数值可以直接运算<br>.box{<br>width:500px + 500px</p>
<p>在less中还可以这样写<br>@import “2.less”  引入其他的less文件（相当于其他的文件的代码 全部复制到这个文件中了）</p>
<h4 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子:"></a>弹性盒子:</h4><p>display:flex;块级的弹性容器<br>display:inline-flex; 行内的弹性容器</p>
<p>主要是代替浮动完成页面的布局</p>
<p>弹性容器（display:flex）的 子（并不是指后代） 元素是弹性元素</p>
<p>弹性元素的排列方式</p>
<p>flex-direction:row（默认值）&#x2F;column row-reverse column-reverse </p>
<p>主轴:弹性盒子的排列方式</p>
<p>侧轴:与主轴垂直方向的称为侧轴  </p>
<p>指定弹性元素伸展的系数<br>flex-grow:0  当父元素有剩余空间的时候，子元素如何伸展 父元素的剩余空间会按照比例进行分配</p>
<p>0  不会去分配剩余空间</p>
<p>弹性元素的收缩系数 (当父元素的空间不足以容纳所有子元素时，如何对子元素进行收缩)<br>flex-shrink :0&#x2F;1&#x2F;2&#x2F;…  0表示不收缩(默认值为1) 值越大 ，缩的越小</p>
<p>设置弹性元素在弹性容器中是否自动换行<br>flex-wrap:wrap&#x2F;no-wrap（默认值）&#x2F;wrap-reverse(反方向排列)<br>no-wrap 元素沿着辅（侧）轴方向自动换行</p>
<p>direction 和 wrap 的简写属性<br>flex-flow:row wrap </p>
<p>主轴上的元素的排列方式<br>justify-content:flex-start(主轴的起边排列)&#x2F;flex-end(主轴的终边排列)&#x2F;center（元素居中排列）&#x2F;space-around(空白分配到元素两侧)&#x2F;space-evenly(空白分配到元素的单侧)&#x2F;space-between(空白分配到元素之间)</p>
<p>侧轴的对齐方式<br>align-items:stretch 将元素的长度设置为相同值 &#x2F;flex-start 元素不会拉伸 沿着起边对齐&#x2F;flex-end 沿着辅轴的终点对齐&#x2F;center 居中对齐&#x2F;baseline 基线对齐</p>
<p>flex-basis<br>指定的是 元素在主轴上的基础长度<br>如果主轴是 横向的 则该值就是指元素的宽度<br>如果主轴是 纵向的 则该值就是指元素的高度<br>默认值是auto 表示参考元素自身的高度或宽度<br>如果是 一个具体的值 则以该值为主</p>
<p>flex:  增长系数 缩减系数 基础长度<br>默认值是  0 1 auto</p>
<p>order： 0&#x2F;1&#x2F;…<br>决定元素的排列顺序<br>值越大 越靠前排列<br><br/><br><br/></p>
<h4 id="像素"><a href="#像素" class="headerlink" title="像素:"></a>像素:</h4><p>分辨率:1920 * 1080 是指 物像像素<br>在编写网页时所用的都是css像素<br>浏览器在显示网页时，需要将我们的css像素 转换为 物理像素<br>一个css像素与 物理像素的对应比例 取决于浏览器</p>
<p>默认情况下，在pc端 一个css像素 等于 一个物理像素</p>
<p>视口:显示网页的窗口（可以通过拖拽改变大小）（固定定位就是根据视口定位的）</p>
<p>放大两倍的情况:<br>视口宽度:980（css像素）<br>物理像素:1920 （物理像素永远不会变）<br>此时 css像素:物理像素 &#x3D; 1:2<br><br/><br><br/></p>
<h4 id="完美视口"><a href="#完美视口" class="headerlink" title="完美视口:"></a>完美视口:</h4><p>想让pc端的网页在移动端 显示的体验更好</p>
<p>可以通过视口的变化来影响像素比</p>
<p>css像素(视口) &#x2F; 物理像素(固定不变的)<br>可以通过meta标签来改变视口大小</p>
<meta name="viewport" content="width=100px" 

<p>width&#x3D;device-width是指视口宽度就是设备的宽度 简称完美视口</p>
<p>iphone6中像素比为:  100 &#x2F; 750<br>一个css像素对应7.5个物理像素<br>每一款移动设备设计时都会有一个最佳的像素比</p>
<p>a(视口的css像素)&#x2F;750(现在的物理像素)&#x3D;像素比 2.0 （即 1个css像素对应2个物理像素）</p>
<p>iphone6： 375 * 667<br><br/><br><br/></p>
<h4 id="vw："><a href="#vw：" class="headerlink" title="vw："></a>vw：</h4><p>vw：永远相对于视口宽度<br>100vw</p>
<p>%的参照物总是在变化</p>
<p>100vw&#x3D;750px(设计图的大小)<br>a&#x3D;48px(设计图中元素的宽)<br><br/><br><br/></p>
<h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询:"></a>媒体查询:</h4><p>@media only screen（带屏幕的设备）&#x2F;print（打印设备）&#x2F;speech（屏幕阅读器)&#x2F;all{<br>body{<br>color:…<br>}<br>}</p>
<p>only 主要是为了兼容一些老版本的浏览器</p>
<p>@media(width:500px 当视口宽度为500px时){<br>}</p>
<p>min-width:视口的最小宽度<br>max-width:视口的最大宽度</p>
<p>@media （min-width：200px）,(max-width:600px){ ,表示或，满足其一就能生效</p>
<p>@media not（min-width：200px）,(max-width:600px){ not表示除了<br><br/><br><br/></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他:"></a>其他:</h4><p>一个元素想让左边留一些间隙，如果设置 margin-left   那么外边那部分不是元素本身拥有的了，如果设置padding-left，空出来的还是元素本身拥有的</p>
<p>若一个元素自身没有设置宽度 则宽度默认为auto ,这种情况下设置padding不会撑大盒子 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/11/CSS/" data-id="cl0pe0c9i0000gono1ibzfafl" data-title="CSS" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-使用hexo搭建博客" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/11/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" class="article-date">
  <time class="dt-published" datetime="2022-02-10T16:59:54.000Z" itemprop="datePublished">2022-02-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/11/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/">使用hexo搭建博客</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>安装Nodejs（不能装最新的 ，应该装  …LTS的）<br>安装Nodejs时出现警告 2503 2502的:<br>任务管理器(ctrl + alt +delete)&gt;文件&gt;运行新任务（方框要勾选）&gt;在输入框中填文件的路径</p>
<p>安装淘宝镜像:npm install -g cnpm –registry&#x3D;<a target="_blank" rel="noopener" href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br>如果直接卡住:<br>npm 版本太低:升到 8.1.2</p>
<p>如果npm包损坏:<br>C:\Users\Administrator\AppData\Roaming  目录下删掉npm （有关的也删掉）文件夹<br>卸载node<br>重新安装Node</p>
<p>安装hexo:(需要在管理员身份运行的页面)npm install -g hexo-cli<br>hexo init （此处需要先创建一个空的文件夹并且在这个里面开始）初始化一个博客<br>hexo s(start的缩写) 启动博客（这里也必须是管理员身份启动的页面,powershell窗口不行）</p>
<p>管理员身份运行: 开始&gt;鼠标右击&gt;命令提示符(管理员)</p>
<p>cmd命令:<br>切换到D盘: d:<br>进入到文件夹:直接 cd source_posts<br>查看当前目录下的内容(hexo博客情况下)：ls -l<br>对自己创建的博客进行添加内容:vim  文件名.md<br>新建立一个博客  hexo new post  博客名</p>
<p>如果使用markdownpad2写博客出现警告框:<br>Awesomium插件下载链接：<br><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1za81RMtIY_FQRkPd6iJ9rQ">https://pan.baidu.com/s/1za81RMtIY_FQRkPd6iJ9rQ</a> 密码：<br>yho5<br>然后关闭，重新打开</p>
<p>如果编辑博客时出现<br>[o]pen Read-only, (E)dit anyway， ®ecover， (D)elete it，(Q)uit，<br>(A)bort<br>问题原因：编辑文件时断网或同一个文件在上一次编辑时未进行保存，则在下一次想要进行编辑时就会出现：<br>解决方法如下：<br>1、如不想编辑该文档，直接按下q就离开vim，也就是退出编辑<br>2、如想继续重新编辑该文档、按下E</p>
<p>退2层目录 : cd ..&#x2F;..&#x2F; （退到source前面一个目录下面）<br>清理:hexo clean<br>生产: hexo g</p>
<p>如果要部署在github上:</p>
<ul>
<li>新建一个仓库<br>仓库名称:昵称.github.io<br>在hexo中安装git插件：（需要在新建的目录下）cnpm install –save hexo-deployer-git<br>查看:ls<br>然后 vim _config.yml<br>滑到最下面deploy配置:<br>type: git<br>repo: 那个github上的仓库地址<br>branch: master<br>这个冒号后面一定要有一个空格</li>
</ul>
<p>写完博客后的保存退出(需要在最后一行):按ESC然后 wq:</p>
<p>若要换主题风格:<br>git clone <a target="_blank" rel="noopener" href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes&#x2F;yilia（还是在新建的那个目录下）<br><a target="_blank" rel="noopener" href="https://github.com/litten/hexo-theme-yilia%EF%BC%88%E8%BF%99%E4%B8%AA%E6%98%AF%E5%88%AB%E4%BA%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%89">https://github.com/litten/hexo-theme-yilia（这个是别人的博客）</a><br>vim _config.yml 修改theme 的值 为 yilia<br>然后清理一下 hexo clean<br>生成一下 hexo g<br>启动 hexo s(这个实在_post目录下面)</p>
<p>当建立第二个博客添加内容保存生成时报错:<br>文档里面的标签后面要有空格</p>
<p>若在本地更新内容后，远程博客上没有改变，则刷新原github上的网址,再看github上是否已提交</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/11/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" data-id="cl0pe0c9v0003gonohila5e69" data-title="使用hexo搭建博客" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/02/25/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
          </li>
        
          <li>
            <a href="/2022/02/25/%E8%AE%A1%E7%AE%97%E9%A2%98/">计算题</a>
          </li>
        
          <li>
            <a href="/2022/02/14/JS%E6%A0%B8%E5%BF%83/">JS</a>
          </li>
        
          <li>
            <a href="/2022/02/14/github%E5%AE%98%E7%BD%91%E5%BF%AB%E9%80%9F%E8%BF%9B%E5%85%A5%E7%9A%84%E6%96%B9%E6%B3%95/">github官网快速进入的方法</a>
          </li>
        
          <li>
            <a href="/2022/02/11/CSS/">CSS</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>